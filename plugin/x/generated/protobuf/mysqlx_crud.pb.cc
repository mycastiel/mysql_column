// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mysqlx_crud.proto

#include "mysqlx_crud.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)

namespace protobuf_mysqlx_5fcrud_2eproto {
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Collection;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Limit;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_Column;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_Insert_TypedRow;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_LimitExpr;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_Order;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_Projection;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_UpdateOperation;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto ::google::protobuf::internal::SCCInfo<7> scc_info_Find;
}  // namespace protobuf_mysqlx_5fcrud_2eproto
namespace protobuf_mysqlx_5fdatatypes_2eproto {
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fdatatypes_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_Scalar;
}  // namespace protobuf_mysqlx_5fdatatypes_2eproto
namespace protobuf_mysqlx_5fexpr_2eproto {
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fexpr_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_DocumentPathItem;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fexpr_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_ColumnIdentifier;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fexpr_2eproto ::google::protobuf::internal::SCCInfo<3> scc_info_Array;
}  // namespace protobuf_mysqlx_5fexpr_2eproto
namespace Mysqlx {
namespace Crud {
class ColumnDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Column>
      _instance;
} _Column_default_instance_;
class ProjectionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Projection>
      _instance;
} _Projection_default_instance_;
class CollectionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Collection>
      _instance;
} _Collection_default_instance_;
class LimitDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Limit>
      _instance;
} _Limit_default_instance_;
class LimitExprDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<LimitExpr>
      _instance;
} _LimitExpr_default_instance_;
class OrderDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Order>
      _instance;
} _Order_default_instance_;
class UpdateOperationDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<UpdateOperation>
      _instance;
} _UpdateOperation_default_instance_;
class FindDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Find>
      _instance;
} _Find_default_instance_;
class Insert_TypedRowDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Insert_TypedRow>
      _instance;
} _Insert_TypedRow_default_instance_;
class InsertDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Insert>
      _instance;
} _Insert_default_instance_;
class UpdateDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Update>
      _instance;
} _Update_default_instance_;
class DeleteDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Delete>
      _instance;
} _Delete_default_instance_;
class CreateViewDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CreateView>
      _instance;
} _CreateView_default_instance_;
class ModifyViewDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ModifyView>
      _instance;
} _ModifyView_default_instance_;
class DropViewDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<DropView>
      _instance;
} _DropView_default_instance_;
}  // namespace Crud
}  // namespace Mysqlx
namespace protobuf_mysqlx_5fcrud_2eproto {
static void InitDefaultsColumn() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Column_default_instance_;
    new (ptr) ::Mysqlx::Crud::Column();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Column::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Column =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsColumn}, {
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_DocumentPathItem.base,}};

static void InitDefaultsProjection() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Projection_default_instance_;
    new (ptr) ::Mysqlx::Crud::Projection();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Projection::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Projection =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsProjection}, {
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_Array.base,}};

static void InitDefaultsCollection() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Collection_default_instance_;
    new (ptr) ::Mysqlx::Crud::Collection();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Collection::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Collection =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsCollection}, {}};

static void InitDefaultsLimit() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Limit_default_instance_;
    new (ptr) ::Mysqlx::Crud::Limit();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Limit::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Limit =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsLimit}, {}};

static void InitDefaultsLimitExpr() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_LimitExpr_default_instance_;
    new (ptr) ::Mysqlx::Crud::LimitExpr();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::LimitExpr::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_LimitExpr =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsLimitExpr}, {
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_Array.base,}};

static void InitDefaultsOrder() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Order_default_instance_;
    new (ptr) ::Mysqlx::Crud::Order();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Order::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Order =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsOrder}, {
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_Array.base,}};

static void InitDefaultsUpdateOperation() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_UpdateOperation_default_instance_;
    new (ptr) ::Mysqlx::Crud::UpdateOperation();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::UpdateOperation::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_UpdateOperation =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsUpdateOperation}, {
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_ColumnIdentifier.base,
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_Array.base,}};

static void InitDefaultsFind() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Find_default_instance_;
    new (ptr) ::Mysqlx::Crud::Find();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Find::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<7> scc_info_Find =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 7, InitDefaultsFind}, {
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Collection.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Projection.base,
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_Array.base,
      &protobuf_mysqlx_5fdatatypes_2eproto::scc_info_Scalar.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Order.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Limit.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_LimitExpr.base,}};

static void InitDefaultsInsert_TypedRow() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Insert_TypedRow_default_instance_;
    new (ptr) ::Mysqlx::Crud::Insert_TypedRow();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Insert_TypedRow::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Insert_TypedRow =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsInsert_TypedRow}, {
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_Array.base,}};

static void InitDefaultsInsert() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Insert_default_instance_;
    new (ptr) ::Mysqlx::Crud::Insert();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Insert::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<4> scc_info_Insert =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 4, InitDefaultsInsert}, {
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Collection.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Column.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Insert_TypedRow.base,
      &protobuf_mysqlx_5fdatatypes_2eproto::scc_info_Scalar.base,}};

static void InitDefaultsUpdate() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Update_default_instance_;
    new (ptr) ::Mysqlx::Crud::Update();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Update::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<7> scc_info_Update =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 7, InitDefaultsUpdate}, {
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Collection.base,
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_Array.base,
      &protobuf_mysqlx_5fdatatypes_2eproto::scc_info_Scalar.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Order.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_UpdateOperation.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Limit.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_LimitExpr.base,}};

static void InitDefaultsDelete() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Delete_default_instance_;
    new (ptr) ::Mysqlx::Crud::Delete();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Delete::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<6> scc_info_Delete =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 6, InitDefaultsDelete}, {
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Collection.base,
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_Array.base,
      &protobuf_mysqlx_5fdatatypes_2eproto::scc_info_Scalar.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Order.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Limit.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_LimitExpr.base,}};

static void InitDefaultsCreateView() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_CreateView_default_instance_;
    new (ptr) ::Mysqlx::Crud::CreateView();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::CreateView::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_CreateView =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsCreateView}, {
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Collection.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Find.base,}};

static void InitDefaultsModifyView() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_ModifyView_default_instance_;
    new (ptr) ::Mysqlx::Crud::ModifyView();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::ModifyView::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_ModifyView =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsModifyView}, {
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Collection.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Find.base,}};

static void InitDefaultsDropView() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_DropView_default_instance_;
    new (ptr) ::Mysqlx::Crud::DropView();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::DropView::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_DropView =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsDropView}, {
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Collection.base,}};

void InitDefaults() {
  ::google::protobuf::internal::InitSCC(&scc_info_Column.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Projection.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Collection.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Limit.base);
  ::google::protobuf::internal::InitSCC(&scc_info_LimitExpr.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Order.base);
  ::google::protobuf::internal::InitSCC(&scc_info_UpdateOperation.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Find.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Insert_TypedRow.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Insert.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Update.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Delete.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CreateView.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ModifyView.base);
  ::google::protobuf::internal::InitSCC(&scc_info_DropView.base);
}

::google::protobuf::Metadata file_level_metadata[15];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[8];

const ::google::protobuf::uint32 TableStruct::offsets[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Column, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Column, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Column, name_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Column, alias_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Column, document_path_),
  0,
  1,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Projection, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Projection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Projection, source_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Projection, alias_),
  1,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Collection, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Collection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Collection, name_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Collection, schema_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Limit, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Limit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Limit, row_count_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Limit, offset_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::LimitExpr, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::LimitExpr, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::LimitExpr, row_count_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::LimitExpr, offset_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Order, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Order, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Order, expr_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Order, direction_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::UpdateOperation, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::UpdateOperation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::UpdateOperation, source_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::UpdateOperation, operation_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::UpdateOperation, value_),
  0,
  2,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Find, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Find, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Find, collection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Find, data_model_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Find, projection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Find, criteria_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Find, args_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Find, order_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Find, grouping_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Find, grouping_criteria_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Find, locking_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Find, locking_options_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Find, limit_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Find, limit_expr_),
  0,
  6,
  ~0u,
  1,
  ~0u,
  ~0u,
  ~0u,
  3,
  7,
  5,
  2,
  4,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Insert_TypedRow, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Insert_TypedRow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Insert_TypedRow, field_),
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Insert, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Insert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Insert, collection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Insert, data_model_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Insert, projection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Insert, row_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Insert, args_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Insert, upsert_),
  0,
  2,
  ~0u,
  ~0u,
  ~0u,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Update, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Update, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Update, collection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Update, data_model_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Update, criteria_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Update, args_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Update, order_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Update, operation_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Update, limit_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Update, limit_expr_),
  0,
  4,
  1,
  ~0u,
  ~0u,
  ~0u,
  2,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Delete, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Delete, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Delete, collection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Delete, data_model_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Delete, criteria_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Delete, args_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Delete, order_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Delete, limit_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::Delete, limit_expr_),
  0,
  4,
  1,
  ~0u,
  ~0u,
  2,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::CreateView, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::CreateView, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::CreateView, collection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::CreateView, definer_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::CreateView, algorithm_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::CreateView, security_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::CreateView, check_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::CreateView, column_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::CreateView, stmt_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::CreateView, replace_existing_),
  1,
  0,
  5,
  6,
  4,
  ~0u,
  2,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::ModifyView, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::ModifyView, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::ModifyView, collection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::ModifyView, definer_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::ModifyView, algorithm_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::ModifyView, security_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::ModifyView, check_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::ModifyView, column_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::ModifyView, stmt_),
  1,
  0,
  4,
  5,
  3,
  ~0u,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::DropView, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::DropView, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::DropView, collection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::Mysqlx::Crud::DropView, if_exists_),
  0,
  1,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, sizeof(::Mysqlx::Crud::Column)},
  { 11, 18, sizeof(::Mysqlx::Crud::Projection)},
  { 20, 27, sizeof(::Mysqlx::Crud::Collection)},
  { 29, 36, sizeof(::Mysqlx::Crud::Limit)},
  { 38, 45, sizeof(::Mysqlx::Crud::LimitExpr)},
  { 47, 54, sizeof(::Mysqlx::Crud::Order)},
  { 56, 64, sizeof(::Mysqlx::Crud::UpdateOperation)},
  { 67, 84, sizeof(::Mysqlx::Crud::Find)},
  { 96, 102, sizeof(::Mysqlx::Crud::Insert_TypedRow)},
  { 103, 114, sizeof(::Mysqlx::Crud::Insert)},
  { 120, 133, sizeof(::Mysqlx::Crud::Update)},
  { 141, 153, sizeof(::Mysqlx::Crud::Delete)},
  { 160, 173, sizeof(::Mysqlx::Crud::CreateView)},
  { 181, 193, sizeof(::Mysqlx::Crud::ModifyView)},
  { 200, 207, sizeof(::Mysqlx::Crud::DropView)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::Mysqlx::Crud::_Column_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Mysqlx::Crud::_Projection_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Mysqlx::Crud::_Collection_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Mysqlx::Crud::_Limit_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Mysqlx::Crud::_LimitExpr_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Mysqlx::Crud::_Order_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Mysqlx::Crud::_UpdateOperation_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Mysqlx::Crud::_Find_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Mysqlx::Crud::_Insert_TypedRow_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Mysqlx::Crud::_Insert_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Mysqlx::Crud::_Update_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Mysqlx::Crud::_Delete_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Mysqlx::Crud::_CreateView_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Mysqlx::Crud::_ModifyView_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Mysqlx::Crud::_DropView_default_instance_),
};

void protobuf_AssignDescriptors() {
  AddDescriptors();
  AssignDescriptors(
      "mysqlx_crud.proto", schemas, file_default_instances, TableStruct::offsets,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static ::google::protobuf::internal::once_flag once;
  ::google::protobuf::internal::call_once(once, protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_PROTOBUF_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 15);
}

void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
      "\n\021mysqlx_crud.proto\022\013Mysqlx.Crud\032\014mysqlx"
      ".proto\032\021mysqlx_expr.proto\032\026mysqlx_dataty"
      "pes.proto\"[\n\006Column\022\014\n\004name\030\001 \001(\t\022\r\n\005ali"
      "as\030\002 \001(\t\0224\n\rdocument_path\030\003 \003(\0132\035.Mysqlx"
      ".Expr.DocumentPathItem\">\n\nProjection\022!\n\006"
      "source\030\001 \002(\0132\021.Mysqlx.Expr.Expr\022\r\n\005alias"
      "\030\002 \001(\t\"*\n\nCollection\022\014\n\004name\030\001 \002(\t\022\016\n\006sc"
      "hema\030\002 \001(\t\"*\n\005Limit\022\021\n\trow_count\030\001 \002(\004\022\016"
      "\n\006offset\030\002 \001(\004\"T\n\tLimitExpr\022$\n\trow_count"
      "\030\001 \002(\0132\021.Mysqlx.Expr.Expr\022!\n\006offset\030\002 \001("
      "\0132\021.Mysqlx.Expr.Expr\"~\n\005Order\022\037\n\004expr\030\001 "
      "\002(\0132\021.Mysqlx.Expr.Expr\0224\n\tdirection\030\002 \001("
      "\0162\034.Mysqlx.Crud.Order.Direction:\003ASC\"\036\n\t"
      "Direction\022\007\n\003ASC\020\001\022\010\n\004DESC\020\002\"\254\002\n\017UpdateO"
      "peration\022-\n\006source\030\001 \002(\0132\035.Mysqlx.Expr.C"
      "olumnIdentifier\022:\n\toperation\030\002 \002(\0162\'.Mys"
      "qlx.Crud.UpdateOperation.UpdateType\022 \n\005v"
      "alue\030\003 \001(\0132\021.Mysqlx.Expr.Expr\"\213\001\n\nUpdate"
      "Type\022\007\n\003SET\020\001\022\017\n\013ITEM_REMOVE\020\002\022\014\n\010ITEM_S"
      "ET\020\003\022\020\n\014ITEM_REPLACE\020\004\022\016\n\nITEM_MERGE\020\005\022\020"
      "\n\014ARRAY_INSERT\020\006\022\020\n\014ARRAY_APPEND\020\007\022\017\n\013ME"
      "RGE_PATCH\020\010\"\352\004\n\004Find\022+\n\ncollection\030\002 \002(\013"
      "2\027.Mysqlx.Crud.Collection\022*\n\ndata_model\030"
      "\003 \001(\0162\026.Mysqlx.Crud.DataModel\022+\n\nproject"
      "ion\030\004 \003(\0132\027.Mysqlx.Crud.Projection\022#\n\010cr"
      "iteria\030\005 \001(\0132\021.Mysqlx.Expr.Expr\022&\n\004args\030"
      "\013 \003(\0132\030.Mysqlx.Datatypes.Scalar\022!\n\005order"
      "\030\007 \003(\0132\022.Mysqlx.Crud.Order\022#\n\010grouping\030\010"
      " \003(\0132\021.Mysqlx.Expr.Expr\022,\n\021grouping_crit"
      "eria\030\t \001(\0132\021.Mysqlx.Expr.Expr\022*\n\007locking"
      "\030\014 \001(\0162\031.Mysqlx.Crud.Find.RowLock\0229\n\017loc"
      "king_options\030\r \001(\0162 .Mysqlx.Crud.Find.Ro"
      "wLockOptions\022!\n\005limit\030\006 \001(\0132\022.Mysqlx.Cru"
      "d.Limit\022*\n\nlimit_expr\030\016 \001(\0132\026.Mysqlx.Cru"
      "d.LimitExpr\".\n\007RowLock\022\017\n\013SHARED_LOCK\020\001\022"
      "\022\n\016EXCLUSIVE_LOCK\020\002\"-\n\016RowLockOptions\022\n\n"
      "\006NOWAIT\020\001\022\017\n\013SKIP_LOCKED\020\002:\004\210\3520\021\"\250\002\n\006Ins"
      "ert\022+\n\ncollection\030\001 \002(\0132\027.Mysqlx.Crud.Co"
      "llection\022*\n\ndata_model\030\002 \001(\0162\026.Mysqlx.Cr"
      "ud.DataModel\022\'\n\nprojection\030\003 \003(\0132\023.Mysql"
      "x.Crud.Column\022)\n\003row\030\004 \003(\0132\034.Mysqlx.Crud"
      ".Insert.TypedRow\022&\n\004args\030\005 \003(\0132\030.Mysqlx."
      "Datatypes.Scalar\022\025\n\006upsert\030\006 \001(\010:\005false\032"
      ",\n\010TypedRow\022 \n\005field\030\001 \003(\0132\021.Mysqlx.Expr"
      ".Expr:\004\210\3520\022\"\327\002\n\006Update\022+\n\ncollection\030\002 \002"
      "(\0132\027.Mysqlx.Crud.Collection\022*\n\ndata_mode"
      "l\030\003 \001(\0162\026.Mysqlx.Crud.DataModel\022#\n\010crite"
      "ria\030\004 \001(\0132\021.Mysqlx.Expr.Expr\022&\n\004args\030\010 \003"
      "(\0132\030.Mysqlx.Datatypes.Scalar\022!\n\005order\030\006 "
      "\003(\0132\022.Mysqlx.Crud.Order\022/\n\toperation\030\007 \003"
      "(\0132\034.Mysqlx.Crud.UpdateOperation\022!\n\005limi"
      "t\030\005 \001(\0132\022.Mysqlx.Crud.Limit\022*\n\nlimit_exp"
      "r\030\t \001(\0132\026.Mysqlx.Crud.LimitExpr:\004\210\3520\023\"\246\002"
      "\n\006Delete\022+\n\ncollection\030\001 \002(\0132\027.Mysqlx.Cr"
      "ud.Collection\022*\n\ndata_model\030\002 \001(\0162\026.Mysq"
      "lx.Crud.DataModel\022#\n\010criteria\030\003 \001(\0132\021.My"
      "sqlx.Expr.Expr\022&\n\004args\030\006 \003(\0132\030.Mysqlx.Da"
      "tatypes.Scalar\022!\n\005order\030\005 \003(\0132\022.Mysqlx.C"
      "rud.Order\022!\n\005limit\030\004 \001(\0132\022.Mysqlx.Crud.L"
      "imit\022*\n\nlimit_expr\030\007 \001(\0132\026.Mysqlx.Crud.L"
      "imitExpr:\004\210\3520\024\"\302\002\n\nCreateView\022+\n\ncollect"
      "ion\030\001 \002(\0132\027.Mysqlx.Crud.Collection\022\017\n\007de"
      "finer\030\002 \001(\t\0228\n\talgorithm\030\003 \001(\0162\032.Mysqlx."
      "Crud.ViewAlgorithm:\tUNDEFINED\0227\n\010securit"
      "y\030\004 \001(\0162\034.Mysqlx.Crud.ViewSqlSecurity:\007D"
      "EFINER\022+\n\005check\030\005 \001(\0162\034.Mysqlx.Crud.View"
      "CheckOption\022\016\n\006column\030\006 \003(\t\022\037\n\004stmt\030\007 \002("
      "\0132\021.Mysqlx.Crud.Find\022\037\n\020replace_existing"
      "\030\010 \001(\010:\005false:\004\210\3520\036\"\215\002\n\nModifyView\022+\n\nco"
      "llection\030\001 \002(\0132\027.Mysqlx.Crud.Collection\022"
      "\017\n\007definer\030\002 \001(\t\022-\n\talgorithm\030\003 \001(\0162\032.My"
      "sqlx.Crud.ViewAlgorithm\022.\n\010security\030\004 \001("
      "\0162\034.Mysqlx.Crud.ViewSqlSecurity\022+\n\005check"
      "\030\005 \001(\0162\034.Mysqlx.Crud.ViewCheckOption\022\016\n\006"
      "column\030\006 \003(\t\022\037\n\004stmt\030\007 \001(\0132\021.Mysqlx.Crud"
      ".Find:\004\210\3520\037\"W\n\010DropView\022+\n\ncollection\030\001 "
      "\002(\0132\027.Mysqlx.Crud.Collection\022\030\n\tif_exist"
      "s\030\002 \001(\010:\005false:\004\210\3520 *$\n\tDataModel\022\014\n\010DOC"
      "UMENT\020\001\022\t\n\005TABLE\020\002*8\n\rViewAlgorithm\022\r\n\tU"
      "NDEFINED\020\001\022\t\n\005MERGE\020\002\022\r\n\tTEMPTABLE\020\003*+\n\017"
      "ViewSqlSecurity\022\013\n\007INVOKER\020\001\022\013\n\007DEFINER\020"
      "\002**\n\017ViewCheckOption\022\t\n\005LOCAL\020\001\022\014\n\010CASCA"
      "DED\020\002B\031\n\027com.mysql.cj.x.protobuf"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 3312);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "mysqlx_crud.proto", &protobuf_RegisterTypes);
  ::protobuf_mysqlx_2eproto::AddDescriptors();
  ::protobuf_mysqlx_5fexpr_2eproto::AddDescriptors();
  ::protobuf_mysqlx_5fdatatypes_2eproto::AddDescriptors();
}

void AddDescriptors() {
  static ::google::protobuf::internal::once_flag once;
  ::google::protobuf::internal::call_once(once, AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at dynamic initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
}  // namespace protobuf_mysqlx_5fcrud_2eproto
namespace Mysqlx {
namespace Crud {
const ::google::protobuf::EnumDescriptor* Order_Direction_descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_enum_descriptors[0];
}
bool Order_Direction_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Order_Direction Order::ASC;
const Order_Direction Order::DESC;
const Order_Direction Order::Direction_MIN;
const Order_Direction Order::Direction_MAX;
const int Order::Direction_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* UpdateOperation_UpdateType_descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_enum_descriptors[1];
}
bool UpdateOperation_UpdateType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const UpdateOperation_UpdateType UpdateOperation::SET;
const UpdateOperation_UpdateType UpdateOperation::ITEM_REMOVE;
const UpdateOperation_UpdateType UpdateOperation::ITEM_SET;
const UpdateOperation_UpdateType UpdateOperation::ITEM_REPLACE;
const UpdateOperation_UpdateType UpdateOperation::ITEM_MERGE;
const UpdateOperation_UpdateType UpdateOperation::ARRAY_INSERT;
const UpdateOperation_UpdateType UpdateOperation::ARRAY_APPEND;
const UpdateOperation_UpdateType UpdateOperation::MERGE_PATCH;
const UpdateOperation_UpdateType UpdateOperation::UpdateType_MIN;
const UpdateOperation_UpdateType UpdateOperation::UpdateType_MAX;
const int UpdateOperation::UpdateType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Find_RowLock_descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_enum_descriptors[2];
}
bool Find_RowLock_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Find_RowLock Find::SHARED_LOCK;
const Find_RowLock Find::EXCLUSIVE_LOCK;
const Find_RowLock Find::RowLock_MIN;
const Find_RowLock Find::RowLock_MAX;
const int Find::RowLock_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Find_RowLockOptions_descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_enum_descriptors[3];
}
bool Find_RowLockOptions_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Find_RowLockOptions Find::NOWAIT;
const Find_RowLockOptions Find::SKIP_LOCKED;
const Find_RowLockOptions Find::RowLockOptions_MIN;
const Find_RowLockOptions Find::RowLockOptions_MAX;
const int Find::RowLockOptions_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* DataModel_descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_enum_descriptors[4];
}
bool DataModel_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ViewAlgorithm_descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_enum_descriptors[5];
}
bool ViewAlgorithm_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ViewSqlSecurity_descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_enum_descriptors[6];
}
bool ViewSqlSecurity_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ViewCheckOption_descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_enum_descriptors[7];
}
bool ViewCheckOption_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void Column::InitAsDefaultInstance() {
}
void Column::clear_document_path() {
  document_path_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Column::kNameFieldNumber;
const int Column::kAliasFieldNumber;
const int Column::kDocumentPathFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Column::Column()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Column.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Column)
}
Column::Column(const Column& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      document_path_(from.document_path_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  alias_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_alias()) {
    alias_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.alias_);
  }
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Column)
}

void Column::SharedCtor() {
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  alias_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Column::~Column() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Column)
  SharedDtor();
}

void Column::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  alias_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Column::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Column::descriptor() {
  ::protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Column& Column::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Column.base);
  return *internal_default_instance();
}


void Column::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Column)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  document_path_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      alias_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Column::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Column)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), static_cast<int>(this->name().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Mysqlx.Crud.Column.name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string alias = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_alias()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->alias().data(), static_cast<int>(this->alias().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Mysqlx.Crud.Column.alias");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_document_path()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Column)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Column)
  return false;
#undef DO_
}

void Column::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Column)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Column.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string alias = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->alias().data(), static_cast<int>(this->alias().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Column.alias");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->alias(), output);
  }

  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->document_path_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3,
      this->document_path(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Column)
}

::google::protobuf::uint8* Column::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Column)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Column.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string alias = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->alias().data(), static_cast<int>(this->alias().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Column.alias");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->alias(), target);
  }

  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->document_path_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->document_path(static_cast<int>(i)), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Column)
  return target;
}

size_t Column::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Column)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->document_path_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->document_path(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 3u) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string alias = 2;
    if (has_alias()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->alias());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Column::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Column)
  GOOGLE_DCHECK_NE(&from, this);
  const Column* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Column>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Column)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Column)
    MergeFrom(*source);
  }
}

void Column::MergeFrom(const Column& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Column)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  document_path_.MergeFrom(from.document_path_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_alias();
      alias_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.alias_);
    }
  }
}

void Column::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Column)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Column::CopyFrom(const Column& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Column)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Column::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->document_path())) return false;
  return true;
}

void Column::Swap(Column* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Column::InternalSwap(Column* other) {
  using std::swap;
  CastToBase(&document_path_)->InternalSwap(CastToBase(&other->document_path_));
  name_.Swap(&other->name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  alias_.Swap(&other->alias_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Column::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Projection::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_Projection_default_instance_._instance.get_mutable()->source_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
}
void Projection::clear_source() {
  if (source_ != NULL) source_->Clear();
  clear_has_source();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Projection::kSourceFieldNumber;
const int Projection::kAliasFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Projection::Projection()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Projection.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Projection)
}
Projection::Projection(const Projection& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  alias_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_alias()) {
    alias_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.alias_);
  }
  if (from.has_source()) {
    source_ = new ::Mysqlx::Expr::Expr(*from.source_);
  } else {
    source_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Projection)
}

void Projection::SharedCtor() {
  alias_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_ = NULL;
}

Projection::~Projection() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Projection)
  SharedDtor();
}

void Projection::SharedDtor() {
  alias_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete source_;
}

void Projection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Projection::descriptor() {
  ::protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Projection& Projection::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Projection.base);
  return *internal_default_instance();
}


void Projection::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Projection)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      alias_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(source_ != NULL);
      source_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Projection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Projection)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.Expr source = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string alias = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_alias()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->alias().data(), static_cast<int>(this->alias().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Mysqlx.Crud.Projection.alias");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Projection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Projection)
  return false;
#undef DO_
}

void Projection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Projection)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Expr.Expr source = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_source(), output);
  }

  // optional string alias = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->alias().data(), static_cast<int>(this->alias().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Projection.alias");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->alias(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Projection)
}

::google::protobuf::uint8* Projection::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Projection)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Expr.Expr source = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_source(), deterministic, target);
  }

  // optional string alias = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->alias().data(), static_cast<int>(this->alias().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Projection.alias");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->alias(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Projection)
  return target;
}

size_t Projection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Projection)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .Mysqlx.Expr.Expr source = 1;
  if (has_source()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *source_);
  }
  // optional string alias = 2;
  if (has_alias()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->alias());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Projection::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Projection)
  GOOGLE_DCHECK_NE(&from, this);
  const Projection* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Projection>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Projection)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Projection)
    MergeFrom(*source);
  }
}

void Projection::MergeFrom(const Projection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Projection)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_alias();
      alias_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.alias_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_source()->::Mysqlx::Expr::Expr::MergeFrom(from.source());
    }
  }
}

void Projection::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Projection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Projection::CopyFrom(const Projection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Projection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Projection::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (has_source()) {
    if (!this->source_->IsInitialized()) return false;
  }
  return true;
}

void Projection::Swap(Projection* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Projection::InternalSwap(Projection* other) {
  using std::swap;
  alias_.Swap(&other->alias_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(source_, other->source_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Projection::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Collection::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Collection::kNameFieldNumber;
const int Collection::kSchemaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Collection::Collection()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Collection.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Collection)
}
Collection::Collection(const Collection& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  schema_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_schema()) {
    schema_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.schema_);
  }
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Collection)
}

void Collection::SharedCtor() {
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  schema_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Collection::~Collection() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Collection)
  SharedDtor();
}

void Collection::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  schema_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Collection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Collection::descriptor() {
  ::protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Collection& Collection::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Collection.base);
  return *internal_default_instance();
}


void Collection::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Collection)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      schema_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Collection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Collection)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), static_cast<int>(this->name().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Mysqlx.Crud.Collection.name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string schema = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_schema()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->schema().data(), static_cast<int>(this->schema().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Mysqlx.Crud.Collection.schema");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Collection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Collection)
  return false;
#undef DO_
}

void Collection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Collection)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Collection.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string schema = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->schema().data(), static_cast<int>(this->schema().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Collection.schema");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->schema(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Collection)
}

::google::protobuf::uint8* Collection::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Collection)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Collection.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string schema = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->schema().data(), static_cast<int>(this->schema().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Collection.schema");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->schema(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Collection)
  return target;
}

size_t Collection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Collection)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required string name = 1;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }
  // optional string schema = 2;
  if (has_schema()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->schema());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Collection::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Collection)
  GOOGLE_DCHECK_NE(&from, this);
  const Collection* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Collection>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Collection)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Collection)
    MergeFrom(*source);
  }
}

void Collection::MergeFrom(const Collection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Collection)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_schema();
      schema_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.schema_);
    }
  }
}

void Collection::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Collection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Collection::CopyFrom(const Collection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Collection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Collection::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Collection::Swap(Collection* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Collection::InternalSwap(Collection* other) {
  using std::swap;
  name_.Swap(&other->name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  schema_.Swap(&other->schema_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Collection::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Limit::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Limit::kRowCountFieldNumber;
const int Limit::kOffsetFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Limit::Limit()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Limit.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Limit)
}
Limit::Limit(const Limit& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&row_count_, &from.row_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&offset_) -
    reinterpret_cast<char*>(&row_count_)) + sizeof(offset_));
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Limit)
}

void Limit::SharedCtor() {
  ::memset(&row_count_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&offset_) -
      reinterpret_cast<char*>(&row_count_)) + sizeof(offset_));
}

Limit::~Limit() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Limit)
  SharedDtor();
}

void Limit::SharedDtor() {
}

void Limit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Limit::descriptor() {
  ::protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Limit& Limit::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Limit.base);
  return *internal_default_instance();
}


void Limit::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Limit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    ::memset(&row_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&offset_) -
        reinterpret_cast<char*>(&row_count_)) + sizeof(offset_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Limit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Limit)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 row_count = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_row_count();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &row_count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 offset = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_offset();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Limit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Limit)
  return false;
#undef DO_
}

void Limit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Limit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 row_count = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->row_count(), output);
  }

  // optional uint64 offset = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->offset(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Limit)
}

::google::protobuf::uint8* Limit::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Limit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 row_count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->row_count(), target);
  }

  // optional uint64 offset = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->offset(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Limit)
  return target;
}

size_t Limit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Limit)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required uint64 row_count = 1;
  if (has_row_count()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->row_count());
  }
  // optional uint64 offset = 2;
  if (has_offset()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->offset());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Limit::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Limit)
  GOOGLE_DCHECK_NE(&from, this);
  const Limit* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Limit>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Limit)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Limit)
    MergeFrom(*source);
  }
}

void Limit::MergeFrom(const Limit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Limit)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      row_count_ = from.row_count_;
    }
    if (cached_has_bits & 0x00000002u) {
      offset_ = from.offset_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Limit::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Limit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Limit::CopyFrom(const Limit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Limit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Limit::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Limit::Swap(Limit* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Limit::InternalSwap(Limit* other) {
  using std::swap;
  swap(row_count_, other->row_count_);
  swap(offset_, other->offset_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Limit::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void LimitExpr::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_LimitExpr_default_instance_._instance.get_mutable()->row_count_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  ::Mysqlx::Crud::_LimitExpr_default_instance_._instance.get_mutable()->offset_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
}
void LimitExpr::clear_row_count() {
  if (row_count_ != NULL) row_count_->Clear();
  clear_has_row_count();
}
void LimitExpr::clear_offset() {
  if (offset_ != NULL) offset_->Clear();
  clear_has_offset();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LimitExpr::kRowCountFieldNumber;
const int LimitExpr::kOffsetFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LimitExpr::LimitExpr()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_LimitExpr.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.LimitExpr)
}
LimitExpr::LimitExpr(const LimitExpr& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_row_count()) {
    row_count_ = new ::Mysqlx::Expr::Expr(*from.row_count_);
  } else {
    row_count_ = NULL;
  }
  if (from.has_offset()) {
    offset_ = new ::Mysqlx::Expr::Expr(*from.offset_);
  } else {
    offset_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.LimitExpr)
}

void LimitExpr::SharedCtor() {
  ::memset(&row_count_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&offset_) -
      reinterpret_cast<char*>(&row_count_)) + sizeof(offset_));
}

LimitExpr::~LimitExpr() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.LimitExpr)
  SharedDtor();
}

void LimitExpr::SharedDtor() {
  if (this != internal_default_instance()) delete row_count_;
  if (this != internal_default_instance()) delete offset_;
}

void LimitExpr::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* LimitExpr::descriptor() {
  ::protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const LimitExpr& LimitExpr::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_LimitExpr.base);
  return *internal_default_instance();
}


void LimitExpr::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.LimitExpr)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(row_count_ != NULL);
      row_count_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(offset_ != NULL);
      offset_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool LimitExpr::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.LimitExpr)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.Expr row_count = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_row_count()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Expr.Expr offset = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_offset()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.LimitExpr)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.LimitExpr)
  return false;
#undef DO_
}

void LimitExpr::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.LimitExpr)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Expr.Expr row_count = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_row_count(), output);
  }

  // optional .Mysqlx.Expr.Expr offset = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_offset(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.LimitExpr)
}

::google::protobuf::uint8* LimitExpr::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.LimitExpr)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Expr.Expr row_count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_row_count(), deterministic, target);
  }

  // optional .Mysqlx.Expr.Expr offset = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_offset(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.LimitExpr)
  return target;
}

size_t LimitExpr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.LimitExpr)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .Mysqlx.Expr.Expr row_count = 1;
  if (has_row_count()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *row_count_);
  }
  // optional .Mysqlx.Expr.Expr offset = 2;
  if (has_offset()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *offset_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LimitExpr::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.LimitExpr)
  GOOGLE_DCHECK_NE(&from, this);
  const LimitExpr* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const LimitExpr>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.LimitExpr)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.LimitExpr)
    MergeFrom(*source);
  }
}

void LimitExpr::MergeFrom(const LimitExpr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.LimitExpr)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_row_count()->::Mysqlx::Expr::Expr::MergeFrom(from.row_count());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_offset()->::Mysqlx::Expr::Expr::MergeFrom(from.offset());
    }
  }
}

void LimitExpr::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.LimitExpr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LimitExpr::CopyFrom(const LimitExpr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.LimitExpr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LimitExpr::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_row_count()) {
    if (!this->row_count_->IsInitialized()) return false;
  }
  if (has_offset()) {
    if (!this->offset_->IsInitialized()) return false;
  }
  return true;
}

void LimitExpr::Swap(LimitExpr* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LimitExpr::InternalSwap(LimitExpr* other) {
  using std::swap;
  swap(row_count_, other->row_count_);
  swap(offset_, other->offset_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata LimitExpr::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Order::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_Order_default_instance_._instance.get_mutable()->expr_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
}
void Order::clear_expr() {
  if (expr_ != NULL) expr_->Clear();
  clear_has_expr();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Order::kExprFieldNumber;
const int Order::kDirectionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Order::Order()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Order.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Order)
}
Order::Order(const Order& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_expr()) {
    expr_ = new ::Mysqlx::Expr::Expr(*from.expr_);
  } else {
    expr_ = NULL;
  }
  direction_ = from.direction_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Order)
}

void Order::SharedCtor() {
  expr_ = NULL;
  direction_ = 1;
}

Order::~Order() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Order)
  SharedDtor();
}

void Order::SharedDtor() {
  if (this != internal_default_instance()) delete expr_;
}

void Order::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Order::descriptor() {
  ::protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Order& Order::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Order.base);
  return *internal_default_instance();
}


void Order::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Order)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(expr_ != NULL);
      expr_->Clear();
    }
    direction_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Order::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Order)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.Expr expr = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_expr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::Order_Direction_IsValid(value)) {
            set_direction(static_cast< ::Mysqlx::Crud::Order_Direction >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Order)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Order)
  return false;
#undef DO_
}

void Order::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Order)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Expr.Expr expr = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_expr(), output);
  }

  // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->direction(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Order)
}

::google::protobuf::uint8* Order::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Order)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Expr.Expr expr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_expr(), deterministic, target);
  }

  // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->direction(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Order)
  return target;
}

size_t Order::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Order)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .Mysqlx.Expr.Expr expr = 1;
  if (has_expr()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *expr_);
  }
  // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
  if (has_direction()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->direction());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Order::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Order)
  GOOGLE_DCHECK_NE(&from, this);
  const Order* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Order>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Order)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Order)
    MergeFrom(*source);
  }
}

void Order::MergeFrom(const Order& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Order)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_expr()->::Mysqlx::Expr::Expr::MergeFrom(from.expr());
    }
    if (cached_has_bits & 0x00000002u) {
      direction_ = from.direction_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Order::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Order)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Order::CopyFrom(const Order& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Order)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Order::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_expr()) {
    if (!this->expr_->IsInitialized()) return false;
  }
  return true;
}

void Order::Swap(Order* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Order::InternalSwap(Order* other) {
  using std::swap;
  swap(expr_, other->expr_);
  swap(direction_, other->direction_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Order::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void UpdateOperation::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_UpdateOperation_default_instance_._instance.get_mutable()->source_ = const_cast< ::Mysqlx::Expr::ColumnIdentifier*>(
      ::Mysqlx::Expr::ColumnIdentifier::internal_default_instance());
  ::Mysqlx::Crud::_UpdateOperation_default_instance_._instance.get_mutable()->value_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
}
void UpdateOperation::clear_source() {
  if (source_ != NULL) source_->Clear();
  clear_has_source();
}
void UpdateOperation::clear_value() {
  if (value_ != NULL) value_->Clear();
  clear_has_value();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UpdateOperation::kSourceFieldNumber;
const int UpdateOperation::kOperationFieldNumber;
const int UpdateOperation::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UpdateOperation::UpdateOperation()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_UpdateOperation.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.UpdateOperation)
}
UpdateOperation::UpdateOperation(const UpdateOperation& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_source()) {
    source_ = new ::Mysqlx::Expr::ColumnIdentifier(*from.source_);
  } else {
    source_ = NULL;
  }
  if (from.has_value()) {
    value_ = new ::Mysqlx::Expr::Expr(*from.value_);
  } else {
    value_ = NULL;
  }
  operation_ = from.operation_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.UpdateOperation)
}

void UpdateOperation::SharedCtor() {
  ::memset(&source_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&value_) -
      reinterpret_cast<char*>(&source_)) + sizeof(value_));
  operation_ = 1;
}

UpdateOperation::~UpdateOperation() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.UpdateOperation)
  SharedDtor();
}

void UpdateOperation::SharedDtor() {
  if (this != internal_default_instance()) delete source_;
  if (this != internal_default_instance()) delete value_;
}

void UpdateOperation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* UpdateOperation::descriptor() {
  ::protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const UpdateOperation& UpdateOperation::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_UpdateOperation.base);
  return *internal_default_instance();
}


void UpdateOperation::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.UpdateOperation)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(source_ != NULL);
      source_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(value_ != NULL);
      value_->Clear();
    }
    operation_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool UpdateOperation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.UpdateOperation)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.ColumnIdentifier source = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::UpdateOperation_UpdateType_IsValid(value)) {
            set_operation(static_cast< ::Mysqlx::Crud::UpdateOperation_UpdateType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Expr.Expr value = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.UpdateOperation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.UpdateOperation)
  return false;
#undef DO_
}

void UpdateOperation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.UpdateOperation)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Expr.ColumnIdentifier source = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_source(), output);
  }

  // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->operation(), output);
  }

  // optional .Mysqlx.Expr.Expr value = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->_internal_value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.UpdateOperation)
}

::google::protobuf::uint8* UpdateOperation::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.UpdateOperation)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Expr.ColumnIdentifier source = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_source(), deterministic, target);
  }

  // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->operation(), target);
  }

  // optional .Mysqlx.Expr.Expr value = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->_internal_value(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.UpdateOperation)
  return target;
}

size_t UpdateOperation::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Mysqlx.Crud.UpdateOperation)
  size_t total_size = 0;

  if (has_source()) {
    // required .Mysqlx.Expr.ColumnIdentifier source = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *source_);
  }

  if (has_operation()) {
    // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->operation());
  }

  return total_size;
}
size_t UpdateOperation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.UpdateOperation)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required .Mysqlx.Expr.ColumnIdentifier source = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *source_);

    // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->operation());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional .Mysqlx.Expr.Expr value = 3;
  if (has_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *value_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UpdateOperation::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.UpdateOperation)
  GOOGLE_DCHECK_NE(&from, this);
  const UpdateOperation* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const UpdateOperation>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.UpdateOperation)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.UpdateOperation)
    MergeFrom(*source);
  }
}

void UpdateOperation::MergeFrom(const UpdateOperation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.UpdateOperation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_source()->::Mysqlx::Expr::ColumnIdentifier::MergeFrom(from.source());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_value()->::Mysqlx::Expr::Expr::MergeFrom(from.value());
    }
    if (cached_has_bits & 0x00000004u) {
      operation_ = from.operation_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UpdateOperation::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.UpdateOperation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UpdateOperation::CopyFrom(const UpdateOperation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.UpdateOperation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateOperation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;
  if (has_source()) {
    if (!this->source_->IsInitialized()) return false;
  }
  if (has_value()) {
    if (!this->value_->IsInitialized()) return false;
  }
  return true;
}

void UpdateOperation::Swap(UpdateOperation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UpdateOperation::InternalSwap(UpdateOperation* other) {
  using std::swap;
  swap(source_, other->source_);
  swap(value_, other->value_);
  swap(operation_, other->operation_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata UpdateOperation::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Find::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_Find_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  ::Mysqlx::Crud::_Find_default_instance_._instance.get_mutable()->criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  ::Mysqlx::Crud::_Find_default_instance_._instance.get_mutable()->grouping_criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  ::Mysqlx::Crud::_Find_default_instance_._instance.get_mutable()->limit_ = const_cast< ::Mysqlx::Crud::Limit*>(
      ::Mysqlx::Crud::Limit::internal_default_instance());
  ::Mysqlx::Crud::_Find_default_instance_._instance.get_mutable()->limit_expr_ = const_cast< ::Mysqlx::Crud::LimitExpr*>(
      ::Mysqlx::Crud::LimitExpr::internal_default_instance());
}
void Find::clear_criteria() {
  if (criteria_ != NULL) criteria_->Clear();
  clear_has_criteria();
}
void Find::clear_args() {
  args_.Clear();
}
void Find::clear_grouping() {
  grouping_.Clear();
}
void Find::clear_grouping_criteria() {
  if (grouping_criteria_ != NULL) grouping_criteria_->Clear();
  clear_has_grouping_criteria();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Find::kCollectionFieldNumber;
const int Find::kDataModelFieldNumber;
const int Find::kProjectionFieldNumber;
const int Find::kCriteriaFieldNumber;
const int Find::kArgsFieldNumber;
const int Find::kOrderFieldNumber;
const int Find::kGroupingFieldNumber;
const int Find::kGroupingCriteriaFieldNumber;
const int Find::kLockingFieldNumber;
const int Find::kLockingOptionsFieldNumber;
const int Find::kLimitFieldNumber;
const int Find::kLimitExprFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Find::Find()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Find.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Find)
}
Find::Find(const Find& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      projection_(from.projection_),
      order_(from.order_),
      grouping_(from.grouping_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = NULL;
  }
  if (from.has_criteria()) {
    criteria_ = new ::Mysqlx::Expr::Expr(*from.criteria_);
  } else {
    criteria_ = NULL;
  }
  if (from.has_limit()) {
    limit_ = new ::Mysqlx::Crud::Limit(*from.limit_);
  } else {
    limit_ = NULL;
  }
  if (from.has_grouping_criteria()) {
    grouping_criteria_ = new ::Mysqlx::Expr::Expr(*from.grouping_criteria_);
  } else {
    grouping_criteria_ = NULL;
  }
  if (from.has_limit_expr()) {
    limit_expr_ = new ::Mysqlx::Crud::LimitExpr(*from.limit_expr_);
  } else {
    limit_expr_ = NULL;
  }
  ::memcpy(&locking_options_, &from.locking_options_,
    static_cast<size_t>(reinterpret_cast<char*>(&locking_) -
    reinterpret_cast<char*>(&locking_options_)) + sizeof(locking_));
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Find)
}

void Find::SharedCtor() {
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&limit_expr_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(limit_expr_));
  locking_options_ = 1;
  data_model_ = 1;
  locking_ = 1;
}

Find::~Find() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Find)
  SharedDtor();
}

void Find::SharedDtor() {
  if (this != internal_default_instance()) delete collection_;
  if (this != internal_default_instance()) delete criteria_;
  if (this != internal_default_instance()) delete limit_;
  if (this != internal_default_instance()) delete grouping_criteria_;
  if (this != internal_default_instance()) delete limit_expr_;
}

void Find::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Find::descriptor() {
  ::protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Find& Find::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Find.base);
  return *internal_default_instance();
}


void Find::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Find)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  projection_.Clear();
  order_.Clear();
  grouping_.Clear();
  args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(collection_ != NULL);
      collection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(criteria_ != NULL);
      criteria_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(limit_ != NULL);
      limit_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(grouping_criteria_ != NULL);
      grouping_criteria_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(limit_expr_ != NULL);
      limit_expr_->Clear();
    }
    locking_options_ = 1;
    data_model_ = 1;
    locking_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Find::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Find)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.Projection projection = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_projection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Expr.Expr criteria = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_criteria()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.Limit limit = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_limit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.Order order = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_order()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Expr.Expr grouping = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u /* 66 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_grouping()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u /* 74 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_grouping_criteria()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(90u /* 90 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.Find.RowLock locking = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(96u /* 96 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::Find_RowLock_IsValid(value)) {
            set_locking(static_cast< ::Mysqlx::Crud::Find_RowLock >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                12, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.Find.RowLockOptions locking_options = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(104u /* 104 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::Find_RowLockOptions_IsValid(value)) {
            set_locking_options(static_cast< ::Mysqlx::Crud::Find_RowLockOptions >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                13, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.LimitExpr limit_expr = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(114u /* 114 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_limit_expr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Find)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Find)
  return false;
#undef DO_
}

void Find::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Find)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_collection(), output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->data_model(), output);
  }

  // repeated .Mysqlx.Crud.Projection projection = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->projection_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4,
      this->projection(static_cast<int>(i)),
      output);
  }

  // optional .Mysqlx.Expr.Expr criteria = 5;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->_internal_criteria(), output);
  }

  // optional .Mysqlx.Crud.Limit limit = 6;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->_internal_limit(), output);
  }

  // repeated .Mysqlx.Crud.Order order = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->order_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7,
      this->order(static_cast<int>(i)),
      output);
  }

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->grouping_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8,
      this->grouping(static_cast<int>(i)),
      output);
  }

  // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->_internal_grouping_criteria(), output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->args_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11,
      this->args(static_cast<int>(i)),
      output);
  }

  // optional .Mysqlx.Crud.Find.RowLock locking = 12;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      12, this->locking(), output);
  }

  // optional .Mysqlx.Crud.Find.RowLockOptions locking_options = 13;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      13, this->locking_options(), output);
  }

  // optional .Mysqlx.Crud.LimitExpr limit_expr = 14;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, this->_internal_limit_expr(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Find)
}

::google::protobuf::uint8* Find::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Find)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_collection(), deterministic, target);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->data_model(), target);
  }

  // repeated .Mysqlx.Crud.Projection projection = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->projection_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->projection(static_cast<int>(i)), deterministic, target);
  }

  // optional .Mysqlx.Expr.Expr criteria = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->_internal_criteria(), deterministic, target);
  }

  // optional .Mysqlx.Crud.Limit limit = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, this->_internal_limit(), deterministic, target);
  }

  // repeated .Mysqlx.Crud.Order order = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->order_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, this->order(static_cast<int>(i)), deterministic, target);
  }

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->grouping_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, this->grouping(static_cast<int>(i)), deterministic, target);
  }

  // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        9, this->_internal_grouping_criteria(), deterministic, target);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->args_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        11, this->args(static_cast<int>(i)), deterministic, target);
  }

  // optional .Mysqlx.Crud.Find.RowLock locking = 12;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      12, this->locking(), target);
  }

  // optional .Mysqlx.Crud.Find.RowLockOptions locking_options = 13;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      13, this->locking_options(), target);
  }

  // optional .Mysqlx.Crud.LimitExpr limit_expr = 14;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        14, this->_internal_limit_expr(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Find)
  return target;
}

size_t Find::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Find)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .Mysqlx.Crud.Collection collection = 2;
  if (has_collection()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *collection_);
  }
  // repeated .Mysqlx.Crud.Projection projection = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->projection_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->projection(static_cast<int>(i)));
    }
  }

  // repeated .Mysqlx.Crud.Order order = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->order_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->order(static_cast<int>(i)));
    }
  }

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  {
    unsigned int count = static_cast<unsigned int>(this->grouping_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->grouping(static_cast<int>(i)));
    }
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  {
    unsigned int count = static_cast<unsigned int>(this->args_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->args(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 254u) {
    // optional .Mysqlx.Expr.Expr criteria = 5;
    if (has_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *criteria_);
    }

    // optional .Mysqlx.Crud.Limit limit = 6;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *limit_);
    }

    // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
    if (has_grouping_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *grouping_criteria_);
    }

    // optional .Mysqlx.Crud.LimitExpr limit_expr = 14;
    if (has_limit_expr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *limit_expr_);
    }

    // optional .Mysqlx.Crud.Find.RowLockOptions locking_options = 13;
    if (has_locking_options()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->locking_options());
    }

    // optional .Mysqlx.Crud.DataModel data_model = 3;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

    // optional .Mysqlx.Crud.Find.RowLock locking = 12;
    if (has_locking()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->locking());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Find::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Find)
  GOOGLE_DCHECK_NE(&from, this);
  const Find* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Find>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Find)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Find)
    MergeFrom(*source);
  }
}

void Find::MergeFrom(const Find& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Find)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  projection_.MergeFrom(from.projection_);
  order_.MergeFrom(from.order_);
  grouping_.MergeFrom(from.grouping_);
  args_.MergeFrom(from.args_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.criteria());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_limit()->::Mysqlx::Crud::Limit::MergeFrom(from.limit());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_grouping_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.grouping_criteria());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_limit_expr()->::Mysqlx::Crud::LimitExpr::MergeFrom(from.limit_expr());
    }
    if (cached_has_bits & 0x00000020u) {
      locking_options_ = from.locking_options_;
    }
    if (cached_has_bits & 0x00000040u) {
      data_model_ = from.data_model_;
    }
    if (cached_has_bits & 0x00000080u) {
      locking_ = from.locking_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Find::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Find)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Find::CopyFrom(const Find& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Find)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Find::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->projection())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->order())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->grouping())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  if (has_collection()) {
    if (!this->collection_->IsInitialized()) return false;
  }
  if (has_criteria()) {
    if (!this->criteria_->IsInitialized()) return false;
  }
  if (has_limit()) {
    if (!this->limit_->IsInitialized()) return false;
  }
  if (has_grouping_criteria()) {
    if (!this->grouping_criteria_->IsInitialized()) return false;
  }
  if (has_limit_expr()) {
    if (!this->limit_expr_->IsInitialized()) return false;
  }
  return true;
}

void Find::Swap(Find* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Find::InternalSwap(Find* other) {
  using std::swap;
  CastToBase(&projection_)->InternalSwap(CastToBase(&other->projection_));
  CastToBase(&order_)->InternalSwap(CastToBase(&other->order_));
  CastToBase(&grouping_)->InternalSwap(CastToBase(&other->grouping_));
  CastToBase(&args_)->InternalSwap(CastToBase(&other->args_));
  swap(collection_, other->collection_);
  swap(criteria_, other->criteria_);
  swap(limit_, other->limit_);
  swap(grouping_criteria_, other->grouping_criteria_);
  swap(limit_expr_, other->limit_expr_);
  swap(locking_options_, other->locking_options_);
  swap(data_model_, other->data_model_);
  swap(locking_, other->locking_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Find::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Insert_TypedRow::InitAsDefaultInstance() {
}
void Insert_TypedRow::clear_field() {
  field_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Insert_TypedRow::kFieldFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Insert_TypedRow::Insert_TypedRow()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Insert_TypedRow.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Insert.TypedRow)
}
Insert_TypedRow::Insert_TypedRow(const Insert_TypedRow& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      field_(from.field_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Insert.TypedRow)
}

void Insert_TypedRow::SharedCtor() {
}

Insert_TypedRow::~Insert_TypedRow() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Insert.TypedRow)
  SharedDtor();
}

void Insert_TypedRow::SharedDtor() {
}

void Insert_TypedRow::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Insert_TypedRow::descriptor() {
  ::protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Insert_TypedRow& Insert_TypedRow::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Insert_TypedRow.base);
  return *internal_default_instance();
}


void Insert_TypedRow::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Insert.TypedRow)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  field_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Insert_TypedRow::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Insert.TypedRow)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Mysqlx.Expr.Expr field = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_field()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Insert.TypedRow)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Insert.TypedRow)
  return false;
#undef DO_
}

void Insert_TypedRow::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Insert.TypedRow)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Mysqlx.Expr.Expr field = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->field_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->field(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Insert.TypedRow)
}

::google::protobuf::uint8* Insert_TypedRow::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Insert.TypedRow)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Mysqlx.Expr.Expr field = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->field_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->field(static_cast<int>(i)), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Insert.TypedRow)
  return target;
}

size_t Insert_TypedRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Insert.TypedRow)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated .Mysqlx.Expr.Expr field = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->field_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->field(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Insert_TypedRow::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Insert.TypedRow)
  GOOGLE_DCHECK_NE(&from, this);
  const Insert_TypedRow* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Insert_TypedRow>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Insert.TypedRow)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Insert.TypedRow)
    MergeFrom(*source);
  }
}

void Insert_TypedRow::MergeFrom(const Insert_TypedRow& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Insert.TypedRow)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  field_.MergeFrom(from.field_);
}

void Insert_TypedRow::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Insert.TypedRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Insert_TypedRow::CopyFrom(const Insert_TypedRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Insert.TypedRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Insert_TypedRow::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->field())) return false;
  return true;
}

void Insert_TypedRow::Swap(Insert_TypedRow* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Insert_TypedRow::InternalSwap(Insert_TypedRow* other) {
  using std::swap;
  CastToBase(&field_)->InternalSwap(CastToBase(&other->field_));
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Insert_TypedRow::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Insert::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_Insert_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
}
void Insert::clear_args() {
  args_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Insert::kCollectionFieldNumber;
const int Insert::kDataModelFieldNumber;
const int Insert::kProjectionFieldNumber;
const int Insert::kRowFieldNumber;
const int Insert::kArgsFieldNumber;
const int Insert::kUpsertFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Insert::Insert()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Insert.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Insert)
}
Insert::Insert(const Insert& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      projection_(from.projection_),
      row_(from.row_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = NULL;
  }
  ::memcpy(&upsert_, &from.upsert_,
    static_cast<size_t>(reinterpret_cast<char*>(&data_model_) -
    reinterpret_cast<char*>(&upsert_)) + sizeof(data_model_));
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Insert)
}

void Insert::SharedCtor() {
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&upsert_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(upsert_));
  data_model_ = 1;
}

Insert::~Insert() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Insert)
  SharedDtor();
}

void Insert::SharedDtor() {
  if (this != internal_default_instance()) delete collection_;
}

void Insert::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Insert::descriptor() {
  ::protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Insert& Insert::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Insert.base);
  return *internal_default_instance();
}


void Insert::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Insert)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  projection_.Clear();
  row_.Clear();
  args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(collection_ != NULL);
    collection_->Clear();
  }
  if (cached_has_bits & 6u) {
    upsert_ = false;
    data_model_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Insert::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Insert)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.Column projection = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_projection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_row()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool upsert = 6 [default = false];
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          set_has_upsert();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &upsert_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Insert)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Insert)
  return false;
#undef DO_
}

void Insert::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Insert)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_collection(), output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->data_model(), output);
  }

  // repeated .Mysqlx.Crud.Column projection = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->projection_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3,
      this->projection(static_cast<int>(i)),
      output);
  }

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->row_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4,
      this->row(static_cast<int>(i)),
      output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->args_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5,
      this->args(static_cast<int>(i)),
      output);
  }

  // optional bool upsert = 6 [default = false];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->upsert(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Insert)
}

::google::protobuf::uint8* Insert::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Insert)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_collection(), deterministic, target);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->data_model(), target);
  }

  // repeated .Mysqlx.Crud.Column projection = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->projection_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->projection(static_cast<int>(i)), deterministic, target);
  }

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->row_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->row(static_cast<int>(i)), deterministic, target);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->args_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->args(static_cast<int>(i)), deterministic, target);
  }

  // optional bool upsert = 6 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->upsert(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Insert)
  return target;
}

size_t Insert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Insert)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *collection_);
  }
  // repeated .Mysqlx.Crud.Column projection = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->projection_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->projection(static_cast<int>(i)));
    }
  }

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->row_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->row(static_cast<int>(i)));
    }
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->args_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->args(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 6u) {
    // optional bool upsert = 6 [default = false];
    if (has_upsert()) {
      total_size += 1 + 1;
    }

    // optional .Mysqlx.Crud.DataModel data_model = 2;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Insert::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Insert)
  GOOGLE_DCHECK_NE(&from, this);
  const Insert* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Insert>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Insert)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Insert)
    MergeFrom(*source);
  }
}

void Insert::MergeFrom(const Insert& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Insert)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  projection_.MergeFrom(from.projection_);
  row_.MergeFrom(from.row_);
  args_.MergeFrom(from.args_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (cached_has_bits & 0x00000002u) {
      upsert_ = from.upsert_;
    }
    if (cached_has_bits & 0x00000004u) {
      data_model_ = from.data_model_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Insert::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Insert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Insert::CopyFrom(const Insert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Insert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Insert::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->projection())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->row())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  if (has_collection()) {
    if (!this->collection_->IsInitialized()) return false;
  }
  return true;
}

void Insert::Swap(Insert* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Insert::InternalSwap(Insert* other) {
  using std::swap;
  CastToBase(&projection_)->InternalSwap(CastToBase(&other->projection_));
  CastToBase(&row_)->InternalSwap(CastToBase(&other->row_));
  CastToBase(&args_)->InternalSwap(CastToBase(&other->args_));
  swap(collection_, other->collection_);
  swap(upsert_, other->upsert_);
  swap(data_model_, other->data_model_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Insert::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Update::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_Update_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  ::Mysqlx::Crud::_Update_default_instance_._instance.get_mutable()->criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  ::Mysqlx::Crud::_Update_default_instance_._instance.get_mutable()->limit_ = const_cast< ::Mysqlx::Crud::Limit*>(
      ::Mysqlx::Crud::Limit::internal_default_instance());
  ::Mysqlx::Crud::_Update_default_instance_._instance.get_mutable()->limit_expr_ = const_cast< ::Mysqlx::Crud::LimitExpr*>(
      ::Mysqlx::Crud::LimitExpr::internal_default_instance());
}
void Update::clear_criteria() {
  if (criteria_ != NULL) criteria_->Clear();
  clear_has_criteria();
}
void Update::clear_args() {
  args_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Update::kCollectionFieldNumber;
const int Update::kDataModelFieldNumber;
const int Update::kCriteriaFieldNumber;
const int Update::kArgsFieldNumber;
const int Update::kOrderFieldNumber;
const int Update::kOperationFieldNumber;
const int Update::kLimitFieldNumber;
const int Update::kLimitExprFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Update::Update()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Update.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Update)
}
Update::Update(const Update& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      order_(from.order_),
      operation_(from.operation_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = NULL;
  }
  if (from.has_criteria()) {
    criteria_ = new ::Mysqlx::Expr::Expr(*from.criteria_);
  } else {
    criteria_ = NULL;
  }
  if (from.has_limit()) {
    limit_ = new ::Mysqlx::Crud::Limit(*from.limit_);
  } else {
    limit_ = NULL;
  }
  if (from.has_limit_expr()) {
    limit_expr_ = new ::Mysqlx::Crud::LimitExpr(*from.limit_expr_);
  } else {
    limit_expr_ = NULL;
  }
  data_model_ = from.data_model_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Update)
}

void Update::SharedCtor() {
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&limit_expr_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(limit_expr_));
  data_model_ = 1;
}

Update::~Update() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Update)
  SharedDtor();
}

void Update::SharedDtor() {
  if (this != internal_default_instance()) delete collection_;
  if (this != internal_default_instance()) delete criteria_;
  if (this != internal_default_instance()) delete limit_;
  if (this != internal_default_instance()) delete limit_expr_;
}

void Update::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Update::descriptor() {
  ::protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Update& Update::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Update.base);
  return *internal_default_instance();
}


void Update::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Update)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  order_.Clear();
  operation_.Clear();
  args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(collection_ != NULL);
      collection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(criteria_ != NULL);
      criteria_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(limit_ != NULL);
      limit_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(limit_expr_ != NULL);
      limit_expr_->Clear();
    }
    data_model_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Update::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Update)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Expr.Expr criteria = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_criteria()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.Limit limit = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_limit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.Order order = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_order()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_operation()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u /* 66 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.LimitExpr limit_expr = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u /* 74 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_limit_expr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Update)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Update)
  return false;
#undef DO_
}

void Update::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Update)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_collection(), output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->data_model(), output);
  }

  // optional .Mysqlx.Expr.Expr criteria = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->_internal_criteria(), output);
  }

  // optional .Mysqlx.Crud.Limit limit = 5;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->_internal_limit(), output);
  }

  // repeated .Mysqlx.Crud.Order order = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->order_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6,
      this->order(static_cast<int>(i)),
      output);
  }

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->operation_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7,
      this->operation(static_cast<int>(i)),
      output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->args_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8,
      this->args(static_cast<int>(i)),
      output);
  }

  // optional .Mysqlx.Crud.LimitExpr limit_expr = 9;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->_internal_limit_expr(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Update)
}

::google::protobuf::uint8* Update::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Update)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_collection(), deterministic, target);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->data_model(), target);
  }

  // optional .Mysqlx.Expr.Expr criteria = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->_internal_criteria(), deterministic, target);
  }

  // optional .Mysqlx.Crud.Limit limit = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->_internal_limit(), deterministic, target);
  }

  // repeated .Mysqlx.Crud.Order order = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->order_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, this->order(static_cast<int>(i)), deterministic, target);
  }

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->operation_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, this->operation(static_cast<int>(i)), deterministic, target);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->args_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, this->args(static_cast<int>(i)), deterministic, target);
  }

  // optional .Mysqlx.Crud.LimitExpr limit_expr = 9;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        9, this->_internal_limit_expr(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Update)
  return target;
}

size_t Update::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Update)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .Mysqlx.Crud.Collection collection = 2;
  if (has_collection()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *collection_);
  }
  // repeated .Mysqlx.Crud.Order order = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->order_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->order(static_cast<int>(i)));
    }
  }

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->operation_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->operation(static_cast<int>(i)));
    }
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  {
    unsigned int count = static_cast<unsigned int>(this->args_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->args(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 30u) {
    // optional .Mysqlx.Expr.Expr criteria = 4;
    if (has_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *criteria_);
    }

    // optional .Mysqlx.Crud.Limit limit = 5;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *limit_);
    }

    // optional .Mysqlx.Crud.LimitExpr limit_expr = 9;
    if (has_limit_expr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *limit_expr_);
    }

    // optional .Mysqlx.Crud.DataModel data_model = 3;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Update::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Update)
  GOOGLE_DCHECK_NE(&from, this);
  const Update* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Update>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Update)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Update)
    MergeFrom(*source);
  }
}

void Update::MergeFrom(const Update& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Update)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  order_.MergeFrom(from.order_);
  operation_.MergeFrom(from.operation_);
  args_.MergeFrom(from.args_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.criteria());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_limit()->::Mysqlx::Crud::Limit::MergeFrom(from.limit());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_limit_expr()->::Mysqlx::Crud::LimitExpr::MergeFrom(from.limit_expr());
    }
    if (cached_has_bits & 0x00000010u) {
      data_model_ = from.data_model_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Update::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Update)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Update::CopyFrom(const Update& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Update)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Update::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->order())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->operation())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  if (has_collection()) {
    if (!this->collection_->IsInitialized()) return false;
  }
  if (has_criteria()) {
    if (!this->criteria_->IsInitialized()) return false;
  }
  if (has_limit()) {
    if (!this->limit_->IsInitialized()) return false;
  }
  if (has_limit_expr()) {
    if (!this->limit_expr_->IsInitialized()) return false;
  }
  return true;
}

void Update::Swap(Update* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Update::InternalSwap(Update* other) {
  using std::swap;
  CastToBase(&order_)->InternalSwap(CastToBase(&other->order_));
  CastToBase(&operation_)->InternalSwap(CastToBase(&other->operation_));
  CastToBase(&args_)->InternalSwap(CastToBase(&other->args_));
  swap(collection_, other->collection_);
  swap(criteria_, other->criteria_);
  swap(limit_, other->limit_);
  swap(limit_expr_, other->limit_expr_);
  swap(data_model_, other->data_model_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Update::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Delete::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_Delete_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  ::Mysqlx::Crud::_Delete_default_instance_._instance.get_mutable()->criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  ::Mysqlx::Crud::_Delete_default_instance_._instance.get_mutable()->limit_ = const_cast< ::Mysqlx::Crud::Limit*>(
      ::Mysqlx::Crud::Limit::internal_default_instance());
  ::Mysqlx::Crud::_Delete_default_instance_._instance.get_mutable()->limit_expr_ = const_cast< ::Mysqlx::Crud::LimitExpr*>(
      ::Mysqlx::Crud::LimitExpr::internal_default_instance());
}
void Delete::clear_criteria() {
  if (criteria_ != NULL) criteria_->Clear();
  clear_has_criteria();
}
void Delete::clear_args() {
  args_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Delete::kCollectionFieldNumber;
const int Delete::kDataModelFieldNumber;
const int Delete::kCriteriaFieldNumber;
const int Delete::kArgsFieldNumber;
const int Delete::kOrderFieldNumber;
const int Delete::kLimitFieldNumber;
const int Delete::kLimitExprFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Delete::Delete()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Delete.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Delete)
}
Delete::Delete(const Delete& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      order_(from.order_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = NULL;
  }
  if (from.has_criteria()) {
    criteria_ = new ::Mysqlx::Expr::Expr(*from.criteria_);
  } else {
    criteria_ = NULL;
  }
  if (from.has_limit()) {
    limit_ = new ::Mysqlx::Crud::Limit(*from.limit_);
  } else {
    limit_ = NULL;
  }
  if (from.has_limit_expr()) {
    limit_expr_ = new ::Mysqlx::Crud::LimitExpr(*from.limit_expr_);
  } else {
    limit_expr_ = NULL;
  }
  data_model_ = from.data_model_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Delete)
}

void Delete::SharedCtor() {
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&limit_expr_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(limit_expr_));
  data_model_ = 1;
}

Delete::~Delete() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Delete)
  SharedDtor();
}

void Delete::SharedDtor() {
  if (this != internal_default_instance()) delete collection_;
  if (this != internal_default_instance()) delete criteria_;
  if (this != internal_default_instance()) delete limit_;
  if (this != internal_default_instance()) delete limit_expr_;
}

void Delete::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Delete::descriptor() {
  ::protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Delete& Delete::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Delete.base);
  return *internal_default_instance();
}


void Delete::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Delete)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  order_.Clear();
  args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(collection_ != NULL);
      collection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(criteria_ != NULL);
      criteria_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(limit_ != NULL);
      limit_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(limit_expr_ != NULL);
      limit_expr_->Clear();
    }
    data_model_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Delete::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Delete)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Expr.Expr criteria = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_criteria()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.Limit limit = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_limit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.Order order = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_order()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.LimitExpr limit_expr = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_limit_expr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Delete)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Delete)
  return false;
#undef DO_
}

void Delete::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Delete)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_collection(), output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->data_model(), output);
  }

  // optional .Mysqlx.Expr.Expr criteria = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->_internal_criteria(), output);
  }

  // optional .Mysqlx.Crud.Limit limit = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->_internal_limit(), output);
  }

  // repeated .Mysqlx.Crud.Order order = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->order_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5,
      this->order(static_cast<int>(i)),
      output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->args_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6,
      this->args(static_cast<int>(i)),
      output);
  }

  // optional .Mysqlx.Crud.LimitExpr limit_expr = 7;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->_internal_limit_expr(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Delete)
}

::google::protobuf::uint8* Delete::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Delete)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_collection(), deterministic, target);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->data_model(), target);
  }

  // optional .Mysqlx.Expr.Expr criteria = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->_internal_criteria(), deterministic, target);
  }

  // optional .Mysqlx.Crud.Limit limit = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->_internal_limit(), deterministic, target);
  }

  // repeated .Mysqlx.Crud.Order order = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->order_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->order(static_cast<int>(i)), deterministic, target);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->args_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, this->args(static_cast<int>(i)), deterministic, target);
  }

  // optional .Mysqlx.Crud.LimitExpr limit_expr = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, this->_internal_limit_expr(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Delete)
  return target;
}

size_t Delete::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Delete)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *collection_);
  }
  // repeated .Mysqlx.Crud.Order order = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->order_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->order(static_cast<int>(i)));
    }
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->args_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->args(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 30u) {
    // optional .Mysqlx.Expr.Expr criteria = 3;
    if (has_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *criteria_);
    }

    // optional .Mysqlx.Crud.Limit limit = 4;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *limit_);
    }

    // optional .Mysqlx.Crud.LimitExpr limit_expr = 7;
    if (has_limit_expr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *limit_expr_);
    }

    // optional .Mysqlx.Crud.DataModel data_model = 2;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Delete::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Delete)
  GOOGLE_DCHECK_NE(&from, this);
  const Delete* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Delete>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Delete)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Delete)
    MergeFrom(*source);
  }
}

void Delete::MergeFrom(const Delete& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Delete)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  order_.MergeFrom(from.order_);
  args_.MergeFrom(from.args_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.criteria());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_limit()->::Mysqlx::Crud::Limit::MergeFrom(from.limit());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_limit_expr()->::Mysqlx::Crud::LimitExpr::MergeFrom(from.limit_expr());
    }
    if (cached_has_bits & 0x00000010u) {
      data_model_ = from.data_model_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Delete::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Delete)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Delete::CopyFrom(const Delete& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Delete)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Delete::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->order())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  if (has_collection()) {
    if (!this->collection_->IsInitialized()) return false;
  }
  if (has_criteria()) {
    if (!this->criteria_->IsInitialized()) return false;
  }
  if (has_limit()) {
    if (!this->limit_->IsInitialized()) return false;
  }
  if (has_limit_expr()) {
    if (!this->limit_expr_->IsInitialized()) return false;
  }
  return true;
}

void Delete::Swap(Delete* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Delete::InternalSwap(Delete* other) {
  using std::swap;
  CastToBase(&order_)->InternalSwap(CastToBase(&other->order_));
  CastToBase(&args_)->InternalSwap(CastToBase(&other->args_));
  swap(collection_, other->collection_);
  swap(criteria_, other->criteria_);
  swap(limit_, other->limit_);
  swap(limit_expr_, other->limit_expr_);
  swap(data_model_, other->data_model_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Delete::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void CreateView::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_CreateView_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  ::Mysqlx::Crud::_CreateView_default_instance_._instance.get_mutable()->stmt_ = const_cast< ::Mysqlx::Crud::Find*>(
      ::Mysqlx::Crud::Find::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CreateView::kCollectionFieldNumber;
const int CreateView::kDefinerFieldNumber;
const int CreateView::kAlgorithmFieldNumber;
const int CreateView::kSecurityFieldNumber;
const int CreateView::kCheckFieldNumber;
const int CreateView::kColumnFieldNumber;
const int CreateView::kStmtFieldNumber;
const int CreateView::kReplaceExistingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CreateView::CreateView()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_CreateView.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.CreateView)
}
CreateView::CreateView(const CreateView& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      column_(from.column_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  definer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_definer()) {
    definer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.definer_);
  }
  if (from.has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = NULL;
  }
  if (from.has_stmt()) {
    stmt_ = new ::Mysqlx::Crud::Find(*from.stmt_);
  } else {
    stmt_ = NULL;
  }
  ::memcpy(&replace_existing_, &from.replace_existing_,
    static_cast<size_t>(reinterpret_cast<char*>(&security_) -
    reinterpret_cast<char*>(&replace_existing_)) + sizeof(security_));
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.CreateView)
}

void CreateView::SharedCtor() {
  definer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&replace_existing_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(replace_existing_));
  check_ = 1;
  algorithm_ = 1;
  security_ = 2;
}

CreateView::~CreateView() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.CreateView)
  SharedDtor();
}

void CreateView::SharedDtor() {
  definer_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete collection_;
  if (this != internal_default_instance()) delete stmt_;
}

void CreateView::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* CreateView::descriptor() {
  ::protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const CreateView& CreateView::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_CreateView.base);
  return *internal_default_instance();
}


void CreateView::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.CreateView)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  column_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      definer_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(collection_ != NULL);
      collection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(stmt_ != NULL);
      stmt_->Clear();
    }
  }
  if (cached_has_bits & 120u) {
    replace_existing_ = false;
    check_ = 1;
    algorithm_ = 1;
    security_ = 2;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool CreateView::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.CreateView)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string definer = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_definer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->definer().data(), static_cast<int>(this->definer().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Mysqlx.Crud.CreateView.definer");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3 [default = UNDEFINED];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::ViewAlgorithm_IsValid(value)) {
            set_algorithm(static_cast< ::Mysqlx::Crud::ViewAlgorithm >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.ViewSqlSecurity security = 4 [default = DEFINER];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::ViewSqlSecurity_IsValid(value)) {
            set_security(static_cast< ::Mysqlx::Crud::ViewSqlSecurity >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                4, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.ViewCheckOption check = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::ViewCheckOption_IsValid(value)) {
            set_check(static_cast< ::Mysqlx::Crud::ViewCheckOption >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                5, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string column = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_column()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->column(this->column_size() - 1).data(),
            static_cast<int>(this->column(this->column_size() - 1).length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Mysqlx.Crud.CreateView.column");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .Mysqlx.Crud.Find stmt = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_stmt()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool replace_existing = 8 [default = false];
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {
          set_has_replace_existing();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &replace_existing_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.CreateView)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.CreateView)
  return false;
#undef DO_
}

void CreateView::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.CreateView)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_collection(), output);
  }

  // optional string definer = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->definer().data(), static_cast<int>(this->definer().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.CreateView.definer");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->definer(), output);
  }

  // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3 [default = UNDEFINED];
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->algorithm(), output);
  }

  // optional .Mysqlx.Crud.ViewSqlSecurity security = 4 [default = DEFINER];
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->security(), output);
  }

  // optional .Mysqlx.Crud.ViewCheckOption check = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->check(), output);
  }

  // repeated string column = 6;
  for (int i = 0, n = this->column_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->column(i).data(), static_cast<int>(this->column(i).length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.CreateView.column");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->column(i), output);
  }

  // required .Mysqlx.Crud.Find stmt = 7;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->_internal_stmt(), output);
  }

  // optional bool replace_existing = 8 [default = false];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->replace_existing(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.CreateView)
}

::google::protobuf::uint8* CreateView::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.CreateView)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_collection(), deterministic, target);
  }

  // optional string definer = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->definer().data(), static_cast<int>(this->definer().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.CreateView.definer");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->definer(), target);
  }

  // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3 [default = UNDEFINED];
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->algorithm(), target);
  }

  // optional .Mysqlx.Crud.ViewSqlSecurity security = 4 [default = DEFINER];
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->security(), target);
  }

  // optional .Mysqlx.Crud.ViewCheckOption check = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->check(), target);
  }

  // repeated string column = 6;
  for (int i = 0, n = this->column_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->column(i).data(), static_cast<int>(this->column(i).length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.CreateView.column");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(6, this->column(i), target);
  }

  // required .Mysqlx.Crud.Find stmt = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, this->_internal_stmt(), deterministic, target);
  }

  // optional bool replace_existing = 8 [default = false];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->replace_existing(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.CreateView)
  return target;
}

size_t CreateView::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Mysqlx.Crud.CreateView)
  size_t total_size = 0;

  if (has_collection()) {
    // required .Mysqlx.Crud.Collection collection = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *collection_);
  }

  if (has_stmt()) {
    // required .Mysqlx.Crud.Find stmt = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *stmt_);
  }

  return total_size;
}
size_t CreateView::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.CreateView)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required .Mysqlx.Crud.Collection collection = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *collection_);

    // required .Mysqlx.Crud.Find stmt = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *stmt_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // repeated string column = 6;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->column_size());
  for (int i = 0, n = this->column_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->column(i));
  }

  // optional string definer = 2;
  if (has_definer()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->definer());
  }

  if (_has_bits_[0 / 32] & 120u) {
    // optional bool replace_existing = 8 [default = false];
    if (has_replace_existing()) {
      total_size += 1 + 1;
    }

    // optional .Mysqlx.Crud.ViewCheckOption check = 5;
    if (has_check()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->check());
    }

    // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3 [default = UNDEFINED];
    if (has_algorithm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->algorithm());
    }

    // optional .Mysqlx.Crud.ViewSqlSecurity security = 4 [default = DEFINER];
    if (has_security()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->security());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CreateView::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.CreateView)
  GOOGLE_DCHECK_NE(&from, this);
  const CreateView* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const CreateView>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.CreateView)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.CreateView)
    MergeFrom(*source);
  }
}

void CreateView::MergeFrom(const CreateView& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.CreateView)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  column_.MergeFrom(from.column_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 127u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_definer();
      definer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.definer_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_stmt()->::Mysqlx::Crud::Find::MergeFrom(from.stmt());
    }
    if (cached_has_bits & 0x00000008u) {
      replace_existing_ = from.replace_existing_;
    }
    if (cached_has_bits & 0x00000010u) {
      check_ = from.check_;
    }
    if (cached_has_bits & 0x00000020u) {
      algorithm_ = from.algorithm_;
    }
    if (cached_has_bits & 0x00000040u) {
      security_ = from.security_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CreateView::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.CreateView)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CreateView::CopyFrom(const CreateView& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.CreateView)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateView::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;
  if (has_collection()) {
    if (!this->collection_->IsInitialized()) return false;
  }
  if (has_stmt()) {
    if (!this->stmt_->IsInitialized()) return false;
  }
  return true;
}

void CreateView::Swap(CreateView* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CreateView::InternalSwap(CreateView* other) {
  using std::swap;
  column_.InternalSwap(CastToBase(&other->column_));
  definer_.Swap(&other->definer_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(collection_, other->collection_);
  swap(stmt_, other->stmt_);
  swap(replace_existing_, other->replace_existing_);
  swap(check_, other->check_);
  swap(algorithm_, other->algorithm_);
  swap(security_, other->security_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata CreateView::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void ModifyView::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_ModifyView_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  ::Mysqlx::Crud::_ModifyView_default_instance_._instance.get_mutable()->stmt_ = const_cast< ::Mysqlx::Crud::Find*>(
      ::Mysqlx::Crud::Find::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ModifyView::kCollectionFieldNumber;
const int ModifyView::kDefinerFieldNumber;
const int ModifyView::kAlgorithmFieldNumber;
const int ModifyView::kSecurityFieldNumber;
const int ModifyView::kCheckFieldNumber;
const int ModifyView::kColumnFieldNumber;
const int ModifyView::kStmtFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ModifyView::ModifyView()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_ModifyView.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.ModifyView)
}
ModifyView::ModifyView(const ModifyView& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      column_(from.column_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  definer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_definer()) {
    definer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.definer_);
  }
  if (from.has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = NULL;
  }
  if (from.has_stmt()) {
    stmt_ = new ::Mysqlx::Crud::Find(*from.stmt_);
  } else {
    stmt_ = NULL;
  }
  ::memcpy(&check_, &from.check_,
    static_cast<size_t>(reinterpret_cast<char*>(&security_) -
    reinterpret_cast<char*>(&check_)) + sizeof(security_));
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.ModifyView)
}

void ModifyView::SharedCtor() {
  definer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&stmt_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(stmt_));
  check_ = 1;
  algorithm_ = 1;
  security_ = 1;
}

ModifyView::~ModifyView() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.ModifyView)
  SharedDtor();
}

void ModifyView::SharedDtor() {
  definer_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete collection_;
  if (this != internal_default_instance()) delete stmt_;
}

void ModifyView::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* ModifyView::descriptor() {
  ::protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ModifyView& ModifyView::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_ModifyView.base);
  return *internal_default_instance();
}


void ModifyView::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.ModifyView)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  column_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      definer_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(collection_ != NULL);
      collection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(stmt_ != NULL);
      stmt_->Clear();
    }
    check_ = 1;
    algorithm_ = 1;
    security_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ModifyView::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.ModifyView)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string definer = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_definer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->definer().data(), static_cast<int>(this->definer().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Mysqlx.Crud.ModifyView.definer");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::ViewAlgorithm_IsValid(value)) {
            set_algorithm(static_cast< ::Mysqlx::Crud::ViewAlgorithm >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.ViewSqlSecurity security = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::ViewSqlSecurity_IsValid(value)) {
            set_security(static_cast< ::Mysqlx::Crud::ViewSqlSecurity >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                4, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.ViewCheckOption check = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::ViewCheckOption_IsValid(value)) {
            set_check(static_cast< ::Mysqlx::Crud::ViewCheckOption >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                5, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string column = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_column()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->column(this->column_size() - 1).data(),
            static_cast<int>(this->column(this->column_size() - 1).length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Mysqlx.Crud.ModifyView.column");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.Find stmt = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_stmt()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.ModifyView)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.ModifyView)
  return false;
#undef DO_
}

void ModifyView::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.ModifyView)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_collection(), output);
  }

  // optional string definer = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->definer().data(), static_cast<int>(this->definer().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.ModifyView.definer");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->definer(), output);
  }

  // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->algorithm(), output);
  }

  // optional .Mysqlx.Crud.ViewSqlSecurity security = 4;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->security(), output);
  }

  // optional .Mysqlx.Crud.ViewCheckOption check = 5;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->check(), output);
  }

  // repeated string column = 6;
  for (int i = 0, n = this->column_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->column(i).data(), static_cast<int>(this->column(i).length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.ModifyView.column");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->column(i), output);
  }

  // optional .Mysqlx.Crud.Find stmt = 7;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->_internal_stmt(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.ModifyView)
}

::google::protobuf::uint8* ModifyView::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.ModifyView)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_collection(), deterministic, target);
  }

  // optional string definer = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->definer().data(), static_cast<int>(this->definer().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.ModifyView.definer");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->definer(), target);
  }

  // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->algorithm(), target);
  }

  // optional .Mysqlx.Crud.ViewSqlSecurity security = 4;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->security(), target);
  }

  // optional .Mysqlx.Crud.ViewCheckOption check = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->check(), target);
  }

  // repeated string column = 6;
  for (int i = 0, n = this->column_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->column(i).data(), static_cast<int>(this->column(i).length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.ModifyView.column");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(6, this->column(i), target);
  }

  // optional .Mysqlx.Crud.Find stmt = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, this->_internal_stmt(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.ModifyView)
  return target;
}

size_t ModifyView::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.ModifyView)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *collection_);
  }
  // repeated string column = 6;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->column_size());
  for (int i = 0, n = this->column_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->column(i));
  }

  // optional string definer = 2;
  if (has_definer()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->definer());
  }

  if (_has_bits_[0 / 32] & 60u) {
    // optional .Mysqlx.Crud.Find stmt = 7;
    if (has_stmt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *stmt_);
    }

    // optional .Mysqlx.Crud.ViewCheckOption check = 5;
    if (has_check()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->check());
    }

    // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3;
    if (has_algorithm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->algorithm());
    }

    // optional .Mysqlx.Crud.ViewSqlSecurity security = 4;
    if (has_security()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->security());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ModifyView::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.ModifyView)
  GOOGLE_DCHECK_NE(&from, this);
  const ModifyView* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ModifyView>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.ModifyView)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.ModifyView)
    MergeFrom(*source);
  }
}

void ModifyView::MergeFrom(const ModifyView& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.ModifyView)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  column_.MergeFrom(from.column_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_definer();
      definer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.definer_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_stmt()->::Mysqlx::Crud::Find::MergeFrom(from.stmt());
    }
    if (cached_has_bits & 0x00000008u) {
      check_ = from.check_;
    }
    if (cached_has_bits & 0x00000010u) {
      algorithm_ = from.algorithm_;
    }
    if (cached_has_bits & 0x00000020u) {
      security_ = from.security_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ModifyView::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.ModifyView)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModifyView::CopyFrom(const ModifyView& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.ModifyView)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModifyView::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (has_collection()) {
    if (!this->collection_->IsInitialized()) return false;
  }
  if (has_stmt()) {
    if (!this->stmt_->IsInitialized()) return false;
  }
  return true;
}

void ModifyView::Swap(ModifyView* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ModifyView::InternalSwap(ModifyView* other) {
  using std::swap;
  column_.InternalSwap(CastToBase(&other->column_));
  definer_.Swap(&other->definer_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(collection_, other->collection_);
  swap(stmt_, other->stmt_);
  swap(check_, other->check_);
  swap(algorithm_, other->algorithm_);
  swap(security_, other->security_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata ModifyView::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void DropView::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_DropView_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DropView::kCollectionFieldNumber;
const int DropView::kIfExistsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DropView::DropView()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_DropView.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.DropView)
}
DropView::DropView(const DropView& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = NULL;
  }
  if_exists_ = from.if_exists_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.DropView)
}

void DropView::SharedCtor() {
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&if_exists_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(if_exists_));
}

DropView::~DropView() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.DropView)
  SharedDtor();
}

void DropView::SharedDtor() {
  if (this != internal_default_instance()) delete collection_;
}

void DropView::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* DropView::descriptor() {
  ::protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const DropView& DropView::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_DropView.base);
  return *internal_default_instance();
}


void DropView::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.DropView)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(collection_ != NULL);
    collection_->Clear();
  }
  if_exists_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool DropView::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.DropView)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool if_exists = 2 [default = false];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_if_exists();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &if_exists_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.DropView)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.DropView)
  return false;
#undef DO_
}

void DropView::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.DropView)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_collection(), output);
  }

  // optional bool if_exists = 2 [default = false];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->if_exists(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.DropView)
}

::google::protobuf::uint8* DropView::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.DropView)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_collection(), deterministic, target);
  }

  // optional bool if_exists = 2 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->if_exists(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.DropView)
  return target;
}

size_t DropView::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.DropView)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *collection_);
  }
  // optional bool if_exists = 2 [default = false];
  if (has_if_exists()) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DropView::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.DropView)
  GOOGLE_DCHECK_NE(&from, this);
  const DropView* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const DropView>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.DropView)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.DropView)
    MergeFrom(*source);
  }
}

void DropView::MergeFrom(const DropView& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.DropView)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (cached_has_bits & 0x00000002u) {
      if_exists_ = from.if_exists_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DropView::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.DropView)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DropView::CopyFrom(const DropView& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.DropView)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DropView::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_collection()) {
    if (!this->collection_->IsInitialized()) return false;
  }
  return true;
}

void DropView::Swap(DropView* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DropView::InternalSwap(DropView* other) {
  using std::swap;
  swap(collection_, other->collection_);
  swap(if_exists_, other->if_exists_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata DropView::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace Crud
}  // namespace Mysqlx
namespace google {
namespace protobuf {
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Column* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Column >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Column >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Projection* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Projection >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Projection >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Collection* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Collection >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Collection >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Limit* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Limit >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Limit >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::LimitExpr* Arena::CreateMaybeMessage< ::Mysqlx::Crud::LimitExpr >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::LimitExpr >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Order* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Order >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Order >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::UpdateOperation* Arena::CreateMaybeMessage< ::Mysqlx::Crud::UpdateOperation >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::UpdateOperation >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Find* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Find >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Find >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Insert_TypedRow* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Insert_TypedRow >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Insert_TypedRow >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Insert* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Insert >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Insert >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Update* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Update >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Update >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Delete* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Delete >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Delete >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::CreateView* Arena::CreateMaybeMessage< ::Mysqlx::Crud::CreateView >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::CreateView >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::ModifyView* Arena::CreateMaybeMessage< ::Mysqlx::Crud::ModifyView >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::ModifyView >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::DropView* Arena::CreateMaybeMessage< ::Mysqlx::Crud::DropView >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::DropView >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
