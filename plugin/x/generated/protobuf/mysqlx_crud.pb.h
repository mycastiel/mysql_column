// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mysqlx_crud.proto

#ifndef PROTOBUF_INCLUDED_mysqlx_5fcrud_2eproto
#define PROTOBUF_INCLUDED_mysqlx_5fcrud_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mysqlx.pb.h"
#include "mysqlx_expr.pb.h"
#include "mysqlx_datatypes.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto 

namespace protobuf_mysqlx_5fcrud_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[15];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_mysqlx_5fcrud_2eproto
namespace Mysqlx {
namespace Crud {
class Collection;
class CollectionDefaultTypeInternal;
extern CollectionDefaultTypeInternal _Collection_default_instance_;
class Column;
class ColumnDefaultTypeInternal;
extern ColumnDefaultTypeInternal _Column_default_instance_;
class CreateView;
class CreateViewDefaultTypeInternal;
extern CreateViewDefaultTypeInternal _CreateView_default_instance_;
class Delete;
class DeleteDefaultTypeInternal;
extern DeleteDefaultTypeInternal _Delete_default_instance_;
class DropView;
class DropViewDefaultTypeInternal;
extern DropViewDefaultTypeInternal _DropView_default_instance_;
class Find;
class FindDefaultTypeInternal;
extern FindDefaultTypeInternal _Find_default_instance_;
class Insert;
class InsertDefaultTypeInternal;
extern InsertDefaultTypeInternal _Insert_default_instance_;
class Insert_TypedRow;
class Insert_TypedRowDefaultTypeInternal;
extern Insert_TypedRowDefaultTypeInternal _Insert_TypedRow_default_instance_;
class Limit;
class LimitDefaultTypeInternal;
extern LimitDefaultTypeInternal _Limit_default_instance_;
class LimitExpr;
class LimitExprDefaultTypeInternal;
extern LimitExprDefaultTypeInternal _LimitExpr_default_instance_;
class ModifyView;
class ModifyViewDefaultTypeInternal;
extern ModifyViewDefaultTypeInternal _ModifyView_default_instance_;
class Order;
class OrderDefaultTypeInternal;
extern OrderDefaultTypeInternal _Order_default_instance_;
class Projection;
class ProjectionDefaultTypeInternal;
extern ProjectionDefaultTypeInternal _Projection_default_instance_;
class Update;
class UpdateDefaultTypeInternal;
extern UpdateDefaultTypeInternal _Update_default_instance_;
class UpdateOperation;
class UpdateOperationDefaultTypeInternal;
extern UpdateOperationDefaultTypeInternal _UpdateOperation_default_instance_;
}  // namespace Crud
}  // namespace Mysqlx
namespace google {
namespace protobuf {
template<> ::Mysqlx::Crud::Collection* Arena::CreateMaybeMessage<::Mysqlx::Crud::Collection>(Arena*);
template<> ::Mysqlx::Crud::Column* Arena::CreateMaybeMessage<::Mysqlx::Crud::Column>(Arena*);
template<> ::Mysqlx::Crud::CreateView* Arena::CreateMaybeMessage<::Mysqlx::Crud::CreateView>(Arena*);
template<> ::Mysqlx::Crud::Delete* Arena::CreateMaybeMessage<::Mysqlx::Crud::Delete>(Arena*);
template<> ::Mysqlx::Crud::DropView* Arena::CreateMaybeMessage<::Mysqlx::Crud::DropView>(Arena*);
template<> ::Mysqlx::Crud::Find* Arena::CreateMaybeMessage<::Mysqlx::Crud::Find>(Arena*);
template<> ::Mysqlx::Crud::Insert* Arena::CreateMaybeMessage<::Mysqlx::Crud::Insert>(Arena*);
template<> ::Mysqlx::Crud::Insert_TypedRow* Arena::CreateMaybeMessage<::Mysqlx::Crud::Insert_TypedRow>(Arena*);
template<> ::Mysqlx::Crud::Limit* Arena::CreateMaybeMessage<::Mysqlx::Crud::Limit>(Arena*);
template<> ::Mysqlx::Crud::LimitExpr* Arena::CreateMaybeMessage<::Mysqlx::Crud::LimitExpr>(Arena*);
template<> ::Mysqlx::Crud::ModifyView* Arena::CreateMaybeMessage<::Mysqlx::Crud::ModifyView>(Arena*);
template<> ::Mysqlx::Crud::Order* Arena::CreateMaybeMessage<::Mysqlx::Crud::Order>(Arena*);
template<> ::Mysqlx::Crud::Projection* Arena::CreateMaybeMessage<::Mysqlx::Crud::Projection>(Arena*);
template<> ::Mysqlx::Crud::Update* Arena::CreateMaybeMessage<::Mysqlx::Crud::Update>(Arena*);
template<> ::Mysqlx::Crud::UpdateOperation* Arena::CreateMaybeMessage<::Mysqlx::Crud::UpdateOperation>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Mysqlx {
namespace Crud {

enum Order_Direction {
  Order_Direction_ASC = 1,
  Order_Direction_DESC = 2
};
bool Order_Direction_IsValid(int value);
const Order_Direction Order_Direction_Direction_MIN = Order_Direction_ASC;
const Order_Direction Order_Direction_Direction_MAX = Order_Direction_DESC;
const int Order_Direction_Direction_ARRAYSIZE = Order_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* Order_Direction_descriptor();
inline const ::std::string& Order_Direction_Name(Order_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    Order_Direction_descriptor(), value);
}
inline bool Order_Direction_Parse(
    const ::std::string& name, Order_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Order_Direction>(
    Order_Direction_descriptor(), name, value);
}
enum UpdateOperation_UpdateType {
  UpdateOperation_UpdateType_SET = 1,
  UpdateOperation_UpdateType_ITEM_REMOVE = 2,
  UpdateOperation_UpdateType_ITEM_SET = 3,
  UpdateOperation_UpdateType_ITEM_REPLACE = 4,
  UpdateOperation_UpdateType_ITEM_MERGE = 5,
  UpdateOperation_UpdateType_ARRAY_INSERT = 6,
  UpdateOperation_UpdateType_ARRAY_APPEND = 7,
  UpdateOperation_UpdateType_MERGE_PATCH = 8
};
bool UpdateOperation_UpdateType_IsValid(int value);
const UpdateOperation_UpdateType UpdateOperation_UpdateType_UpdateType_MIN = UpdateOperation_UpdateType_SET;
const UpdateOperation_UpdateType UpdateOperation_UpdateType_UpdateType_MAX = UpdateOperation_UpdateType_MERGE_PATCH;
const int UpdateOperation_UpdateType_UpdateType_ARRAYSIZE = UpdateOperation_UpdateType_UpdateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UpdateOperation_UpdateType_descriptor();
inline const ::std::string& UpdateOperation_UpdateType_Name(UpdateOperation_UpdateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UpdateOperation_UpdateType_descriptor(), value);
}
inline bool UpdateOperation_UpdateType_Parse(
    const ::std::string& name, UpdateOperation_UpdateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpdateOperation_UpdateType>(
    UpdateOperation_UpdateType_descriptor(), name, value);
}
enum Find_RowLock {
  Find_RowLock_SHARED_LOCK = 1,
  Find_RowLock_EXCLUSIVE_LOCK = 2
};
bool Find_RowLock_IsValid(int value);
const Find_RowLock Find_RowLock_RowLock_MIN = Find_RowLock_SHARED_LOCK;
const Find_RowLock Find_RowLock_RowLock_MAX = Find_RowLock_EXCLUSIVE_LOCK;
const int Find_RowLock_RowLock_ARRAYSIZE = Find_RowLock_RowLock_MAX + 1;

const ::google::protobuf::EnumDescriptor* Find_RowLock_descriptor();
inline const ::std::string& Find_RowLock_Name(Find_RowLock value) {
  return ::google::protobuf::internal::NameOfEnum(
    Find_RowLock_descriptor(), value);
}
inline bool Find_RowLock_Parse(
    const ::std::string& name, Find_RowLock* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Find_RowLock>(
    Find_RowLock_descriptor(), name, value);
}
enum Find_RowLockOptions {
  Find_RowLockOptions_NOWAIT = 1,
  Find_RowLockOptions_SKIP_LOCKED = 2
};
bool Find_RowLockOptions_IsValid(int value);
const Find_RowLockOptions Find_RowLockOptions_RowLockOptions_MIN = Find_RowLockOptions_NOWAIT;
const Find_RowLockOptions Find_RowLockOptions_RowLockOptions_MAX = Find_RowLockOptions_SKIP_LOCKED;
const int Find_RowLockOptions_RowLockOptions_ARRAYSIZE = Find_RowLockOptions_RowLockOptions_MAX + 1;

const ::google::protobuf::EnumDescriptor* Find_RowLockOptions_descriptor();
inline const ::std::string& Find_RowLockOptions_Name(Find_RowLockOptions value) {
  return ::google::protobuf::internal::NameOfEnum(
    Find_RowLockOptions_descriptor(), value);
}
inline bool Find_RowLockOptions_Parse(
    const ::std::string& name, Find_RowLockOptions* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Find_RowLockOptions>(
    Find_RowLockOptions_descriptor(), name, value);
}
enum DataModel {
  DOCUMENT = 1,
  TABLE = 2
};
bool DataModel_IsValid(int value);
const DataModel DataModel_MIN = DOCUMENT;
const DataModel DataModel_MAX = TABLE;
const int DataModel_ARRAYSIZE = DataModel_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataModel_descriptor();
inline const ::std::string& DataModel_Name(DataModel value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataModel_descriptor(), value);
}
inline bool DataModel_Parse(
    const ::std::string& name, DataModel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataModel>(
    DataModel_descriptor(), name, value);
}
enum ViewAlgorithm {
  UNDEFINED = 1,
  MERGE = 2,
  TEMPTABLE = 3
};
bool ViewAlgorithm_IsValid(int value);
const ViewAlgorithm ViewAlgorithm_MIN = UNDEFINED;
const ViewAlgorithm ViewAlgorithm_MAX = TEMPTABLE;
const int ViewAlgorithm_ARRAYSIZE = ViewAlgorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* ViewAlgorithm_descriptor();
inline const ::std::string& ViewAlgorithm_Name(ViewAlgorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    ViewAlgorithm_descriptor(), value);
}
inline bool ViewAlgorithm_Parse(
    const ::std::string& name, ViewAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ViewAlgorithm>(
    ViewAlgorithm_descriptor(), name, value);
}
enum ViewSqlSecurity {
  INVOKER = 1,
  DEFINER = 2
};
bool ViewSqlSecurity_IsValid(int value);
const ViewSqlSecurity ViewSqlSecurity_MIN = INVOKER;
const ViewSqlSecurity ViewSqlSecurity_MAX = DEFINER;
const int ViewSqlSecurity_ARRAYSIZE = ViewSqlSecurity_MAX + 1;

const ::google::protobuf::EnumDescriptor* ViewSqlSecurity_descriptor();
inline const ::std::string& ViewSqlSecurity_Name(ViewSqlSecurity value) {
  return ::google::protobuf::internal::NameOfEnum(
    ViewSqlSecurity_descriptor(), value);
}
inline bool ViewSqlSecurity_Parse(
    const ::std::string& name, ViewSqlSecurity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ViewSqlSecurity>(
    ViewSqlSecurity_descriptor(), name, value);
}
enum ViewCheckOption {
  LOCAL = 1,
  CASCADED = 2
};
bool ViewCheckOption_IsValid(int value);
const ViewCheckOption ViewCheckOption_MIN = LOCAL;
const ViewCheckOption ViewCheckOption_MAX = CASCADED;
const int ViewCheckOption_ARRAYSIZE = ViewCheckOption_MAX + 1;

const ::google::protobuf::EnumDescriptor* ViewCheckOption_descriptor();
inline const ::std::string& ViewCheckOption_Name(ViewCheckOption value) {
  return ::google::protobuf::internal::NameOfEnum(
    ViewCheckOption_descriptor(), value);
}
inline bool ViewCheckOption_Parse(
    const ::std::string& name, ViewCheckOption* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ViewCheckOption>(
    ViewCheckOption_descriptor(), name, value);
}
// ===================================================================

class Column : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Column) */ {
 public:
  Column();
  virtual ~Column();

  Column(const Column& from);

  inline Column& operator=(const Column& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Column(Column&& from) noexcept
    : Column() {
    *this = ::std::move(from);
  }

  inline Column& operator=(Column&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Column& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Column* internal_default_instance() {
    return reinterpret_cast<const Column*>(
               &_Column_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Column* other);
  friend void swap(Column& a, Column& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Column* New() const final {
    return CreateMaybeMessage<Column>(NULL);
  }

  Column* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Column>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Column& from);
  void MergeFrom(const Column& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Column* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  int document_path_size() const;
  void clear_document_path();
  static const int kDocumentPathFieldNumber = 3;
  ::Mysqlx::Expr::DocumentPathItem* mutable_document_path(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >*
      mutable_document_path();
  const ::Mysqlx::Expr::DocumentPathItem& document_path(int index) const;
  ::Mysqlx::Expr::DocumentPathItem* add_document_path();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >&
      document_path() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string alias = 2;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 2;
  const ::std::string& alias() const;
  void set_alias(const ::std::string& value);
  #if LANG_CXX11
  void set_alias(::std::string&& value);
  #endif
  void set_alias(const char* value);
  void set_alias(const char* value, size_t size);
  ::std::string* mutable_alias();
  ::std::string* release_alias();
  void set_allocated_alias(::std::string* alias);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Column)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_alias();
  void clear_has_alias();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem > document_path_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr alias_;
  friend struct ::protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Projection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Projection) */ {
 public:
  Projection();
  virtual ~Projection();

  Projection(const Projection& from);

  inline Projection& operator=(const Projection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Projection(Projection&& from) noexcept
    : Projection() {
    *this = ::std::move(from);
  }

  inline Projection& operator=(Projection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Projection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Projection* internal_default_instance() {
    return reinterpret_cast<const Projection*>(
               &_Projection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Projection* other);
  friend void swap(Projection& a, Projection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Projection* New() const final {
    return CreateMaybeMessage<Projection>(NULL);
  }

  Projection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Projection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Projection& from);
  void MergeFrom(const Projection& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Projection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string alias = 2;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 2;
  const ::std::string& alias() const;
  void set_alias(const ::std::string& value);
  #if LANG_CXX11
  void set_alias(::std::string&& value);
  #endif
  void set_alias(const char* value);
  void set_alias(const char* value, size_t size);
  ::std::string* mutable_alias();
  ::std::string* release_alias();
  void set_allocated_alias(::std::string* alias);

  // required .Mysqlx.Expr.Expr source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  private:
  const ::Mysqlx::Expr::Expr& _internal_source() const;
  public:
  const ::Mysqlx::Expr::Expr& source() const;
  ::Mysqlx::Expr::Expr* release_source();
  ::Mysqlx::Expr::Expr* mutable_source();
  void set_allocated_source(::Mysqlx::Expr::Expr* source);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Projection)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_alias();
  void clear_has_alias();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr alias_;
  ::Mysqlx::Expr::Expr* source_;
  friend struct ::protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Collection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Collection) */ {
 public:
  Collection();
  virtual ~Collection();

  Collection(const Collection& from);

  inline Collection& operator=(const Collection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Collection(Collection&& from) noexcept
    : Collection() {
    *this = ::std::move(from);
  }

  inline Collection& operator=(Collection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Collection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Collection* internal_default_instance() {
    return reinterpret_cast<const Collection*>(
               &_Collection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Collection* other);
  friend void swap(Collection& a, Collection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Collection* New() const final {
    return CreateMaybeMessage<Collection>(NULL);
  }

  Collection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Collection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Collection& from);
  void MergeFrom(const Collection& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Collection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string schema = 2;
  bool has_schema() const;
  void clear_schema();
  static const int kSchemaFieldNumber = 2;
  const ::std::string& schema() const;
  void set_schema(const ::std::string& value);
  #if LANG_CXX11
  void set_schema(::std::string&& value);
  #endif
  void set_schema(const char* value);
  void set_schema(const char* value, size_t size);
  ::std::string* mutable_schema();
  ::std::string* release_schema();
  void set_allocated_schema(::std::string* schema);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Collection)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_schema();
  void clear_has_schema();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr schema_;
  friend struct ::protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Limit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Limit) */ {
 public:
  Limit();
  virtual ~Limit();

  Limit(const Limit& from);

  inline Limit& operator=(const Limit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Limit(Limit&& from) noexcept
    : Limit() {
    *this = ::std::move(from);
  }

  inline Limit& operator=(Limit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Limit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Limit* internal_default_instance() {
    return reinterpret_cast<const Limit*>(
               &_Limit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Limit* other);
  friend void swap(Limit& a, Limit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Limit* New() const final {
    return CreateMaybeMessage<Limit>(NULL);
  }

  Limit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Limit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Limit& from);
  void MergeFrom(const Limit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Limit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 row_count = 1;
  bool has_row_count() const;
  void clear_row_count();
  static const int kRowCountFieldNumber = 1;
  ::google::protobuf::uint64 row_count() const;
  void set_row_count(::google::protobuf::uint64 value);

  // optional uint64 offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Limit)
 private:
  void set_has_row_count();
  void clear_has_row_count();
  void set_has_offset();
  void clear_has_offset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 row_count_;
  ::google::protobuf::uint64 offset_;
  friend struct ::protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LimitExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.LimitExpr) */ {
 public:
  LimitExpr();
  virtual ~LimitExpr();

  LimitExpr(const LimitExpr& from);

  inline LimitExpr& operator=(const LimitExpr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LimitExpr(LimitExpr&& from) noexcept
    : LimitExpr() {
    *this = ::std::move(from);
  }

  inline LimitExpr& operator=(LimitExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LimitExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LimitExpr* internal_default_instance() {
    return reinterpret_cast<const LimitExpr*>(
               &_LimitExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(LimitExpr* other);
  friend void swap(LimitExpr& a, LimitExpr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LimitExpr* New() const final {
    return CreateMaybeMessage<LimitExpr>(NULL);
  }

  LimitExpr* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LimitExpr>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LimitExpr& from);
  void MergeFrom(const LimitExpr& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LimitExpr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Mysqlx.Expr.Expr row_count = 1;
  bool has_row_count() const;
  void clear_row_count();
  static const int kRowCountFieldNumber = 1;
  private:
  const ::Mysqlx::Expr::Expr& _internal_row_count() const;
  public:
  const ::Mysqlx::Expr::Expr& row_count() const;
  ::Mysqlx::Expr::Expr* release_row_count();
  ::Mysqlx::Expr::Expr* mutable_row_count();
  void set_allocated_row_count(::Mysqlx::Expr::Expr* row_count);

  // optional .Mysqlx.Expr.Expr offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  private:
  const ::Mysqlx::Expr::Expr& _internal_offset() const;
  public:
  const ::Mysqlx::Expr::Expr& offset() const;
  ::Mysqlx::Expr::Expr* release_offset();
  ::Mysqlx::Expr::Expr* mutable_offset();
  void set_allocated_offset(::Mysqlx::Expr::Expr* offset);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.LimitExpr)
 private:
  void set_has_row_count();
  void clear_has_row_count();
  void set_has_offset();
  void clear_has_offset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::Mysqlx::Expr::Expr* row_count_;
  ::Mysqlx::Expr::Expr* offset_;
  friend struct ::protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Order : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Order) */ {
 public:
  Order();
  virtual ~Order();

  Order(const Order& from);

  inline Order& operator=(const Order& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Order(Order&& from) noexcept
    : Order() {
    *this = ::std::move(from);
  }

  inline Order& operator=(Order&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Order& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Order* internal_default_instance() {
    return reinterpret_cast<const Order*>(
               &_Order_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Order* other);
  friend void swap(Order& a, Order& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Order* New() const final {
    return CreateMaybeMessage<Order>(NULL);
  }

  Order* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Order>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Order& from);
  void MergeFrom(const Order& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Order* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Order_Direction Direction;
  static const Direction ASC =
    Order_Direction_ASC;
  static const Direction DESC =
    Order_Direction_DESC;
  static inline bool Direction_IsValid(int value) {
    return Order_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    Order_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    Order_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    Order_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return Order_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return Order_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return Order_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Mysqlx.Expr.Expr expr = 1;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 1;
  private:
  const ::Mysqlx::Expr::Expr& _internal_expr() const;
  public:
  const ::Mysqlx::Expr::Expr& expr() const;
  ::Mysqlx::Expr::Expr* release_expr();
  ::Mysqlx::Expr::Expr* mutable_expr();
  void set_allocated_expr(::Mysqlx::Expr::Expr* expr);

  // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  ::Mysqlx::Crud::Order_Direction direction() const;
  void set_direction(::Mysqlx::Crud::Order_Direction value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Order)
 private:
  void set_has_expr();
  void clear_has_expr();
  void set_has_direction();
  void clear_has_direction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::Mysqlx::Expr::Expr* expr_;
  int direction_;
  friend struct ::protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateOperation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.UpdateOperation) */ {
 public:
  UpdateOperation();
  virtual ~UpdateOperation();

  UpdateOperation(const UpdateOperation& from);

  inline UpdateOperation& operator=(const UpdateOperation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateOperation(UpdateOperation&& from) noexcept
    : UpdateOperation() {
    *this = ::std::move(from);
  }

  inline UpdateOperation& operator=(UpdateOperation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateOperation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateOperation* internal_default_instance() {
    return reinterpret_cast<const UpdateOperation*>(
               &_UpdateOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(UpdateOperation* other);
  friend void swap(UpdateOperation& a, UpdateOperation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateOperation* New() const final {
    return CreateMaybeMessage<UpdateOperation>(NULL);
  }

  UpdateOperation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateOperation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateOperation& from);
  void MergeFrom(const UpdateOperation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateOperation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UpdateOperation_UpdateType UpdateType;
  static const UpdateType SET =
    UpdateOperation_UpdateType_SET;
  static const UpdateType ITEM_REMOVE =
    UpdateOperation_UpdateType_ITEM_REMOVE;
  static const UpdateType ITEM_SET =
    UpdateOperation_UpdateType_ITEM_SET;
  static const UpdateType ITEM_REPLACE =
    UpdateOperation_UpdateType_ITEM_REPLACE;
  static const UpdateType ITEM_MERGE =
    UpdateOperation_UpdateType_ITEM_MERGE;
  static const UpdateType ARRAY_INSERT =
    UpdateOperation_UpdateType_ARRAY_INSERT;
  static const UpdateType ARRAY_APPEND =
    UpdateOperation_UpdateType_ARRAY_APPEND;
  static const UpdateType MERGE_PATCH =
    UpdateOperation_UpdateType_MERGE_PATCH;
  static inline bool UpdateType_IsValid(int value) {
    return UpdateOperation_UpdateType_IsValid(value);
  }
  static const UpdateType UpdateType_MIN =
    UpdateOperation_UpdateType_UpdateType_MIN;
  static const UpdateType UpdateType_MAX =
    UpdateOperation_UpdateType_UpdateType_MAX;
  static const int UpdateType_ARRAYSIZE =
    UpdateOperation_UpdateType_UpdateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  UpdateType_descriptor() {
    return UpdateOperation_UpdateType_descriptor();
  }
  static inline const ::std::string& UpdateType_Name(UpdateType value) {
    return UpdateOperation_UpdateType_Name(value);
  }
  static inline bool UpdateType_Parse(const ::std::string& name,
      UpdateType* value) {
    return UpdateOperation_UpdateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Mysqlx.Expr.ColumnIdentifier source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  private:
  const ::Mysqlx::Expr::ColumnIdentifier& _internal_source() const;
  public:
  const ::Mysqlx::Expr::ColumnIdentifier& source() const;
  ::Mysqlx::Expr::ColumnIdentifier* release_source();
  ::Mysqlx::Expr::ColumnIdentifier* mutable_source();
  void set_allocated_source(::Mysqlx::Expr::ColumnIdentifier* source);

  // optional .Mysqlx.Expr.Expr value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  private:
  const ::Mysqlx::Expr::Expr& _internal_value() const;
  public:
  const ::Mysqlx::Expr::Expr& value() const;
  ::Mysqlx::Expr::Expr* release_value();
  ::Mysqlx::Expr::Expr* mutable_value();
  void set_allocated_value(::Mysqlx::Expr::Expr* value);

  // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
  bool has_operation() const;
  void clear_operation();
  static const int kOperationFieldNumber = 2;
  ::Mysqlx::Crud::UpdateOperation_UpdateType operation() const;
  void set_operation(::Mysqlx::Crud::UpdateOperation_UpdateType value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.UpdateOperation)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_operation();
  void clear_has_operation();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::Mysqlx::Expr::ColumnIdentifier* source_;
  ::Mysqlx::Expr::Expr* value_;
  int operation_;
  friend struct ::protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Find : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Find) */ {
 public:
  Find();
  virtual ~Find();

  Find(const Find& from);

  inline Find& operator=(const Find& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Find(Find&& from) noexcept
    : Find() {
    *this = ::std::move(from);
  }

  inline Find& operator=(Find&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Find& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Find* internal_default_instance() {
    return reinterpret_cast<const Find*>(
               &_Find_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Find* other);
  friend void swap(Find& a, Find& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Find* New() const final {
    return CreateMaybeMessage<Find>(NULL);
  }

  Find* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Find>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Find& from);
  void MergeFrom(const Find& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Find* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Find_RowLock RowLock;
  static const RowLock SHARED_LOCK =
    Find_RowLock_SHARED_LOCK;
  static const RowLock EXCLUSIVE_LOCK =
    Find_RowLock_EXCLUSIVE_LOCK;
  static inline bool RowLock_IsValid(int value) {
    return Find_RowLock_IsValid(value);
  }
  static const RowLock RowLock_MIN =
    Find_RowLock_RowLock_MIN;
  static const RowLock RowLock_MAX =
    Find_RowLock_RowLock_MAX;
  static const int RowLock_ARRAYSIZE =
    Find_RowLock_RowLock_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RowLock_descriptor() {
    return Find_RowLock_descriptor();
  }
  static inline const ::std::string& RowLock_Name(RowLock value) {
    return Find_RowLock_Name(value);
  }
  static inline bool RowLock_Parse(const ::std::string& name,
      RowLock* value) {
    return Find_RowLock_Parse(name, value);
  }

  typedef Find_RowLockOptions RowLockOptions;
  static const RowLockOptions NOWAIT =
    Find_RowLockOptions_NOWAIT;
  static const RowLockOptions SKIP_LOCKED =
    Find_RowLockOptions_SKIP_LOCKED;
  static inline bool RowLockOptions_IsValid(int value) {
    return Find_RowLockOptions_IsValid(value);
  }
  static const RowLockOptions RowLockOptions_MIN =
    Find_RowLockOptions_RowLockOptions_MIN;
  static const RowLockOptions RowLockOptions_MAX =
    Find_RowLockOptions_RowLockOptions_MAX;
  static const int RowLockOptions_ARRAYSIZE =
    Find_RowLockOptions_RowLockOptions_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RowLockOptions_descriptor() {
    return Find_RowLockOptions_descriptor();
  }
  static inline const ::std::string& RowLockOptions_Name(RowLockOptions value) {
    return Find_RowLockOptions_Name(value);
  }
  static inline bool RowLockOptions_Parse(const ::std::string& name,
      RowLockOptions* value) {
    return Find_RowLockOptions_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Crud.Projection projection = 4;
  int projection_size() const;
  void clear_projection();
  static const int kProjectionFieldNumber = 4;
  ::Mysqlx::Crud::Projection* mutable_projection(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Projection >*
      mutable_projection();
  const ::Mysqlx::Crud::Projection& projection(int index) const;
  ::Mysqlx::Crud::Projection* add_projection();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Projection >&
      projection() const;

  // repeated .Mysqlx.Crud.Order order = 7;
  int order_size() const;
  void clear_order();
  static const int kOrderFieldNumber = 7;
  ::Mysqlx::Crud::Order* mutable_order(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
      mutable_order();
  const ::Mysqlx::Crud::Order& order(int index) const;
  ::Mysqlx::Crud::Order* add_order();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
      order() const;

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  int grouping_size() const;
  void clear_grouping();
  static const int kGroupingFieldNumber = 8;
  ::Mysqlx::Expr::Expr* mutable_grouping(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_grouping();
  const ::Mysqlx::Expr::Expr& grouping(int index) const;
  ::Mysqlx::Expr::Expr* add_grouping();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      grouping() const;

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 11;
  ::Mysqlx::Datatypes::Scalar* mutable_args(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
      mutable_args();
  const ::Mysqlx::Datatypes::Scalar& args(int index) const;
  ::Mysqlx::Datatypes::Scalar* add_args();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
      args() const;

  // required .Mysqlx.Crud.Collection collection = 2;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  private:
  const ::Mysqlx::Crud::Collection& _internal_collection() const;
  public:
  const ::Mysqlx::Crud::Collection& collection() const;
  ::Mysqlx::Crud::Collection* release_collection();
  ::Mysqlx::Crud::Collection* mutable_collection();
  void set_allocated_collection(::Mysqlx::Crud::Collection* collection);

  // optional .Mysqlx.Expr.Expr criteria = 5;
  bool has_criteria() const;
  void clear_criteria();
  static const int kCriteriaFieldNumber = 5;
  private:
  const ::Mysqlx::Expr::Expr& _internal_criteria() const;
  public:
  const ::Mysqlx::Expr::Expr& criteria() const;
  ::Mysqlx::Expr::Expr* release_criteria();
  ::Mysqlx::Expr::Expr* mutable_criteria();
  void set_allocated_criteria(::Mysqlx::Expr::Expr* criteria);

  // optional .Mysqlx.Crud.Limit limit = 6;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 6;
  private:
  const ::Mysqlx::Crud::Limit& _internal_limit() const;
  public:
  const ::Mysqlx::Crud::Limit& limit() const;
  ::Mysqlx::Crud::Limit* release_limit();
  ::Mysqlx::Crud::Limit* mutable_limit();
  void set_allocated_limit(::Mysqlx::Crud::Limit* limit);

  // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
  bool has_grouping_criteria() const;
  void clear_grouping_criteria();
  static const int kGroupingCriteriaFieldNumber = 9;
  private:
  const ::Mysqlx::Expr::Expr& _internal_grouping_criteria() const;
  public:
  const ::Mysqlx::Expr::Expr& grouping_criteria() const;
  ::Mysqlx::Expr::Expr* release_grouping_criteria();
  ::Mysqlx::Expr::Expr* mutable_grouping_criteria();
  void set_allocated_grouping_criteria(::Mysqlx::Expr::Expr* grouping_criteria);

  // optional .Mysqlx.Crud.LimitExpr limit_expr = 14;
  bool has_limit_expr() const;
  void clear_limit_expr();
  static const int kLimitExprFieldNumber = 14;
  private:
  const ::Mysqlx::Crud::LimitExpr& _internal_limit_expr() const;
  public:
  const ::Mysqlx::Crud::LimitExpr& limit_expr() const;
  ::Mysqlx::Crud::LimitExpr* release_limit_expr();
  ::Mysqlx::Crud::LimitExpr* mutable_limit_expr();
  void set_allocated_limit_expr(::Mysqlx::Crud::LimitExpr* limit_expr);

  // optional .Mysqlx.Crud.Find.RowLockOptions locking_options = 13;
  bool has_locking_options() const;
  void clear_locking_options();
  static const int kLockingOptionsFieldNumber = 13;
  ::Mysqlx::Crud::Find_RowLockOptions locking_options() const;
  void set_locking_options(::Mysqlx::Crud::Find_RowLockOptions value);

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  bool has_data_model() const;
  void clear_data_model();
  static const int kDataModelFieldNumber = 3;
  ::Mysqlx::Crud::DataModel data_model() const;
  void set_data_model(::Mysqlx::Crud::DataModel value);

  // optional .Mysqlx.Crud.Find.RowLock locking = 12;
  bool has_locking() const;
  void clear_locking();
  static const int kLockingFieldNumber = 12;
  ::Mysqlx::Crud::Find_RowLock locking() const;
  void set_locking(::Mysqlx::Crud::Find_RowLock value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Find)
 private:
  void set_has_collection();
  void clear_has_collection();
  void set_has_data_model();
  void clear_has_data_model();
  void set_has_criteria();
  void clear_has_criteria();
  void set_has_grouping_criteria();
  void clear_has_grouping_criteria();
  void set_has_locking();
  void clear_has_locking();
  void set_has_locking_options();
  void clear_has_locking_options();
  void set_has_limit();
  void clear_has_limit();
  void set_has_limit_expr();
  void clear_has_limit_expr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Projection > projection_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order > order_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr > grouping_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar > args_;
  ::Mysqlx::Crud::Collection* collection_;
  ::Mysqlx::Expr::Expr* criteria_;
  ::Mysqlx::Crud::Limit* limit_;
  ::Mysqlx::Expr::Expr* grouping_criteria_;
  ::Mysqlx::Crud::LimitExpr* limit_expr_;
  int locking_options_;
  int data_model_;
  int locking_;
  friend struct ::protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Insert_TypedRow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Insert.TypedRow) */ {
 public:
  Insert_TypedRow();
  virtual ~Insert_TypedRow();

  Insert_TypedRow(const Insert_TypedRow& from);

  inline Insert_TypedRow& operator=(const Insert_TypedRow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Insert_TypedRow(Insert_TypedRow&& from) noexcept
    : Insert_TypedRow() {
    *this = ::std::move(from);
  }

  inline Insert_TypedRow& operator=(Insert_TypedRow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Insert_TypedRow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Insert_TypedRow* internal_default_instance() {
    return reinterpret_cast<const Insert_TypedRow*>(
               &_Insert_TypedRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Insert_TypedRow* other);
  friend void swap(Insert_TypedRow& a, Insert_TypedRow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Insert_TypedRow* New() const final {
    return CreateMaybeMessage<Insert_TypedRow>(NULL);
  }

  Insert_TypedRow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Insert_TypedRow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Insert_TypedRow& from);
  void MergeFrom(const Insert_TypedRow& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Insert_TypedRow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Expr.Expr field = 1;
  int field_size() const;
  void clear_field();
  static const int kFieldFieldNumber = 1;
  ::Mysqlx::Expr::Expr* mutable_field(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_field();
  const ::Mysqlx::Expr::Expr& field(int index) const;
  ::Mysqlx::Expr::Expr* add_field();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      field() const;

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Insert.TypedRow)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr > field_;
  friend struct ::protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Insert : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Insert) */ {
 public:
  Insert();
  virtual ~Insert();

  Insert(const Insert& from);

  inline Insert& operator=(const Insert& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Insert(Insert&& from) noexcept
    : Insert() {
    *this = ::std::move(from);
  }

  inline Insert& operator=(Insert&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Insert& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Insert* internal_default_instance() {
    return reinterpret_cast<const Insert*>(
               &_Insert_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Insert* other);
  friend void swap(Insert& a, Insert& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Insert* New() const final {
    return CreateMaybeMessage<Insert>(NULL);
  }

  Insert* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Insert>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Insert& from);
  void MergeFrom(const Insert& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Insert* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Insert_TypedRow TypedRow;

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Crud.Column projection = 3;
  int projection_size() const;
  void clear_projection();
  static const int kProjectionFieldNumber = 3;
  ::Mysqlx::Crud::Column* mutable_projection(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Column >*
      mutable_projection();
  const ::Mysqlx::Crud::Column& projection(int index) const;
  ::Mysqlx::Crud::Column* add_projection();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Column >&
      projection() const;

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  int row_size() const;
  void clear_row();
  static const int kRowFieldNumber = 4;
  ::Mysqlx::Crud::Insert_TypedRow* mutable_row(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow >*
      mutable_row();
  const ::Mysqlx::Crud::Insert_TypedRow& row(int index) const;
  ::Mysqlx::Crud::Insert_TypedRow* add_row();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow >&
      row() const;

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 5;
  ::Mysqlx::Datatypes::Scalar* mutable_args(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
      mutable_args();
  const ::Mysqlx::Datatypes::Scalar& args(int index) const;
  ::Mysqlx::Datatypes::Scalar* add_args();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
      args() const;

  // required .Mysqlx.Crud.Collection collection = 1;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 1;
  private:
  const ::Mysqlx::Crud::Collection& _internal_collection() const;
  public:
  const ::Mysqlx::Crud::Collection& collection() const;
  ::Mysqlx::Crud::Collection* release_collection();
  ::Mysqlx::Crud::Collection* mutable_collection();
  void set_allocated_collection(::Mysqlx::Crud::Collection* collection);

  // optional bool upsert = 6 [default = false];
  bool has_upsert() const;
  void clear_upsert();
  static const int kUpsertFieldNumber = 6;
  bool upsert() const;
  void set_upsert(bool value);

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  bool has_data_model() const;
  void clear_data_model();
  static const int kDataModelFieldNumber = 2;
  ::Mysqlx::Crud::DataModel data_model() const;
  void set_data_model(::Mysqlx::Crud::DataModel value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Insert)
 private:
  void set_has_collection();
  void clear_has_collection();
  void set_has_data_model();
  void clear_has_data_model();
  void set_has_upsert();
  void clear_has_upsert();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Column > projection_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow > row_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar > args_;
  ::Mysqlx::Crud::Collection* collection_;
  bool upsert_;
  int data_model_;
  friend struct ::protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Update : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Update) */ {
 public:
  Update();
  virtual ~Update();

  Update(const Update& from);

  inline Update& operator=(const Update& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Update(Update&& from) noexcept
    : Update() {
    *this = ::std::move(from);
  }

  inline Update& operator=(Update&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Update& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Update* internal_default_instance() {
    return reinterpret_cast<const Update*>(
               &_Update_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Update* other);
  friend void swap(Update& a, Update& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Update* New() const final {
    return CreateMaybeMessage<Update>(NULL);
  }

  Update* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Update>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Update& from);
  void MergeFrom(const Update& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Update* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Crud.Order order = 6;
  int order_size() const;
  void clear_order();
  static const int kOrderFieldNumber = 6;
  ::Mysqlx::Crud::Order* mutable_order(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
      mutable_order();
  const ::Mysqlx::Crud::Order& order(int index) const;
  ::Mysqlx::Crud::Order* add_order();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
      order() const;

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  int operation_size() const;
  void clear_operation();
  static const int kOperationFieldNumber = 7;
  ::Mysqlx::Crud::UpdateOperation* mutable_operation(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation >*
      mutable_operation();
  const ::Mysqlx::Crud::UpdateOperation& operation(int index) const;
  ::Mysqlx::Crud::UpdateOperation* add_operation();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation >&
      operation() const;

  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 8;
  ::Mysqlx::Datatypes::Scalar* mutable_args(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
      mutable_args();
  const ::Mysqlx::Datatypes::Scalar& args(int index) const;
  ::Mysqlx::Datatypes::Scalar* add_args();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
      args() const;

  // required .Mysqlx.Crud.Collection collection = 2;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  private:
  const ::Mysqlx::Crud::Collection& _internal_collection() const;
  public:
  const ::Mysqlx::Crud::Collection& collection() const;
  ::Mysqlx::Crud::Collection* release_collection();
  ::Mysqlx::Crud::Collection* mutable_collection();
  void set_allocated_collection(::Mysqlx::Crud::Collection* collection);

  // optional .Mysqlx.Expr.Expr criteria = 4;
  bool has_criteria() const;
  void clear_criteria();
  static const int kCriteriaFieldNumber = 4;
  private:
  const ::Mysqlx::Expr::Expr& _internal_criteria() const;
  public:
  const ::Mysqlx::Expr::Expr& criteria() const;
  ::Mysqlx::Expr::Expr* release_criteria();
  ::Mysqlx::Expr::Expr* mutable_criteria();
  void set_allocated_criteria(::Mysqlx::Expr::Expr* criteria);

  // optional .Mysqlx.Crud.Limit limit = 5;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 5;
  private:
  const ::Mysqlx::Crud::Limit& _internal_limit() const;
  public:
  const ::Mysqlx::Crud::Limit& limit() const;
  ::Mysqlx::Crud::Limit* release_limit();
  ::Mysqlx::Crud::Limit* mutable_limit();
  void set_allocated_limit(::Mysqlx::Crud::Limit* limit);

  // optional .Mysqlx.Crud.LimitExpr limit_expr = 9;
  bool has_limit_expr() const;
  void clear_limit_expr();
  static const int kLimitExprFieldNumber = 9;
  private:
  const ::Mysqlx::Crud::LimitExpr& _internal_limit_expr() const;
  public:
  const ::Mysqlx::Crud::LimitExpr& limit_expr() const;
  ::Mysqlx::Crud::LimitExpr* release_limit_expr();
  ::Mysqlx::Crud::LimitExpr* mutable_limit_expr();
  void set_allocated_limit_expr(::Mysqlx::Crud::LimitExpr* limit_expr);

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  bool has_data_model() const;
  void clear_data_model();
  static const int kDataModelFieldNumber = 3;
  ::Mysqlx::Crud::DataModel data_model() const;
  void set_data_model(::Mysqlx::Crud::DataModel value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Update)
 private:
  void set_has_collection();
  void clear_has_collection();
  void set_has_data_model();
  void clear_has_data_model();
  void set_has_criteria();
  void clear_has_criteria();
  void set_has_limit();
  void clear_has_limit();
  void set_has_limit_expr();
  void clear_has_limit_expr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order > order_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation > operation_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar > args_;
  ::Mysqlx::Crud::Collection* collection_;
  ::Mysqlx::Expr::Expr* criteria_;
  ::Mysqlx::Crud::Limit* limit_;
  ::Mysqlx::Crud::LimitExpr* limit_expr_;
  int data_model_;
  friend struct ::protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Delete : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Delete) */ {
 public:
  Delete();
  virtual ~Delete();

  Delete(const Delete& from);

  inline Delete& operator=(const Delete& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Delete(Delete&& from) noexcept
    : Delete() {
    *this = ::std::move(from);
  }

  inline Delete& operator=(Delete&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Delete& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Delete* internal_default_instance() {
    return reinterpret_cast<const Delete*>(
               &_Delete_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Delete* other);
  friend void swap(Delete& a, Delete& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Delete* New() const final {
    return CreateMaybeMessage<Delete>(NULL);
  }

  Delete* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Delete>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Delete& from);
  void MergeFrom(const Delete& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Delete* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Crud.Order order = 5;
  int order_size() const;
  void clear_order();
  static const int kOrderFieldNumber = 5;
  ::Mysqlx::Crud::Order* mutable_order(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
      mutable_order();
  const ::Mysqlx::Crud::Order& order(int index) const;
  ::Mysqlx::Crud::Order* add_order();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
      order() const;

  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 6;
  ::Mysqlx::Datatypes::Scalar* mutable_args(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
      mutable_args();
  const ::Mysqlx::Datatypes::Scalar& args(int index) const;
  ::Mysqlx::Datatypes::Scalar* add_args();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
      args() const;

  // required .Mysqlx.Crud.Collection collection = 1;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 1;
  private:
  const ::Mysqlx::Crud::Collection& _internal_collection() const;
  public:
  const ::Mysqlx::Crud::Collection& collection() const;
  ::Mysqlx::Crud::Collection* release_collection();
  ::Mysqlx::Crud::Collection* mutable_collection();
  void set_allocated_collection(::Mysqlx::Crud::Collection* collection);

  // optional .Mysqlx.Expr.Expr criteria = 3;
  bool has_criteria() const;
  void clear_criteria();
  static const int kCriteriaFieldNumber = 3;
  private:
  const ::Mysqlx::Expr::Expr& _internal_criteria() const;
  public:
  const ::Mysqlx::Expr::Expr& criteria() const;
  ::Mysqlx::Expr::Expr* release_criteria();
  ::Mysqlx::Expr::Expr* mutable_criteria();
  void set_allocated_criteria(::Mysqlx::Expr::Expr* criteria);

  // optional .Mysqlx.Crud.Limit limit = 4;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 4;
  private:
  const ::Mysqlx::Crud::Limit& _internal_limit() const;
  public:
  const ::Mysqlx::Crud::Limit& limit() const;
  ::Mysqlx::Crud::Limit* release_limit();
  ::Mysqlx::Crud::Limit* mutable_limit();
  void set_allocated_limit(::Mysqlx::Crud::Limit* limit);

  // optional .Mysqlx.Crud.LimitExpr limit_expr = 7;
  bool has_limit_expr() const;
  void clear_limit_expr();
  static const int kLimitExprFieldNumber = 7;
  private:
  const ::Mysqlx::Crud::LimitExpr& _internal_limit_expr() const;
  public:
  const ::Mysqlx::Crud::LimitExpr& limit_expr() const;
  ::Mysqlx::Crud::LimitExpr* release_limit_expr();
  ::Mysqlx::Crud::LimitExpr* mutable_limit_expr();
  void set_allocated_limit_expr(::Mysqlx::Crud::LimitExpr* limit_expr);

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  bool has_data_model() const;
  void clear_data_model();
  static const int kDataModelFieldNumber = 2;
  ::Mysqlx::Crud::DataModel data_model() const;
  void set_data_model(::Mysqlx::Crud::DataModel value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Delete)
 private:
  void set_has_collection();
  void clear_has_collection();
  void set_has_data_model();
  void clear_has_data_model();
  void set_has_criteria();
  void clear_has_criteria();
  void set_has_limit();
  void clear_has_limit();
  void set_has_limit_expr();
  void clear_has_limit_expr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order > order_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar > args_;
  ::Mysqlx::Crud::Collection* collection_;
  ::Mysqlx::Expr::Expr* criteria_;
  ::Mysqlx::Crud::Limit* limit_;
  ::Mysqlx::Crud::LimitExpr* limit_expr_;
  int data_model_;
  friend struct ::protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.CreateView) */ {
 public:
  CreateView();
  virtual ~CreateView();

  CreateView(const CreateView& from);

  inline CreateView& operator=(const CreateView& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateView(CreateView&& from) noexcept
    : CreateView() {
    *this = ::std::move(from);
  }

  inline CreateView& operator=(CreateView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateView* internal_default_instance() {
    return reinterpret_cast<const CreateView*>(
               &_CreateView_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(CreateView* other);
  friend void swap(CreateView& a, CreateView& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateView* New() const final {
    return CreateMaybeMessage<CreateView>(NULL);
  }

  CreateView* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateView>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateView& from);
  void MergeFrom(const CreateView& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string column = 6;
  int column_size() const;
  void clear_column();
  static const int kColumnFieldNumber = 6;
  const ::std::string& column(int index) const;
  ::std::string* mutable_column(int index);
  void set_column(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_column(int index, ::std::string&& value);
  #endif
  void set_column(int index, const char* value);
  void set_column(int index, const char* value, size_t size);
  ::std::string* add_column();
  void add_column(const ::std::string& value);
  #if LANG_CXX11
  void add_column(::std::string&& value);
  #endif
  void add_column(const char* value);
  void add_column(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& column() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_column();

  // optional string definer = 2;
  bool has_definer() const;
  void clear_definer();
  static const int kDefinerFieldNumber = 2;
  const ::std::string& definer() const;
  void set_definer(const ::std::string& value);
  #if LANG_CXX11
  void set_definer(::std::string&& value);
  #endif
  void set_definer(const char* value);
  void set_definer(const char* value, size_t size);
  ::std::string* mutable_definer();
  ::std::string* release_definer();
  void set_allocated_definer(::std::string* definer);

  // required .Mysqlx.Crud.Collection collection = 1;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 1;
  private:
  const ::Mysqlx::Crud::Collection& _internal_collection() const;
  public:
  const ::Mysqlx::Crud::Collection& collection() const;
  ::Mysqlx::Crud::Collection* release_collection();
  ::Mysqlx::Crud::Collection* mutable_collection();
  void set_allocated_collection(::Mysqlx::Crud::Collection* collection);

  // required .Mysqlx.Crud.Find stmt = 7;
  bool has_stmt() const;
  void clear_stmt();
  static const int kStmtFieldNumber = 7;
  private:
  const ::Mysqlx::Crud::Find& _internal_stmt() const;
  public:
  const ::Mysqlx::Crud::Find& stmt() const;
  ::Mysqlx::Crud::Find* release_stmt();
  ::Mysqlx::Crud::Find* mutable_stmt();
  void set_allocated_stmt(::Mysqlx::Crud::Find* stmt);

  // optional bool replace_existing = 8 [default = false];
  bool has_replace_existing() const;
  void clear_replace_existing();
  static const int kReplaceExistingFieldNumber = 8;
  bool replace_existing() const;
  void set_replace_existing(bool value);

  // optional .Mysqlx.Crud.ViewCheckOption check = 5;
  bool has_check() const;
  void clear_check();
  static const int kCheckFieldNumber = 5;
  ::Mysqlx::Crud::ViewCheckOption check() const;
  void set_check(::Mysqlx::Crud::ViewCheckOption value);

  // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3 [default = UNDEFINED];
  bool has_algorithm() const;
  void clear_algorithm();
  static const int kAlgorithmFieldNumber = 3;
  ::Mysqlx::Crud::ViewAlgorithm algorithm() const;
  void set_algorithm(::Mysqlx::Crud::ViewAlgorithm value);

  // optional .Mysqlx.Crud.ViewSqlSecurity security = 4 [default = DEFINER];
  bool has_security() const;
  void clear_security();
  static const int kSecurityFieldNumber = 4;
  ::Mysqlx::Crud::ViewSqlSecurity security() const;
  void set_security(::Mysqlx::Crud::ViewSqlSecurity value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.CreateView)
 private:
  void set_has_collection();
  void clear_has_collection();
  void set_has_definer();
  void clear_has_definer();
  void set_has_algorithm();
  void clear_has_algorithm();
  void set_has_security();
  void clear_has_security();
  void set_has_check();
  void clear_has_check();
  void set_has_stmt();
  void clear_has_stmt();
  void set_has_replace_existing();
  void clear_has_replace_existing();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> column_;
  ::google::protobuf::internal::ArenaStringPtr definer_;
  ::Mysqlx::Crud::Collection* collection_;
  ::Mysqlx::Crud::Find* stmt_;
  bool replace_existing_;
  int check_;
  int algorithm_;
  int security_;
  friend struct ::protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModifyView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.ModifyView) */ {
 public:
  ModifyView();
  virtual ~ModifyView();

  ModifyView(const ModifyView& from);

  inline ModifyView& operator=(const ModifyView& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModifyView(ModifyView&& from) noexcept
    : ModifyView() {
    *this = ::std::move(from);
  }

  inline ModifyView& operator=(ModifyView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModifyView* internal_default_instance() {
    return reinterpret_cast<const ModifyView*>(
               &_ModifyView_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ModifyView* other);
  friend void swap(ModifyView& a, ModifyView& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModifyView* New() const final {
    return CreateMaybeMessage<ModifyView>(NULL);
  }

  ModifyView* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModifyView>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModifyView& from);
  void MergeFrom(const ModifyView& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifyView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string column = 6;
  int column_size() const;
  void clear_column();
  static const int kColumnFieldNumber = 6;
  const ::std::string& column(int index) const;
  ::std::string* mutable_column(int index);
  void set_column(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_column(int index, ::std::string&& value);
  #endif
  void set_column(int index, const char* value);
  void set_column(int index, const char* value, size_t size);
  ::std::string* add_column();
  void add_column(const ::std::string& value);
  #if LANG_CXX11
  void add_column(::std::string&& value);
  #endif
  void add_column(const char* value);
  void add_column(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& column() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_column();

  // optional string definer = 2;
  bool has_definer() const;
  void clear_definer();
  static const int kDefinerFieldNumber = 2;
  const ::std::string& definer() const;
  void set_definer(const ::std::string& value);
  #if LANG_CXX11
  void set_definer(::std::string&& value);
  #endif
  void set_definer(const char* value);
  void set_definer(const char* value, size_t size);
  ::std::string* mutable_definer();
  ::std::string* release_definer();
  void set_allocated_definer(::std::string* definer);

  // required .Mysqlx.Crud.Collection collection = 1;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 1;
  private:
  const ::Mysqlx::Crud::Collection& _internal_collection() const;
  public:
  const ::Mysqlx::Crud::Collection& collection() const;
  ::Mysqlx::Crud::Collection* release_collection();
  ::Mysqlx::Crud::Collection* mutable_collection();
  void set_allocated_collection(::Mysqlx::Crud::Collection* collection);

  // optional .Mysqlx.Crud.Find stmt = 7;
  bool has_stmt() const;
  void clear_stmt();
  static const int kStmtFieldNumber = 7;
  private:
  const ::Mysqlx::Crud::Find& _internal_stmt() const;
  public:
  const ::Mysqlx::Crud::Find& stmt() const;
  ::Mysqlx::Crud::Find* release_stmt();
  ::Mysqlx::Crud::Find* mutable_stmt();
  void set_allocated_stmt(::Mysqlx::Crud::Find* stmt);

  // optional .Mysqlx.Crud.ViewCheckOption check = 5;
  bool has_check() const;
  void clear_check();
  static const int kCheckFieldNumber = 5;
  ::Mysqlx::Crud::ViewCheckOption check() const;
  void set_check(::Mysqlx::Crud::ViewCheckOption value);

  // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3;
  bool has_algorithm() const;
  void clear_algorithm();
  static const int kAlgorithmFieldNumber = 3;
  ::Mysqlx::Crud::ViewAlgorithm algorithm() const;
  void set_algorithm(::Mysqlx::Crud::ViewAlgorithm value);

  // optional .Mysqlx.Crud.ViewSqlSecurity security = 4;
  bool has_security() const;
  void clear_security();
  static const int kSecurityFieldNumber = 4;
  ::Mysqlx::Crud::ViewSqlSecurity security() const;
  void set_security(::Mysqlx::Crud::ViewSqlSecurity value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.ModifyView)
 private:
  void set_has_collection();
  void clear_has_collection();
  void set_has_definer();
  void clear_has_definer();
  void set_has_algorithm();
  void clear_has_algorithm();
  void set_has_security();
  void clear_has_security();
  void set_has_check();
  void clear_has_check();
  void set_has_stmt();
  void clear_has_stmt();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> column_;
  ::google::protobuf::internal::ArenaStringPtr definer_;
  ::Mysqlx::Crud::Collection* collection_;
  ::Mysqlx::Crud::Find* stmt_;
  int check_;
  int algorithm_;
  int security_;
  friend struct ::protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DropView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.DropView) */ {
 public:
  DropView();
  virtual ~DropView();

  DropView(const DropView& from);

  inline DropView& operator=(const DropView& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DropView(DropView&& from) noexcept
    : DropView() {
    *this = ::std::move(from);
  }

  inline DropView& operator=(DropView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DropView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DropView* internal_default_instance() {
    return reinterpret_cast<const DropView*>(
               &_DropView_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(DropView* other);
  friend void swap(DropView& a, DropView& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DropView* New() const final {
    return CreateMaybeMessage<DropView>(NULL);
  }

  DropView* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DropView>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DropView& from);
  void MergeFrom(const DropView& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Mysqlx.Crud.Collection collection = 1;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 1;
  private:
  const ::Mysqlx::Crud::Collection& _internal_collection() const;
  public:
  const ::Mysqlx::Crud::Collection& collection() const;
  ::Mysqlx::Crud::Collection* release_collection();
  ::Mysqlx::Crud::Collection* mutable_collection();
  void set_allocated_collection(::Mysqlx::Crud::Collection* collection);

  // optional bool if_exists = 2 [default = false];
  bool has_if_exists() const;
  void clear_if_exists();
  static const int kIfExistsFieldNumber = 2;
  bool if_exists() const;
  void set_if_exists(bool value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.DropView)
 private:
  void set_has_collection();
  void clear_has_collection();
  void set_has_if_exists();
  void clear_has_if_exists();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::Mysqlx::Crud::Collection* collection_;
  bool if_exists_;
  friend struct ::protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Column

// optional string name = 1;
inline bool Column::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Column::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Column::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Column::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Column::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Column.name)
  return name_.GetNoArena();
}
inline void Column::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Column.name)
}
#if LANG_CXX11
inline void Column::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Column.name)
}
#endif
inline void Column::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Column.name)
}
inline void Column::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Column.name)
}
inline ::std::string* Column::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Column.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Column::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Column.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Column::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Column.name)
}

// optional string alias = 2;
inline bool Column::has_alias() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Column::set_has_alias() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Column::clear_has_alias() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Column::clear_alias() {
  alias_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_alias();
}
inline const ::std::string& Column::alias() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Column.alias)
  return alias_.GetNoArena();
}
inline void Column::set_alias(const ::std::string& value) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Column.alias)
}
#if LANG_CXX11
inline void Column::set_alias(::std::string&& value) {
  set_has_alias();
  alias_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Column.alias)
}
#endif
inline void Column::set_alias(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Column.alias)
}
inline void Column::set_alias(const char* value, size_t size) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Column.alias)
}
inline ::std::string* Column::mutable_alias() {
  set_has_alias();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Column.alias)
  return alias_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Column::release_alias() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Column.alias)
  if (!has_alias()) {
    return NULL;
  }
  clear_has_alias();
  return alias_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Column::set_allocated_alias(::std::string* alias) {
  if (alias != NULL) {
    set_has_alias();
  } else {
    clear_has_alias();
  }
  alias_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alias);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Column.alias)
}

// repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
inline int Column::document_path_size() const {
  return document_path_.size();
}
inline ::Mysqlx::Expr::DocumentPathItem* Column::mutable_document_path(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Column.document_path)
  return document_path_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >*
Column::mutable_document_path() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Column.document_path)
  return &document_path_;
}
inline const ::Mysqlx::Expr::DocumentPathItem& Column::document_path(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Column.document_path)
  return document_path_.Get(index);
}
inline ::Mysqlx::Expr::DocumentPathItem* Column::add_document_path() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Column.document_path)
  return document_path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >&
Column::document_path() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Column.document_path)
  return document_path_;
}

// -------------------------------------------------------------------

// Projection

// required .Mysqlx.Expr.Expr source = 1;
inline bool Projection::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Projection::set_has_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Projection::clear_has_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Mysqlx::Expr::Expr& Projection::_internal_source() const {
  return *source_;
}
inline const ::Mysqlx::Expr::Expr& Projection::source() const {
  const ::Mysqlx::Expr::Expr* p = source_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Projection.source)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline ::Mysqlx::Expr::Expr* Projection::release_source() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Projection.source)
  clear_has_source();
  ::Mysqlx::Expr::Expr* temp = source_;
  source_ = NULL;
  return temp;
}
inline ::Mysqlx::Expr::Expr* Projection::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    source_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Projection.source)
  return source_;
}
inline void Projection::set_allocated_source(::Mysqlx::Expr::Expr* source) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(source_);
  }
  if (source) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    set_has_source();
  } else {
    clear_has_source();
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Projection.source)
}

// optional string alias = 2;
inline bool Projection::has_alias() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Projection::set_has_alias() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Projection::clear_has_alias() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Projection::clear_alias() {
  alias_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_alias();
}
inline const ::std::string& Projection::alias() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Projection.alias)
  return alias_.GetNoArena();
}
inline void Projection::set_alias(const ::std::string& value) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Projection.alias)
}
#if LANG_CXX11
inline void Projection::set_alias(::std::string&& value) {
  set_has_alias();
  alias_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Projection.alias)
}
#endif
inline void Projection::set_alias(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Projection.alias)
}
inline void Projection::set_alias(const char* value, size_t size) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Projection.alias)
}
inline ::std::string* Projection::mutable_alias() {
  set_has_alias();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Projection.alias)
  return alias_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Projection::release_alias() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Projection.alias)
  if (!has_alias()) {
    return NULL;
  }
  clear_has_alias();
  return alias_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Projection::set_allocated_alias(::std::string* alias) {
  if (alias != NULL) {
    set_has_alias();
  } else {
    clear_has_alias();
  }
  alias_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alias);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Projection.alias)
}

// -------------------------------------------------------------------

// Collection

// required string name = 1;
inline bool Collection::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Collection::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Collection::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Collection::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Collection::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Collection.name)
  return name_.GetNoArena();
}
inline void Collection::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Collection.name)
}
#if LANG_CXX11
inline void Collection::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Collection.name)
}
#endif
inline void Collection::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Collection.name)
}
inline void Collection::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Collection.name)
}
inline ::std::string* Collection::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Collection.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Collection::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Collection.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Collection::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Collection.name)
}

// optional string schema = 2;
inline bool Collection::has_schema() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Collection::set_has_schema() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Collection::clear_has_schema() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Collection::clear_schema() {
  schema_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_schema();
}
inline const ::std::string& Collection::schema() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Collection.schema)
  return schema_.GetNoArena();
}
inline void Collection::set_schema(const ::std::string& value) {
  set_has_schema();
  schema_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Collection.schema)
}
#if LANG_CXX11
inline void Collection::set_schema(::std::string&& value) {
  set_has_schema();
  schema_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Collection.schema)
}
#endif
inline void Collection::set_schema(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_schema();
  schema_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Collection.schema)
}
inline void Collection::set_schema(const char* value, size_t size) {
  set_has_schema();
  schema_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Collection.schema)
}
inline ::std::string* Collection::mutable_schema() {
  set_has_schema();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Collection.schema)
  return schema_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Collection::release_schema() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Collection.schema)
  if (!has_schema()) {
    return NULL;
  }
  clear_has_schema();
  return schema_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Collection::set_allocated_schema(::std::string* schema) {
  if (schema != NULL) {
    set_has_schema();
  } else {
    clear_has_schema();
  }
  schema_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schema);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Collection.schema)
}

// -------------------------------------------------------------------

// Limit

// required uint64 row_count = 1;
inline bool Limit::has_row_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Limit::set_has_row_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Limit::clear_has_row_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Limit::clear_row_count() {
  row_count_ = GOOGLE_ULONGLONG(0);
  clear_has_row_count();
}
inline ::google::protobuf::uint64 Limit::row_count() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Limit.row_count)
  return row_count_;
}
inline void Limit::set_row_count(::google::protobuf::uint64 value) {
  set_has_row_count();
  row_count_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Limit.row_count)
}

// optional uint64 offset = 2;
inline bool Limit::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Limit::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Limit::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Limit::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 Limit::offset() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Limit.offset)
  return offset_;
}
inline void Limit::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Limit.offset)
}

// -------------------------------------------------------------------

// LimitExpr

// required .Mysqlx.Expr.Expr row_count = 1;
inline bool LimitExpr::has_row_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LimitExpr::set_has_row_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LimitExpr::clear_has_row_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Mysqlx::Expr::Expr& LimitExpr::_internal_row_count() const {
  return *row_count_;
}
inline const ::Mysqlx::Expr::Expr& LimitExpr::row_count() const {
  const ::Mysqlx::Expr::Expr* p = row_count_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.LimitExpr.row_count)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline ::Mysqlx::Expr::Expr* LimitExpr::release_row_count() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.LimitExpr.row_count)
  clear_has_row_count();
  ::Mysqlx::Expr::Expr* temp = row_count_;
  row_count_ = NULL;
  return temp;
}
inline ::Mysqlx::Expr::Expr* LimitExpr::mutable_row_count() {
  set_has_row_count();
  if (row_count_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    row_count_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.LimitExpr.row_count)
  return row_count_;
}
inline void LimitExpr::set_allocated_row_count(::Mysqlx::Expr::Expr* row_count) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(row_count_);
  }
  if (row_count) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      row_count = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, row_count, submessage_arena);
    }
    set_has_row_count();
  } else {
    clear_has_row_count();
  }
  row_count_ = row_count;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.LimitExpr.row_count)
}

// optional .Mysqlx.Expr.Expr offset = 2;
inline bool LimitExpr::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LimitExpr::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LimitExpr::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Mysqlx::Expr::Expr& LimitExpr::_internal_offset() const {
  return *offset_;
}
inline const ::Mysqlx::Expr::Expr& LimitExpr::offset() const {
  const ::Mysqlx::Expr::Expr* p = offset_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.LimitExpr.offset)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline ::Mysqlx::Expr::Expr* LimitExpr::release_offset() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.LimitExpr.offset)
  clear_has_offset();
  ::Mysqlx::Expr::Expr* temp = offset_;
  offset_ = NULL;
  return temp;
}
inline ::Mysqlx::Expr::Expr* LimitExpr::mutable_offset() {
  set_has_offset();
  if (offset_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    offset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.LimitExpr.offset)
  return offset_;
}
inline void LimitExpr::set_allocated_offset(::Mysqlx::Expr::Expr* offset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(offset_);
  }
  if (offset) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      offset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, offset, submessage_arena);
    }
    set_has_offset();
  } else {
    clear_has_offset();
  }
  offset_ = offset;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.LimitExpr.offset)
}

// -------------------------------------------------------------------

// Order

// required .Mysqlx.Expr.Expr expr = 1;
inline bool Order::has_expr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Order::set_has_expr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Order::clear_has_expr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Mysqlx::Expr::Expr& Order::_internal_expr() const {
  return *expr_;
}
inline const ::Mysqlx::Expr::Expr& Order::expr() const {
  const ::Mysqlx::Expr::Expr* p = expr_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Order.expr)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline ::Mysqlx::Expr::Expr* Order::release_expr() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Order.expr)
  clear_has_expr();
  ::Mysqlx::Expr::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline ::Mysqlx::Expr::Expr* Order::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    expr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Order.expr)
  return expr_;
}
inline void Order::set_allocated_expr(::Mysqlx::Expr::Expr* expr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(expr_);
  }
  if (expr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      expr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, expr, submessage_arena);
    }
    set_has_expr();
  } else {
    clear_has_expr();
  }
  expr_ = expr;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Order.expr)
}

// optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
inline bool Order::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Order::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Order::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Order::clear_direction() {
  direction_ = 1;
  clear_has_direction();
}
inline ::Mysqlx::Crud::Order_Direction Order::direction() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Order.direction)
  return static_cast< ::Mysqlx::Crud::Order_Direction >(direction_);
}
inline void Order::set_direction(::Mysqlx::Crud::Order_Direction value) {
  assert(::Mysqlx::Crud::Order_Direction_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Order.direction)
}

// -------------------------------------------------------------------

// UpdateOperation

// required .Mysqlx.Expr.ColumnIdentifier source = 1;
inline bool UpdateOperation::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateOperation::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateOperation::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Mysqlx::Expr::ColumnIdentifier& UpdateOperation::_internal_source() const {
  return *source_;
}
inline const ::Mysqlx::Expr::ColumnIdentifier& UpdateOperation::source() const {
  const ::Mysqlx::Expr::ColumnIdentifier* p = source_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.UpdateOperation.source)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Expr::ColumnIdentifier*>(
      &::Mysqlx::Expr::_ColumnIdentifier_default_instance_);
}
inline ::Mysqlx::Expr::ColumnIdentifier* UpdateOperation::release_source() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.UpdateOperation.source)
  clear_has_source();
  ::Mysqlx::Expr::ColumnIdentifier* temp = source_;
  source_ = NULL;
  return temp;
}
inline ::Mysqlx::Expr::ColumnIdentifier* UpdateOperation::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::ColumnIdentifier>(GetArenaNoVirtual());
    source_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.UpdateOperation.source)
  return source_;
}
inline void UpdateOperation::set_allocated_source(::Mysqlx::Expr::ColumnIdentifier* source) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(source_);
  }
  if (source) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    set_has_source();
  } else {
    clear_has_source();
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.UpdateOperation.source)
}

// required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
inline bool UpdateOperation::has_operation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateOperation::set_has_operation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateOperation::clear_has_operation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateOperation::clear_operation() {
  operation_ = 1;
  clear_has_operation();
}
inline ::Mysqlx::Crud::UpdateOperation_UpdateType UpdateOperation::operation() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.UpdateOperation.operation)
  return static_cast< ::Mysqlx::Crud::UpdateOperation_UpdateType >(operation_);
}
inline void UpdateOperation::set_operation(::Mysqlx::Crud::UpdateOperation_UpdateType value) {
  assert(::Mysqlx::Crud::UpdateOperation_UpdateType_IsValid(value));
  set_has_operation();
  operation_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.UpdateOperation.operation)
}

// optional .Mysqlx.Expr.Expr value = 3;
inline bool UpdateOperation::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateOperation::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateOperation::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Mysqlx::Expr::Expr& UpdateOperation::_internal_value() const {
  return *value_;
}
inline const ::Mysqlx::Expr::Expr& UpdateOperation::value() const {
  const ::Mysqlx::Expr::Expr* p = value_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.UpdateOperation.value)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline ::Mysqlx::Expr::Expr* UpdateOperation::release_value() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.UpdateOperation.value)
  clear_has_value();
  ::Mysqlx::Expr::Expr* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::Mysqlx::Expr::Expr* UpdateOperation::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.UpdateOperation.value)
  return value_;
}
inline void UpdateOperation::set_allocated_value(::Mysqlx::Expr::Expr* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    set_has_value();
  } else {
    clear_has_value();
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.UpdateOperation.value)
}

// -------------------------------------------------------------------

// Find

// required .Mysqlx.Crud.Collection collection = 2;
inline bool Find::has_collection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Find::set_has_collection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Find::clear_has_collection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Find::clear_collection() {
  if (collection_ != NULL) collection_->Clear();
  clear_has_collection();
}
inline const ::Mysqlx::Crud::Collection& Find::_internal_collection() const {
  return *collection_;
}
inline const ::Mysqlx::Crud::Collection& Find::collection() const {
  const ::Mysqlx::Crud::Collection* p = collection_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.collection)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Collection*>(
      &::Mysqlx::Crud::_Collection_default_instance_);
}
inline ::Mysqlx::Crud::Collection* Find::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Find.collection)
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
inline ::Mysqlx::Crud::Collection* Find::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Collection>(GetArenaNoVirtual());
    collection_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.collection)
  return collection_;
}
inline void Find::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete collection_;
  }
  if (collection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      collection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, collection, submessage_arena);
    }
    set_has_collection();
  } else {
    clear_has_collection();
  }
  collection_ = collection;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 3;
inline bool Find::has_data_model() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Find::set_has_data_model() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Find::clear_has_data_model() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Find::clear_data_model() {
  data_model_ = 1;
  clear_has_data_model();
}
inline ::Mysqlx::Crud::DataModel Find::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.data_model)
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
inline void Find::set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  set_has_data_model();
  data_model_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Find.data_model)
}

// repeated .Mysqlx.Crud.Projection projection = 4;
inline int Find::projection_size() const {
  return projection_.size();
}
inline void Find::clear_projection() {
  projection_.Clear();
}
inline ::Mysqlx::Crud::Projection* Find::mutable_projection(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.projection)
  return projection_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Projection >*
Find::mutable_projection() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.projection)
  return &projection_;
}
inline const ::Mysqlx::Crud::Projection& Find::projection(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.projection)
  return projection_.Get(index);
}
inline ::Mysqlx::Crud::Projection* Find::add_projection() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.projection)
  return projection_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Projection >&
Find::projection() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.projection)
  return projection_;
}

// optional .Mysqlx.Expr.Expr criteria = 5;
inline bool Find::has_criteria() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Find::set_has_criteria() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Find::clear_has_criteria() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Mysqlx::Expr::Expr& Find::_internal_criteria() const {
  return *criteria_;
}
inline const ::Mysqlx::Expr::Expr& Find::criteria() const {
  const ::Mysqlx::Expr::Expr* p = criteria_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.criteria)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline ::Mysqlx::Expr::Expr* Find::release_criteria() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Find.criteria)
  clear_has_criteria();
  ::Mysqlx::Expr::Expr* temp = criteria_;
  criteria_ = NULL;
  return temp;
}
inline ::Mysqlx::Expr::Expr* Find::mutable_criteria() {
  set_has_criteria();
  if (criteria_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    criteria_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.criteria)
  return criteria_;
}
inline void Find::set_allocated_criteria(::Mysqlx::Expr::Expr* criteria) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(criteria_);
  }
  if (criteria) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      criteria = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, criteria, submessage_arena);
    }
    set_has_criteria();
  } else {
    clear_has_criteria();
  }
  criteria_ = criteria;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.criteria)
}

// repeated .Mysqlx.Datatypes.Scalar args = 11;
inline int Find::args_size() const {
  return args_.size();
}
inline ::Mysqlx::Datatypes::Scalar* Find::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.args)
  return args_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Find::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.args)
  return &args_;
}
inline const ::Mysqlx::Datatypes::Scalar& Find::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.args)
  return args_.Get(index);
}
inline ::Mysqlx::Datatypes::Scalar* Find::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Find::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.args)
  return args_;
}

// repeated .Mysqlx.Crud.Order order = 7;
inline int Find::order_size() const {
  return order_.size();
}
inline void Find::clear_order() {
  order_.Clear();
}
inline ::Mysqlx::Crud::Order* Find::mutable_order(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.order)
  return order_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
Find::mutable_order() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.order)
  return &order_;
}
inline const ::Mysqlx::Crud::Order& Find::order(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.order)
  return order_.Get(index);
}
inline ::Mysqlx::Crud::Order* Find::add_order() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.order)
  return order_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
Find::order() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.order)
  return order_;
}

// repeated .Mysqlx.Expr.Expr grouping = 8;
inline int Find::grouping_size() const {
  return grouping_.size();
}
inline ::Mysqlx::Expr::Expr* Find::mutable_grouping(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.grouping)
  return grouping_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
Find::mutable_grouping() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.grouping)
  return &grouping_;
}
inline const ::Mysqlx::Expr::Expr& Find::grouping(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.grouping)
  return grouping_.Get(index);
}
inline ::Mysqlx::Expr::Expr* Find::add_grouping() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.grouping)
  return grouping_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
Find::grouping() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.grouping)
  return grouping_;
}

// optional .Mysqlx.Expr.Expr grouping_criteria = 9;
inline bool Find::has_grouping_criteria() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Find::set_has_grouping_criteria() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Find::clear_has_grouping_criteria() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::Mysqlx::Expr::Expr& Find::_internal_grouping_criteria() const {
  return *grouping_criteria_;
}
inline const ::Mysqlx::Expr::Expr& Find::grouping_criteria() const {
  const ::Mysqlx::Expr::Expr* p = grouping_criteria_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.grouping_criteria)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline ::Mysqlx::Expr::Expr* Find::release_grouping_criteria() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Find.grouping_criteria)
  clear_has_grouping_criteria();
  ::Mysqlx::Expr::Expr* temp = grouping_criteria_;
  grouping_criteria_ = NULL;
  return temp;
}
inline ::Mysqlx::Expr::Expr* Find::mutable_grouping_criteria() {
  set_has_grouping_criteria();
  if (grouping_criteria_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    grouping_criteria_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.grouping_criteria)
  return grouping_criteria_;
}
inline void Find::set_allocated_grouping_criteria(::Mysqlx::Expr::Expr* grouping_criteria) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(grouping_criteria_);
  }
  if (grouping_criteria) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      grouping_criteria = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, grouping_criteria, submessage_arena);
    }
    set_has_grouping_criteria();
  } else {
    clear_has_grouping_criteria();
  }
  grouping_criteria_ = grouping_criteria;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.grouping_criteria)
}

// optional .Mysqlx.Crud.Find.RowLock locking = 12;
inline bool Find::has_locking() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Find::set_has_locking() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Find::clear_has_locking() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Find::clear_locking() {
  locking_ = 1;
  clear_has_locking();
}
inline ::Mysqlx::Crud::Find_RowLock Find::locking() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.locking)
  return static_cast< ::Mysqlx::Crud::Find_RowLock >(locking_);
}
inline void Find::set_locking(::Mysqlx::Crud::Find_RowLock value) {
  assert(::Mysqlx::Crud::Find_RowLock_IsValid(value));
  set_has_locking();
  locking_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Find.locking)
}

// optional .Mysqlx.Crud.Find.RowLockOptions locking_options = 13;
inline bool Find::has_locking_options() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Find::set_has_locking_options() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Find::clear_has_locking_options() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Find::clear_locking_options() {
  locking_options_ = 1;
  clear_has_locking_options();
}
inline ::Mysqlx::Crud::Find_RowLockOptions Find::locking_options() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.locking_options)
  return static_cast< ::Mysqlx::Crud::Find_RowLockOptions >(locking_options_);
}
inline void Find::set_locking_options(::Mysqlx::Crud::Find_RowLockOptions value) {
  assert(::Mysqlx::Crud::Find_RowLockOptions_IsValid(value));
  set_has_locking_options();
  locking_options_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Find.locking_options)
}

// optional .Mysqlx.Crud.Limit limit = 6;
inline bool Find::has_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Find::set_has_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Find::clear_has_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Find::clear_limit() {
  if (limit_ != NULL) limit_->Clear();
  clear_has_limit();
}
inline const ::Mysqlx::Crud::Limit& Find::_internal_limit() const {
  return *limit_;
}
inline const ::Mysqlx::Crud::Limit& Find::limit() const {
  const ::Mysqlx::Crud::Limit* p = limit_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Limit*>(
      &::Mysqlx::Crud::_Limit_default_instance_);
}
inline ::Mysqlx::Crud::Limit* Find::release_limit() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Find.limit)
  clear_has_limit();
  ::Mysqlx::Crud::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline ::Mysqlx::Crud::Limit* Find::mutable_limit() {
  set_has_limit();
  if (limit_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Limit>(GetArenaNoVirtual());
    limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.limit)
  return limit_;
}
inline void Find::set_allocated_limit(::Mysqlx::Crud::Limit* limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete limit_;
  }
  if (limit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    set_has_limit();
  } else {
    clear_has_limit();
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.limit)
}

// optional .Mysqlx.Crud.LimitExpr limit_expr = 14;
inline bool Find::has_limit_expr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Find::set_has_limit_expr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Find::clear_has_limit_expr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Find::clear_limit_expr() {
  if (limit_expr_ != NULL) limit_expr_->Clear();
  clear_has_limit_expr();
}
inline const ::Mysqlx::Crud::LimitExpr& Find::_internal_limit_expr() const {
  return *limit_expr_;
}
inline const ::Mysqlx::Crud::LimitExpr& Find::limit_expr() const {
  const ::Mysqlx::Crud::LimitExpr* p = limit_expr_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.limit_expr)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Crud::LimitExpr*>(
      &::Mysqlx::Crud::_LimitExpr_default_instance_);
}
inline ::Mysqlx::Crud::LimitExpr* Find::release_limit_expr() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Find.limit_expr)
  clear_has_limit_expr();
  ::Mysqlx::Crud::LimitExpr* temp = limit_expr_;
  limit_expr_ = NULL;
  return temp;
}
inline ::Mysqlx::Crud::LimitExpr* Find::mutable_limit_expr() {
  set_has_limit_expr();
  if (limit_expr_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::LimitExpr>(GetArenaNoVirtual());
    limit_expr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.limit_expr)
  return limit_expr_;
}
inline void Find::set_allocated_limit_expr(::Mysqlx::Crud::LimitExpr* limit_expr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete limit_expr_;
  }
  if (limit_expr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      limit_expr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit_expr, submessage_arena);
    }
    set_has_limit_expr();
  } else {
    clear_has_limit_expr();
  }
  limit_expr_ = limit_expr;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.limit_expr)
}

// -------------------------------------------------------------------

// Insert_TypedRow

// repeated .Mysqlx.Expr.Expr field = 1;
inline int Insert_TypedRow::field_size() const {
  return field_.size();
}
inline ::Mysqlx::Expr::Expr* Insert_TypedRow::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.TypedRow.field)
  return field_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
Insert_TypedRow::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.TypedRow.field)
  return &field_;
}
inline const ::Mysqlx::Expr::Expr& Insert_TypedRow::field(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.TypedRow.field)
  return field_.Get(index);
}
inline ::Mysqlx::Expr::Expr* Insert_TypedRow::add_field() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.TypedRow.field)
  return field_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
Insert_TypedRow::field() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.TypedRow.field)
  return field_;
}

// -------------------------------------------------------------------

// Insert

// required .Mysqlx.Crud.Collection collection = 1;
inline bool Insert::has_collection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Insert::set_has_collection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Insert::clear_has_collection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Insert::clear_collection() {
  if (collection_ != NULL) collection_->Clear();
  clear_has_collection();
}
inline const ::Mysqlx::Crud::Collection& Insert::_internal_collection() const {
  return *collection_;
}
inline const ::Mysqlx::Crud::Collection& Insert::collection() const {
  const ::Mysqlx::Crud::Collection* p = collection_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.collection)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Collection*>(
      &::Mysqlx::Crud::_Collection_default_instance_);
}
inline ::Mysqlx::Crud::Collection* Insert::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Insert.collection)
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
inline ::Mysqlx::Crud::Collection* Insert::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Collection>(GetArenaNoVirtual());
    collection_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.collection)
  return collection_;
}
inline void Insert::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete collection_;
  }
  if (collection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      collection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, collection, submessage_arena);
    }
    set_has_collection();
  } else {
    clear_has_collection();
  }
  collection_ = collection;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Insert.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 2;
inline bool Insert::has_data_model() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Insert::set_has_data_model() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Insert::clear_has_data_model() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Insert::clear_data_model() {
  data_model_ = 1;
  clear_has_data_model();
}
inline ::Mysqlx::Crud::DataModel Insert::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.data_model)
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
inline void Insert::set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  set_has_data_model();
  data_model_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Insert.data_model)
}

// repeated .Mysqlx.Crud.Column projection = 3;
inline int Insert::projection_size() const {
  return projection_.size();
}
inline void Insert::clear_projection() {
  projection_.Clear();
}
inline ::Mysqlx::Crud::Column* Insert::mutable_projection(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.projection)
  return projection_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Column >*
Insert::mutable_projection() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.projection)
  return &projection_;
}
inline const ::Mysqlx::Crud::Column& Insert::projection(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.projection)
  return projection_.Get(index);
}
inline ::Mysqlx::Crud::Column* Insert::add_projection() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.projection)
  return projection_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Column >&
Insert::projection() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.projection)
  return projection_;
}

// repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
inline int Insert::row_size() const {
  return row_.size();
}
inline void Insert::clear_row() {
  row_.Clear();
}
inline ::Mysqlx::Crud::Insert_TypedRow* Insert::mutable_row(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.row)
  return row_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow >*
Insert::mutable_row() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.row)
  return &row_;
}
inline const ::Mysqlx::Crud::Insert_TypedRow& Insert::row(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.row)
  return row_.Get(index);
}
inline ::Mysqlx::Crud::Insert_TypedRow* Insert::add_row() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.row)
  return row_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow >&
Insert::row() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.row)
  return row_;
}

// repeated .Mysqlx.Datatypes.Scalar args = 5;
inline int Insert::args_size() const {
  return args_.size();
}
inline ::Mysqlx::Datatypes::Scalar* Insert::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.args)
  return args_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Insert::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.args)
  return &args_;
}
inline const ::Mysqlx::Datatypes::Scalar& Insert::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.args)
  return args_.Get(index);
}
inline ::Mysqlx::Datatypes::Scalar* Insert::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Insert::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.args)
  return args_;
}

// optional bool upsert = 6 [default = false];
inline bool Insert::has_upsert() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Insert::set_has_upsert() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Insert::clear_has_upsert() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Insert::clear_upsert() {
  upsert_ = false;
  clear_has_upsert();
}
inline bool Insert::upsert() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.upsert)
  return upsert_;
}
inline void Insert::set_upsert(bool value) {
  set_has_upsert();
  upsert_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Insert.upsert)
}

// -------------------------------------------------------------------

// Update

// required .Mysqlx.Crud.Collection collection = 2;
inline bool Update::has_collection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Update::set_has_collection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Update::clear_has_collection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Update::clear_collection() {
  if (collection_ != NULL) collection_->Clear();
  clear_has_collection();
}
inline const ::Mysqlx::Crud::Collection& Update::_internal_collection() const {
  return *collection_;
}
inline const ::Mysqlx::Crud::Collection& Update::collection() const {
  const ::Mysqlx::Crud::Collection* p = collection_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.collection)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Collection*>(
      &::Mysqlx::Crud::_Collection_default_instance_);
}
inline ::Mysqlx::Crud::Collection* Update::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Update.collection)
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
inline ::Mysqlx::Crud::Collection* Update::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Collection>(GetArenaNoVirtual());
    collection_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.collection)
  return collection_;
}
inline void Update::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete collection_;
  }
  if (collection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      collection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, collection, submessage_arena);
    }
    set_has_collection();
  } else {
    clear_has_collection();
  }
  collection_ = collection;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Update.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 3;
inline bool Update::has_data_model() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Update::set_has_data_model() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Update::clear_has_data_model() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Update::clear_data_model() {
  data_model_ = 1;
  clear_has_data_model();
}
inline ::Mysqlx::Crud::DataModel Update::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.data_model)
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
inline void Update::set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  set_has_data_model();
  data_model_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Update.data_model)
}

// optional .Mysqlx.Expr.Expr criteria = 4;
inline bool Update::has_criteria() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Update::set_has_criteria() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Update::clear_has_criteria() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Mysqlx::Expr::Expr& Update::_internal_criteria() const {
  return *criteria_;
}
inline const ::Mysqlx::Expr::Expr& Update::criteria() const {
  const ::Mysqlx::Expr::Expr* p = criteria_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.criteria)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline ::Mysqlx::Expr::Expr* Update::release_criteria() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Update.criteria)
  clear_has_criteria();
  ::Mysqlx::Expr::Expr* temp = criteria_;
  criteria_ = NULL;
  return temp;
}
inline ::Mysqlx::Expr::Expr* Update::mutable_criteria() {
  set_has_criteria();
  if (criteria_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    criteria_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.criteria)
  return criteria_;
}
inline void Update::set_allocated_criteria(::Mysqlx::Expr::Expr* criteria) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(criteria_);
  }
  if (criteria) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      criteria = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, criteria, submessage_arena);
    }
    set_has_criteria();
  } else {
    clear_has_criteria();
  }
  criteria_ = criteria;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Update.criteria)
}

// repeated .Mysqlx.Datatypes.Scalar args = 8;
inline int Update::args_size() const {
  return args_.size();
}
inline ::Mysqlx::Datatypes::Scalar* Update::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.args)
  return args_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Update::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Update.args)
  return &args_;
}
inline const ::Mysqlx::Datatypes::Scalar& Update::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.args)
  return args_.Get(index);
}
inline ::Mysqlx::Datatypes::Scalar* Update::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Update.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Update::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Update.args)
  return args_;
}

// repeated .Mysqlx.Crud.Order order = 6;
inline int Update::order_size() const {
  return order_.size();
}
inline void Update::clear_order() {
  order_.Clear();
}
inline ::Mysqlx::Crud::Order* Update::mutable_order(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.order)
  return order_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
Update::mutable_order() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Update.order)
  return &order_;
}
inline const ::Mysqlx::Crud::Order& Update::order(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.order)
  return order_.Get(index);
}
inline ::Mysqlx::Crud::Order* Update::add_order() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Update.order)
  return order_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
Update::order() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Update.order)
  return order_;
}

// repeated .Mysqlx.Crud.UpdateOperation operation = 7;
inline int Update::operation_size() const {
  return operation_.size();
}
inline void Update::clear_operation() {
  operation_.Clear();
}
inline ::Mysqlx::Crud::UpdateOperation* Update::mutable_operation(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.operation)
  return operation_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation >*
Update::mutable_operation() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Update.operation)
  return &operation_;
}
inline const ::Mysqlx::Crud::UpdateOperation& Update::operation(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.operation)
  return operation_.Get(index);
}
inline ::Mysqlx::Crud::UpdateOperation* Update::add_operation() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Update.operation)
  return operation_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation >&
Update::operation() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Update.operation)
  return operation_;
}

// optional .Mysqlx.Crud.Limit limit = 5;
inline bool Update::has_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Update::set_has_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Update::clear_has_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Update::clear_limit() {
  if (limit_ != NULL) limit_->Clear();
  clear_has_limit();
}
inline const ::Mysqlx::Crud::Limit& Update::_internal_limit() const {
  return *limit_;
}
inline const ::Mysqlx::Crud::Limit& Update::limit() const {
  const ::Mysqlx::Crud::Limit* p = limit_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Limit*>(
      &::Mysqlx::Crud::_Limit_default_instance_);
}
inline ::Mysqlx::Crud::Limit* Update::release_limit() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Update.limit)
  clear_has_limit();
  ::Mysqlx::Crud::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline ::Mysqlx::Crud::Limit* Update::mutable_limit() {
  set_has_limit();
  if (limit_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Limit>(GetArenaNoVirtual());
    limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.limit)
  return limit_;
}
inline void Update::set_allocated_limit(::Mysqlx::Crud::Limit* limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete limit_;
  }
  if (limit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    set_has_limit();
  } else {
    clear_has_limit();
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Update.limit)
}

// optional .Mysqlx.Crud.LimitExpr limit_expr = 9;
inline bool Update::has_limit_expr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Update::set_has_limit_expr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Update::clear_has_limit_expr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Update::clear_limit_expr() {
  if (limit_expr_ != NULL) limit_expr_->Clear();
  clear_has_limit_expr();
}
inline const ::Mysqlx::Crud::LimitExpr& Update::_internal_limit_expr() const {
  return *limit_expr_;
}
inline const ::Mysqlx::Crud::LimitExpr& Update::limit_expr() const {
  const ::Mysqlx::Crud::LimitExpr* p = limit_expr_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.limit_expr)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Crud::LimitExpr*>(
      &::Mysqlx::Crud::_LimitExpr_default_instance_);
}
inline ::Mysqlx::Crud::LimitExpr* Update::release_limit_expr() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Update.limit_expr)
  clear_has_limit_expr();
  ::Mysqlx::Crud::LimitExpr* temp = limit_expr_;
  limit_expr_ = NULL;
  return temp;
}
inline ::Mysqlx::Crud::LimitExpr* Update::mutable_limit_expr() {
  set_has_limit_expr();
  if (limit_expr_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::LimitExpr>(GetArenaNoVirtual());
    limit_expr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.limit_expr)
  return limit_expr_;
}
inline void Update::set_allocated_limit_expr(::Mysqlx::Crud::LimitExpr* limit_expr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete limit_expr_;
  }
  if (limit_expr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      limit_expr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit_expr, submessage_arena);
    }
    set_has_limit_expr();
  } else {
    clear_has_limit_expr();
  }
  limit_expr_ = limit_expr;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Update.limit_expr)
}

// -------------------------------------------------------------------

// Delete

// required .Mysqlx.Crud.Collection collection = 1;
inline bool Delete::has_collection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Delete::set_has_collection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Delete::clear_has_collection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Delete::clear_collection() {
  if (collection_ != NULL) collection_->Clear();
  clear_has_collection();
}
inline const ::Mysqlx::Crud::Collection& Delete::_internal_collection() const {
  return *collection_;
}
inline const ::Mysqlx::Crud::Collection& Delete::collection() const {
  const ::Mysqlx::Crud::Collection* p = collection_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.collection)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Collection*>(
      &::Mysqlx::Crud::_Collection_default_instance_);
}
inline ::Mysqlx::Crud::Collection* Delete::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Delete.collection)
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
inline ::Mysqlx::Crud::Collection* Delete::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Collection>(GetArenaNoVirtual());
    collection_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.collection)
  return collection_;
}
inline void Delete::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete collection_;
  }
  if (collection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      collection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, collection, submessage_arena);
    }
    set_has_collection();
  } else {
    clear_has_collection();
  }
  collection_ = collection;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Delete.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 2;
inline bool Delete::has_data_model() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Delete::set_has_data_model() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Delete::clear_has_data_model() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Delete::clear_data_model() {
  data_model_ = 1;
  clear_has_data_model();
}
inline ::Mysqlx::Crud::DataModel Delete::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.data_model)
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
inline void Delete::set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  set_has_data_model();
  data_model_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Delete.data_model)
}

// optional .Mysqlx.Expr.Expr criteria = 3;
inline bool Delete::has_criteria() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Delete::set_has_criteria() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Delete::clear_has_criteria() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Mysqlx::Expr::Expr& Delete::_internal_criteria() const {
  return *criteria_;
}
inline const ::Mysqlx::Expr::Expr& Delete::criteria() const {
  const ::Mysqlx::Expr::Expr* p = criteria_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.criteria)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline ::Mysqlx::Expr::Expr* Delete::release_criteria() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Delete.criteria)
  clear_has_criteria();
  ::Mysqlx::Expr::Expr* temp = criteria_;
  criteria_ = NULL;
  return temp;
}
inline ::Mysqlx::Expr::Expr* Delete::mutable_criteria() {
  set_has_criteria();
  if (criteria_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    criteria_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.criteria)
  return criteria_;
}
inline void Delete::set_allocated_criteria(::Mysqlx::Expr::Expr* criteria) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(criteria_);
  }
  if (criteria) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      criteria = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, criteria, submessage_arena);
    }
    set_has_criteria();
  } else {
    clear_has_criteria();
  }
  criteria_ = criteria;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Delete.criteria)
}

// repeated .Mysqlx.Datatypes.Scalar args = 6;
inline int Delete::args_size() const {
  return args_.size();
}
inline ::Mysqlx::Datatypes::Scalar* Delete::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.args)
  return args_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Delete::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Delete.args)
  return &args_;
}
inline const ::Mysqlx::Datatypes::Scalar& Delete::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.args)
  return args_.Get(index);
}
inline ::Mysqlx::Datatypes::Scalar* Delete::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Delete.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Delete::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Delete.args)
  return args_;
}

// repeated .Mysqlx.Crud.Order order = 5;
inline int Delete::order_size() const {
  return order_.size();
}
inline void Delete::clear_order() {
  order_.Clear();
}
inline ::Mysqlx::Crud::Order* Delete::mutable_order(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.order)
  return order_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
Delete::mutable_order() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Delete.order)
  return &order_;
}
inline const ::Mysqlx::Crud::Order& Delete::order(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.order)
  return order_.Get(index);
}
inline ::Mysqlx::Crud::Order* Delete::add_order() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Delete.order)
  return order_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
Delete::order() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Delete.order)
  return order_;
}

// optional .Mysqlx.Crud.Limit limit = 4;
inline bool Delete::has_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Delete::set_has_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Delete::clear_has_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Delete::clear_limit() {
  if (limit_ != NULL) limit_->Clear();
  clear_has_limit();
}
inline const ::Mysqlx::Crud::Limit& Delete::_internal_limit() const {
  return *limit_;
}
inline const ::Mysqlx::Crud::Limit& Delete::limit() const {
  const ::Mysqlx::Crud::Limit* p = limit_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Limit*>(
      &::Mysqlx::Crud::_Limit_default_instance_);
}
inline ::Mysqlx::Crud::Limit* Delete::release_limit() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Delete.limit)
  clear_has_limit();
  ::Mysqlx::Crud::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline ::Mysqlx::Crud::Limit* Delete::mutable_limit() {
  set_has_limit();
  if (limit_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Limit>(GetArenaNoVirtual());
    limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.limit)
  return limit_;
}
inline void Delete::set_allocated_limit(::Mysqlx::Crud::Limit* limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete limit_;
  }
  if (limit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    set_has_limit();
  } else {
    clear_has_limit();
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Delete.limit)
}

// optional .Mysqlx.Crud.LimitExpr limit_expr = 7;
inline bool Delete::has_limit_expr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Delete::set_has_limit_expr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Delete::clear_has_limit_expr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Delete::clear_limit_expr() {
  if (limit_expr_ != NULL) limit_expr_->Clear();
  clear_has_limit_expr();
}
inline const ::Mysqlx::Crud::LimitExpr& Delete::_internal_limit_expr() const {
  return *limit_expr_;
}
inline const ::Mysqlx::Crud::LimitExpr& Delete::limit_expr() const {
  const ::Mysqlx::Crud::LimitExpr* p = limit_expr_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.limit_expr)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Crud::LimitExpr*>(
      &::Mysqlx::Crud::_LimitExpr_default_instance_);
}
inline ::Mysqlx::Crud::LimitExpr* Delete::release_limit_expr() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Delete.limit_expr)
  clear_has_limit_expr();
  ::Mysqlx::Crud::LimitExpr* temp = limit_expr_;
  limit_expr_ = NULL;
  return temp;
}
inline ::Mysqlx::Crud::LimitExpr* Delete::mutable_limit_expr() {
  set_has_limit_expr();
  if (limit_expr_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::LimitExpr>(GetArenaNoVirtual());
    limit_expr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.limit_expr)
  return limit_expr_;
}
inline void Delete::set_allocated_limit_expr(::Mysqlx::Crud::LimitExpr* limit_expr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete limit_expr_;
  }
  if (limit_expr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      limit_expr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit_expr, submessage_arena);
    }
    set_has_limit_expr();
  } else {
    clear_has_limit_expr();
  }
  limit_expr_ = limit_expr;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Delete.limit_expr)
}

// -------------------------------------------------------------------

// CreateView

// required .Mysqlx.Crud.Collection collection = 1;
inline bool CreateView::has_collection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateView::set_has_collection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateView::clear_has_collection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateView::clear_collection() {
  if (collection_ != NULL) collection_->Clear();
  clear_has_collection();
}
inline const ::Mysqlx::Crud::Collection& CreateView::_internal_collection() const {
  return *collection_;
}
inline const ::Mysqlx::Crud::Collection& CreateView::collection() const {
  const ::Mysqlx::Crud::Collection* p = collection_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.CreateView.collection)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Collection*>(
      &::Mysqlx::Crud::_Collection_default_instance_);
}
inline ::Mysqlx::Crud::Collection* CreateView::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.CreateView.collection)
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
inline ::Mysqlx::Crud::Collection* CreateView::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Collection>(GetArenaNoVirtual());
    collection_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.CreateView.collection)
  return collection_;
}
inline void CreateView::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete collection_;
  }
  if (collection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      collection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, collection, submessage_arena);
    }
    set_has_collection();
  } else {
    clear_has_collection();
  }
  collection_ = collection;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.CreateView.collection)
}

// optional string definer = 2;
inline bool CreateView::has_definer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateView::set_has_definer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateView::clear_has_definer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateView::clear_definer() {
  definer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_definer();
}
inline const ::std::string& CreateView::definer() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.CreateView.definer)
  return definer_.GetNoArena();
}
inline void CreateView::set_definer(const ::std::string& value) {
  set_has_definer();
  definer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.CreateView.definer)
}
#if LANG_CXX11
inline void CreateView::set_definer(::std::string&& value) {
  set_has_definer();
  definer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.CreateView.definer)
}
#endif
inline void CreateView::set_definer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_definer();
  definer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.CreateView.definer)
}
inline void CreateView::set_definer(const char* value, size_t size) {
  set_has_definer();
  definer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.CreateView.definer)
}
inline ::std::string* CreateView::mutable_definer() {
  set_has_definer();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.CreateView.definer)
  return definer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateView::release_definer() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.CreateView.definer)
  if (!has_definer()) {
    return NULL;
  }
  clear_has_definer();
  return definer_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateView::set_allocated_definer(::std::string* definer) {
  if (definer != NULL) {
    set_has_definer();
  } else {
    clear_has_definer();
  }
  definer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), definer);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.CreateView.definer)
}

// optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3 [default = UNDEFINED];
inline bool CreateView::has_algorithm() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreateView::set_has_algorithm() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreateView::clear_has_algorithm() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreateView::clear_algorithm() {
  algorithm_ = 1;
  clear_has_algorithm();
}
inline ::Mysqlx::Crud::ViewAlgorithm CreateView::algorithm() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.CreateView.algorithm)
  return static_cast< ::Mysqlx::Crud::ViewAlgorithm >(algorithm_);
}
inline void CreateView::set_algorithm(::Mysqlx::Crud::ViewAlgorithm value) {
  assert(::Mysqlx::Crud::ViewAlgorithm_IsValid(value));
  set_has_algorithm();
  algorithm_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.CreateView.algorithm)
}

// optional .Mysqlx.Crud.ViewSqlSecurity security = 4 [default = DEFINER];
inline bool CreateView::has_security() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CreateView::set_has_security() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CreateView::clear_has_security() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CreateView::clear_security() {
  security_ = 2;
  clear_has_security();
}
inline ::Mysqlx::Crud::ViewSqlSecurity CreateView::security() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.CreateView.security)
  return static_cast< ::Mysqlx::Crud::ViewSqlSecurity >(security_);
}
inline void CreateView::set_security(::Mysqlx::Crud::ViewSqlSecurity value) {
  assert(::Mysqlx::Crud::ViewSqlSecurity_IsValid(value));
  set_has_security();
  security_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.CreateView.security)
}

// optional .Mysqlx.Crud.ViewCheckOption check = 5;
inline bool CreateView::has_check() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateView::set_has_check() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateView::clear_has_check() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateView::clear_check() {
  check_ = 1;
  clear_has_check();
}
inline ::Mysqlx::Crud::ViewCheckOption CreateView::check() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.CreateView.check)
  return static_cast< ::Mysqlx::Crud::ViewCheckOption >(check_);
}
inline void CreateView::set_check(::Mysqlx::Crud::ViewCheckOption value) {
  assert(::Mysqlx::Crud::ViewCheckOption_IsValid(value));
  set_has_check();
  check_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.CreateView.check)
}

// repeated string column = 6;
inline int CreateView::column_size() const {
  return column_.size();
}
inline void CreateView::clear_column() {
  column_.Clear();
}
inline const ::std::string& CreateView::column(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.CreateView.column)
  return column_.Get(index);
}
inline ::std::string* CreateView::mutable_column(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.CreateView.column)
  return column_.Mutable(index);
}
inline void CreateView::set_column(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.CreateView.column)
  column_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CreateView::set_column(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.CreateView.column)
  column_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CreateView::set_column(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  column_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.CreateView.column)
}
inline void CreateView::set_column(int index, const char* value, size_t size) {
  column_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.CreateView.column)
}
inline ::std::string* CreateView::add_column() {
  // @@protoc_insertion_point(field_add_mutable:Mysqlx.Crud.CreateView.column)
  return column_.Add();
}
inline void CreateView::add_column(const ::std::string& value) {
  column_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.CreateView.column)
}
#if LANG_CXX11
inline void CreateView::add_column(::std::string&& value) {
  column_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.CreateView.column)
}
#endif
inline void CreateView::add_column(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  column_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Mysqlx.Crud.CreateView.column)
}
inline void CreateView::add_column(const char* value, size_t size) {
  column_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Mysqlx.Crud.CreateView.column)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CreateView::column() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.CreateView.column)
  return column_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CreateView::mutable_column() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.CreateView.column)
  return &column_;
}

// required .Mysqlx.Crud.Find stmt = 7;
inline bool CreateView::has_stmt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateView::set_has_stmt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateView::clear_has_stmt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateView::clear_stmt() {
  if (stmt_ != NULL) stmt_->Clear();
  clear_has_stmt();
}
inline const ::Mysqlx::Crud::Find& CreateView::_internal_stmt() const {
  return *stmt_;
}
inline const ::Mysqlx::Crud::Find& CreateView::stmt() const {
  const ::Mysqlx::Crud::Find* p = stmt_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.CreateView.stmt)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Find*>(
      &::Mysqlx::Crud::_Find_default_instance_);
}
inline ::Mysqlx::Crud::Find* CreateView::release_stmt() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.CreateView.stmt)
  clear_has_stmt();
  ::Mysqlx::Crud::Find* temp = stmt_;
  stmt_ = NULL;
  return temp;
}
inline ::Mysqlx::Crud::Find* CreateView::mutable_stmt() {
  set_has_stmt();
  if (stmt_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Find>(GetArenaNoVirtual());
    stmt_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.CreateView.stmt)
  return stmt_;
}
inline void CreateView::set_allocated_stmt(::Mysqlx::Crud::Find* stmt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stmt_;
  }
  if (stmt) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stmt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stmt, submessage_arena);
    }
    set_has_stmt();
  } else {
    clear_has_stmt();
  }
  stmt_ = stmt;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.CreateView.stmt)
}

// optional bool replace_existing = 8 [default = false];
inline bool CreateView::has_replace_existing() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateView::set_has_replace_existing() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateView::clear_has_replace_existing() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateView::clear_replace_existing() {
  replace_existing_ = false;
  clear_has_replace_existing();
}
inline bool CreateView::replace_existing() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.CreateView.replace_existing)
  return replace_existing_;
}
inline void CreateView::set_replace_existing(bool value) {
  set_has_replace_existing();
  replace_existing_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.CreateView.replace_existing)
}

// -------------------------------------------------------------------

// ModifyView

// required .Mysqlx.Crud.Collection collection = 1;
inline bool ModifyView::has_collection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyView::set_has_collection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyView::clear_has_collection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyView::clear_collection() {
  if (collection_ != NULL) collection_->Clear();
  clear_has_collection();
}
inline const ::Mysqlx::Crud::Collection& ModifyView::_internal_collection() const {
  return *collection_;
}
inline const ::Mysqlx::Crud::Collection& ModifyView::collection() const {
  const ::Mysqlx::Crud::Collection* p = collection_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.ModifyView.collection)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Collection*>(
      &::Mysqlx::Crud::_Collection_default_instance_);
}
inline ::Mysqlx::Crud::Collection* ModifyView::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.ModifyView.collection)
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
inline ::Mysqlx::Crud::Collection* ModifyView::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Collection>(GetArenaNoVirtual());
    collection_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.ModifyView.collection)
  return collection_;
}
inline void ModifyView::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete collection_;
  }
  if (collection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      collection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, collection, submessage_arena);
    }
    set_has_collection();
  } else {
    clear_has_collection();
  }
  collection_ = collection;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.ModifyView.collection)
}

// optional string definer = 2;
inline bool ModifyView::has_definer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyView::set_has_definer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyView::clear_has_definer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyView::clear_definer() {
  definer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_definer();
}
inline const ::std::string& ModifyView::definer() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.ModifyView.definer)
  return definer_.GetNoArena();
}
inline void ModifyView::set_definer(const ::std::string& value) {
  set_has_definer();
  definer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.ModifyView.definer)
}
#if LANG_CXX11
inline void ModifyView::set_definer(::std::string&& value) {
  set_has_definer();
  definer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.ModifyView.definer)
}
#endif
inline void ModifyView::set_definer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_definer();
  definer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.ModifyView.definer)
}
inline void ModifyView::set_definer(const char* value, size_t size) {
  set_has_definer();
  definer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.ModifyView.definer)
}
inline ::std::string* ModifyView::mutable_definer() {
  set_has_definer();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.ModifyView.definer)
  return definer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModifyView::release_definer() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.ModifyView.definer)
  if (!has_definer()) {
    return NULL;
  }
  clear_has_definer();
  return definer_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModifyView::set_allocated_definer(::std::string* definer) {
  if (definer != NULL) {
    set_has_definer();
  } else {
    clear_has_definer();
  }
  definer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), definer);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.ModifyView.definer)
}

// optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3;
inline bool ModifyView::has_algorithm() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModifyView::set_has_algorithm() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModifyView::clear_has_algorithm() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModifyView::clear_algorithm() {
  algorithm_ = 1;
  clear_has_algorithm();
}
inline ::Mysqlx::Crud::ViewAlgorithm ModifyView::algorithm() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.ModifyView.algorithm)
  return static_cast< ::Mysqlx::Crud::ViewAlgorithm >(algorithm_);
}
inline void ModifyView::set_algorithm(::Mysqlx::Crud::ViewAlgorithm value) {
  assert(::Mysqlx::Crud::ViewAlgorithm_IsValid(value));
  set_has_algorithm();
  algorithm_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.ModifyView.algorithm)
}

// optional .Mysqlx.Crud.ViewSqlSecurity security = 4;
inline bool ModifyView::has_security() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ModifyView::set_has_security() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ModifyView::clear_has_security() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ModifyView::clear_security() {
  security_ = 1;
  clear_has_security();
}
inline ::Mysqlx::Crud::ViewSqlSecurity ModifyView::security() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.ModifyView.security)
  return static_cast< ::Mysqlx::Crud::ViewSqlSecurity >(security_);
}
inline void ModifyView::set_security(::Mysqlx::Crud::ViewSqlSecurity value) {
  assert(::Mysqlx::Crud::ViewSqlSecurity_IsValid(value));
  set_has_security();
  security_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.ModifyView.security)
}

// optional .Mysqlx.Crud.ViewCheckOption check = 5;
inline bool ModifyView::has_check() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModifyView::set_has_check() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModifyView::clear_has_check() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModifyView::clear_check() {
  check_ = 1;
  clear_has_check();
}
inline ::Mysqlx::Crud::ViewCheckOption ModifyView::check() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.ModifyView.check)
  return static_cast< ::Mysqlx::Crud::ViewCheckOption >(check_);
}
inline void ModifyView::set_check(::Mysqlx::Crud::ViewCheckOption value) {
  assert(::Mysqlx::Crud::ViewCheckOption_IsValid(value));
  set_has_check();
  check_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.ModifyView.check)
}

// repeated string column = 6;
inline int ModifyView::column_size() const {
  return column_.size();
}
inline void ModifyView::clear_column() {
  column_.Clear();
}
inline const ::std::string& ModifyView::column(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.ModifyView.column)
  return column_.Get(index);
}
inline ::std::string* ModifyView::mutable_column(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.ModifyView.column)
  return column_.Mutable(index);
}
inline void ModifyView::set_column(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.ModifyView.column)
  column_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ModifyView::set_column(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.ModifyView.column)
  column_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ModifyView::set_column(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  column_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.ModifyView.column)
}
inline void ModifyView::set_column(int index, const char* value, size_t size) {
  column_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.ModifyView.column)
}
inline ::std::string* ModifyView::add_column() {
  // @@protoc_insertion_point(field_add_mutable:Mysqlx.Crud.ModifyView.column)
  return column_.Add();
}
inline void ModifyView::add_column(const ::std::string& value) {
  column_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.ModifyView.column)
}
#if LANG_CXX11
inline void ModifyView::add_column(::std::string&& value) {
  column_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.ModifyView.column)
}
#endif
inline void ModifyView::add_column(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  column_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Mysqlx.Crud.ModifyView.column)
}
inline void ModifyView::add_column(const char* value, size_t size) {
  column_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Mysqlx.Crud.ModifyView.column)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModifyView::column() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.ModifyView.column)
  return column_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ModifyView::mutable_column() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.ModifyView.column)
  return &column_;
}

// optional .Mysqlx.Crud.Find stmt = 7;
inline bool ModifyView::has_stmt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyView::set_has_stmt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyView::clear_has_stmt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyView::clear_stmt() {
  if (stmt_ != NULL) stmt_->Clear();
  clear_has_stmt();
}
inline const ::Mysqlx::Crud::Find& ModifyView::_internal_stmt() const {
  return *stmt_;
}
inline const ::Mysqlx::Crud::Find& ModifyView::stmt() const {
  const ::Mysqlx::Crud::Find* p = stmt_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.ModifyView.stmt)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Find*>(
      &::Mysqlx::Crud::_Find_default_instance_);
}
inline ::Mysqlx::Crud::Find* ModifyView::release_stmt() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.ModifyView.stmt)
  clear_has_stmt();
  ::Mysqlx::Crud::Find* temp = stmt_;
  stmt_ = NULL;
  return temp;
}
inline ::Mysqlx::Crud::Find* ModifyView::mutable_stmt() {
  set_has_stmt();
  if (stmt_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Find>(GetArenaNoVirtual());
    stmt_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.ModifyView.stmt)
  return stmt_;
}
inline void ModifyView::set_allocated_stmt(::Mysqlx::Crud::Find* stmt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stmt_;
  }
  if (stmt) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stmt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stmt, submessage_arena);
    }
    set_has_stmt();
  } else {
    clear_has_stmt();
  }
  stmt_ = stmt;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.ModifyView.stmt)
}

// -------------------------------------------------------------------

// DropView

// required .Mysqlx.Crud.Collection collection = 1;
inline bool DropView::has_collection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DropView::set_has_collection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DropView::clear_has_collection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DropView::clear_collection() {
  if (collection_ != NULL) collection_->Clear();
  clear_has_collection();
}
inline const ::Mysqlx::Crud::Collection& DropView::_internal_collection() const {
  return *collection_;
}
inline const ::Mysqlx::Crud::Collection& DropView::collection() const {
  const ::Mysqlx::Crud::Collection* p = collection_;
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.DropView.collection)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Collection*>(
      &::Mysqlx::Crud::_Collection_default_instance_);
}
inline ::Mysqlx::Crud::Collection* DropView::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.DropView.collection)
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
inline ::Mysqlx::Crud::Collection* DropView::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Collection>(GetArenaNoVirtual());
    collection_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.DropView.collection)
  return collection_;
}
inline void DropView::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete collection_;
  }
  if (collection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      collection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, collection, submessage_arena);
    }
    set_has_collection();
  } else {
    clear_has_collection();
  }
  collection_ = collection;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.DropView.collection)
}

// optional bool if_exists = 2 [default = false];
inline bool DropView::has_if_exists() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DropView::set_has_if_exists() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DropView::clear_has_if_exists() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DropView::clear_if_exists() {
  if_exists_ = false;
  clear_has_if_exists();
}
inline bool DropView::if_exists() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.DropView.if_exists)
  return if_exists_;
}
inline void DropView::set_if_exists(bool value) {
  set_has_if_exists();
  if_exists_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.DropView.if_exists)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Crud
}  // namespace Mysqlx

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Mysqlx::Crud::Order_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mysqlx::Crud::Order_Direction>() {
  return ::Mysqlx::Crud::Order_Direction_descriptor();
}
template <> struct is_proto_enum< ::Mysqlx::Crud::UpdateOperation_UpdateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mysqlx::Crud::UpdateOperation_UpdateType>() {
  return ::Mysqlx::Crud::UpdateOperation_UpdateType_descriptor();
}
template <> struct is_proto_enum< ::Mysqlx::Crud::Find_RowLock> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mysqlx::Crud::Find_RowLock>() {
  return ::Mysqlx::Crud::Find_RowLock_descriptor();
}
template <> struct is_proto_enum< ::Mysqlx::Crud::Find_RowLockOptions> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mysqlx::Crud::Find_RowLockOptions>() {
  return ::Mysqlx::Crud::Find_RowLockOptions_descriptor();
}
template <> struct is_proto_enum< ::Mysqlx::Crud::DataModel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mysqlx::Crud::DataModel>() {
  return ::Mysqlx::Crud::DataModel_descriptor();
}
template <> struct is_proto_enum< ::Mysqlx::Crud::ViewAlgorithm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mysqlx::Crud::ViewAlgorithm>() {
  return ::Mysqlx::Crud::ViewAlgorithm_descriptor();
}
template <> struct is_proto_enum< ::Mysqlx::Crud::ViewSqlSecurity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mysqlx::Crud::ViewSqlSecurity>() {
  return ::Mysqlx::Crud::ViewSqlSecurity_descriptor();
}
template <> struct is_proto_enum< ::Mysqlx::Crud::ViewCheckOption> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mysqlx::Crud::ViewCheckOption>() {
  return ::Mysqlx::Crud::ViewCheckOption_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_mysqlx_5fcrud_2eproto
