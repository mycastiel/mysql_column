// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mysqlx_crud.proto

#include "mysqlx_crud.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)

namespace protobuf_mysqlx_5fcrud_2eproto {
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Collection;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Limit;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_Column;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_Insert_TypedRow;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_LimitExpr;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_Order;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_Projection;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_UpdateOperation;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fcrud_2eproto ::google::protobuf::internal::SCCInfo<7> scc_info_Find;
}  // namespace protobuf_mysqlx_5fcrud_2eproto
namespace protobuf_mysqlx_5fdatatypes_2eproto {
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fdatatypes_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_Scalar;
}  // namespace protobuf_mysqlx_5fdatatypes_2eproto
namespace protobuf_mysqlx_5fexpr_2eproto {
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fexpr_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_DocumentPathItem;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fexpr_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_ColumnIdentifier;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fexpr_2eproto ::google::protobuf::internal::SCCInfo<3> scc_info_Array;
}  // namespace protobuf_mysqlx_5fexpr_2eproto
namespace Mysqlx {
namespace Crud {
class ColumnDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Column>
      _instance;
} _Column_default_instance_;
class ProjectionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Projection>
      _instance;
} _Projection_default_instance_;
class CollectionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Collection>
      _instance;
} _Collection_default_instance_;
class LimitDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Limit>
      _instance;
} _Limit_default_instance_;
class LimitExprDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<LimitExpr>
      _instance;
} _LimitExpr_default_instance_;
class OrderDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Order>
      _instance;
} _Order_default_instance_;
class UpdateOperationDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<UpdateOperation>
      _instance;
} _UpdateOperation_default_instance_;
class FindDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Find>
      _instance;
} _Find_default_instance_;
class Insert_TypedRowDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Insert_TypedRow>
      _instance;
} _Insert_TypedRow_default_instance_;
class InsertDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Insert>
      _instance;
} _Insert_default_instance_;
class UpdateDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Update>
      _instance;
} _Update_default_instance_;
class DeleteDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Delete>
      _instance;
} _Delete_default_instance_;
class CreateViewDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CreateView>
      _instance;
} _CreateView_default_instance_;
class ModifyViewDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ModifyView>
      _instance;
} _ModifyView_default_instance_;
class DropViewDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<DropView>
      _instance;
} _DropView_default_instance_;
}  // namespace Crud
}  // namespace Mysqlx
namespace protobuf_mysqlx_5fcrud_2eproto {
static void InitDefaultsColumn() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Column_default_instance_;
    new (ptr) ::Mysqlx::Crud::Column();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Column::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Column =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsColumn}, {
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_DocumentPathItem.base,}};

static void InitDefaultsProjection() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Projection_default_instance_;
    new (ptr) ::Mysqlx::Crud::Projection();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Projection::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Projection =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsProjection}, {
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_Array.base,}};

static void InitDefaultsCollection() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Collection_default_instance_;
    new (ptr) ::Mysqlx::Crud::Collection();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Collection::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Collection =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsCollection}, {}};

static void InitDefaultsLimit() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Limit_default_instance_;
    new (ptr) ::Mysqlx::Crud::Limit();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Limit::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Limit =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsLimit}, {}};

static void InitDefaultsLimitExpr() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_LimitExpr_default_instance_;
    new (ptr) ::Mysqlx::Crud::LimitExpr();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::LimitExpr::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_LimitExpr =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsLimitExpr}, {
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_Array.base,}};

static void InitDefaultsOrder() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Order_default_instance_;
    new (ptr) ::Mysqlx::Crud::Order();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Order::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Order =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsOrder}, {
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_Array.base,}};

static void InitDefaultsUpdateOperation() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_UpdateOperation_default_instance_;
    new (ptr) ::Mysqlx::Crud::UpdateOperation();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::UpdateOperation::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_UpdateOperation =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsUpdateOperation}, {
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_ColumnIdentifier.base,
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_Array.base,}};

static void InitDefaultsFind() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Find_default_instance_;
    new (ptr) ::Mysqlx::Crud::Find();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Find::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<7> scc_info_Find =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 7, InitDefaultsFind}, {
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Collection.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Projection.base,
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_Array.base,
      &protobuf_mysqlx_5fdatatypes_2eproto::scc_info_Scalar.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Order.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Limit.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_LimitExpr.base,}};

static void InitDefaultsInsert_TypedRow() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Insert_TypedRow_default_instance_;
    new (ptr) ::Mysqlx::Crud::Insert_TypedRow();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Insert_TypedRow::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Insert_TypedRow =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsInsert_TypedRow}, {
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_Array.base,}};

static void InitDefaultsInsert() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Insert_default_instance_;
    new (ptr) ::Mysqlx::Crud::Insert();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Insert::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<4> scc_info_Insert =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 4, InitDefaultsInsert}, {
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Collection.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Column.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Insert_TypedRow.base,
      &protobuf_mysqlx_5fdatatypes_2eproto::scc_info_Scalar.base,}};

static void InitDefaultsUpdate() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Update_default_instance_;
    new (ptr) ::Mysqlx::Crud::Update();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Update::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<7> scc_info_Update =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 7, InitDefaultsUpdate}, {
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Collection.base,
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_Array.base,
      &protobuf_mysqlx_5fdatatypes_2eproto::scc_info_Scalar.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Order.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_UpdateOperation.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Limit.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_LimitExpr.base,}};

static void InitDefaultsDelete() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Delete_default_instance_;
    new (ptr) ::Mysqlx::Crud::Delete();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Delete::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<6> scc_info_Delete =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 6, InitDefaultsDelete}, {
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Collection.base,
      &protobuf_mysqlx_5fexpr_2eproto::scc_info_Array.base,
      &protobuf_mysqlx_5fdatatypes_2eproto::scc_info_Scalar.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Order.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Limit.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_LimitExpr.base,}};

static void InitDefaultsCreateView() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_CreateView_default_instance_;
    new (ptr) ::Mysqlx::Crud::CreateView();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::CreateView::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_CreateView =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsCreateView}, {
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Collection.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Find.base,}};

static void InitDefaultsModifyView() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_ModifyView_default_instance_;
    new (ptr) ::Mysqlx::Crud::ModifyView();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::ModifyView::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_ModifyView =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsModifyView}, {
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Collection.base,
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Find.base,}};

static void InitDefaultsDropView() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_DropView_default_instance_;
    new (ptr) ::Mysqlx::Crud::DropView();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::DropView::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_DropView =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsDropView}, {
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Collection.base,}};

void InitDefaults() {
  ::google::protobuf::internal::InitSCC(&scc_info_Column.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Projection.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Collection.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Limit.base);
  ::google::protobuf::internal::InitSCC(&scc_info_LimitExpr.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Order.base);
  ::google::protobuf::internal::InitSCC(&scc_info_UpdateOperation.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Find.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Insert_TypedRow.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Insert.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Update.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Delete.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CreateView.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ModifyView.base);
  ::google::protobuf::internal::InitSCC(&scc_info_DropView.base);
}

}  // namespace protobuf_mysqlx_5fcrud_2eproto
namespace Mysqlx {
namespace Crud {
bool Order_Direction_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Order_Direction Order::ASC;
const Order_Direction Order::DESC;
const Order_Direction Order::Direction_MIN;
const Order_Direction Order::Direction_MAX;
const int Order::Direction_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool UpdateOperation_UpdateType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const UpdateOperation_UpdateType UpdateOperation::SET;
const UpdateOperation_UpdateType UpdateOperation::ITEM_REMOVE;
const UpdateOperation_UpdateType UpdateOperation::ITEM_SET;
const UpdateOperation_UpdateType UpdateOperation::ITEM_REPLACE;
const UpdateOperation_UpdateType UpdateOperation::ITEM_MERGE;
const UpdateOperation_UpdateType UpdateOperation::ARRAY_INSERT;
const UpdateOperation_UpdateType UpdateOperation::ARRAY_APPEND;
const UpdateOperation_UpdateType UpdateOperation::MERGE_PATCH;
const UpdateOperation_UpdateType UpdateOperation::UpdateType_MIN;
const UpdateOperation_UpdateType UpdateOperation::UpdateType_MAX;
const int UpdateOperation::UpdateType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool Find_RowLock_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Find_RowLock Find::SHARED_LOCK;
const Find_RowLock Find::EXCLUSIVE_LOCK;
const Find_RowLock Find::RowLock_MIN;
const Find_RowLock Find::RowLock_MAX;
const int Find::RowLock_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool Find_RowLockOptions_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Find_RowLockOptions Find::NOWAIT;
const Find_RowLockOptions Find::SKIP_LOCKED;
const Find_RowLockOptions Find::RowLockOptions_MIN;
const Find_RowLockOptions Find::RowLockOptions_MAX;
const int Find::RowLockOptions_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool DataModel_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool ViewAlgorithm_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

bool ViewSqlSecurity_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool ViewCheckOption_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void Column::InitAsDefaultInstance() {
}
void Column::clear_document_path() {
  document_path_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Column::kNameFieldNumber;
const int Column::kAliasFieldNumber;
const int Column::kDocumentPathFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Column::Column()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Column.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Column)
}
Column::Column(const Column& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      document_path_(from.document_path_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  alias_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_alias()) {
    alias_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.alias_);
  }
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Column)
}

void Column::SharedCtor() {
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  alias_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Column::~Column() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Column)
  SharedDtor();
}

void Column::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  alias_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Column::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Column& Column::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Column.base);
  return *internal_default_instance();
}


void Column::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Column)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  document_path_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      alias_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Column::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Column)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string alias = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_alias()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_document_path()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Column)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Column)
  return false;
#undef DO_
}

void Column::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Column)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string alias = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->alias(), output);
  }

  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->document_path_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3,
      this->document_path(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Column)
}

size_t Column::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Column)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->document_path_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->document_path(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 3u) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string alias = 2;
    if (has_alias()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->alias());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Column::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Column*>(&from));
}

void Column::MergeFrom(const Column& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Column)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  document_path_.MergeFrom(from.document_path_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_alias();
      alias_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.alias_);
    }
  }
}

void Column::CopyFrom(const Column& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Column)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Column::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->document_path())) return false;
  return true;
}

void Column::Swap(Column* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Column::InternalSwap(Column* other) {
  using std::swap;
  CastToBase(&document_path_)->InternalSwap(CastToBase(&other->document_path_));
  name_.Swap(&other->name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  alias_.Swap(&other->alias_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string Column::GetTypeName() const {
  return "Mysqlx.Crud.Column";
}


// ===================================================================

void Projection::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_Projection_default_instance_._instance.get_mutable()->source_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
}
void Projection::clear_source() {
  if (source_ != NULL) source_->Clear();
  clear_has_source();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Projection::kSourceFieldNumber;
const int Projection::kAliasFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Projection::Projection()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Projection.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Projection)
}
Projection::Projection(const Projection& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  alias_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_alias()) {
    alias_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.alias_);
  }
  if (from.has_source()) {
    source_ = new ::Mysqlx::Expr::Expr(*from.source_);
  } else {
    source_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Projection)
}

void Projection::SharedCtor() {
  alias_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_ = NULL;
}

Projection::~Projection() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Projection)
  SharedDtor();
}

void Projection::SharedDtor() {
  alias_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete source_;
}

void Projection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Projection& Projection::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Projection.base);
  return *internal_default_instance();
}


void Projection::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Projection)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      alias_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(source_ != NULL);
      source_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Projection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Projection)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.Expr source = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string alias = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_alias()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Projection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Projection)
  return false;
#undef DO_
}

void Projection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Projection)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Expr.Expr source = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->_internal_source(), output);
  }

  // optional string alias = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->alias(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Projection)
}

size_t Projection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Projection)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required .Mysqlx.Expr.Expr source = 1;
  if (has_source()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *source_);
  }
  // optional string alias = 2;
  if (has_alias()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->alias());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Projection::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Projection*>(&from));
}

void Projection::MergeFrom(const Projection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Projection)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_alias();
      alias_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.alias_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_source()->::Mysqlx::Expr::Expr::MergeFrom(from.source());
    }
  }
}

void Projection::CopyFrom(const Projection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Projection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Projection::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (has_source()) {
    if (!this->source_->IsInitialized()) return false;
  }
  return true;
}

void Projection::Swap(Projection* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Projection::InternalSwap(Projection* other) {
  using std::swap;
  alias_.Swap(&other->alias_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(source_, other->source_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string Projection::GetTypeName() const {
  return "Mysqlx.Crud.Projection";
}


// ===================================================================

void Collection::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Collection::kNameFieldNumber;
const int Collection::kSchemaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Collection::Collection()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Collection.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Collection)
}
Collection::Collection(const Collection& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  schema_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_schema()) {
    schema_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.schema_);
  }
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Collection)
}

void Collection::SharedCtor() {
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  schema_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Collection::~Collection() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Collection)
  SharedDtor();
}

void Collection::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  schema_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Collection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Collection& Collection::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Collection.base);
  return *internal_default_instance();
}


void Collection::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Collection)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      schema_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Collection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Collection)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string schema = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_schema()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Collection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Collection)
  return false;
#undef DO_
}

void Collection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Collection)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string schema = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->schema(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Collection)
}

size_t Collection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Collection)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required string name = 1;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }
  // optional string schema = 2;
  if (has_schema()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->schema());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Collection::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Collection*>(&from));
}

void Collection::MergeFrom(const Collection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Collection)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_schema();
      schema_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.schema_);
    }
  }
}

void Collection::CopyFrom(const Collection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Collection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Collection::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Collection::Swap(Collection* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Collection::InternalSwap(Collection* other) {
  using std::swap;
  name_.Swap(&other->name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  schema_.Swap(&other->schema_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string Collection::GetTypeName() const {
  return "Mysqlx.Crud.Collection";
}


// ===================================================================

void Limit::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Limit::kRowCountFieldNumber;
const int Limit::kOffsetFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Limit::Limit()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Limit.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Limit)
}
Limit::Limit(const Limit& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&row_count_, &from.row_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&offset_) -
    reinterpret_cast<char*>(&row_count_)) + sizeof(offset_));
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Limit)
}

void Limit::SharedCtor() {
  ::memset(&row_count_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&offset_) -
      reinterpret_cast<char*>(&row_count_)) + sizeof(offset_));
}

Limit::~Limit() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Limit)
  SharedDtor();
}

void Limit::SharedDtor() {
}

void Limit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Limit& Limit::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Limit.base);
  return *internal_default_instance();
}


void Limit::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Limit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    ::memset(&row_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&offset_) -
        reinterpret_cast<char*>(&row_count_)) + sizeof(offset_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Limit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Limit)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 row_count = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_row_count();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &row_count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 offset = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_offset();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Limit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Limit)
  return false;
#undef DO_
}

void Limit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Limit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 row_count = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->row_count(), output);
  }

  // optional uint64 offset = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->offset(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Limit)
}

size_t Limit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Limit)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required uint64 row_count = 1;
  if (has_row_count()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->row_count());
  }
  // optional uint64 offset = 2;
  if (has_offset()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->offset());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Limit::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Limit*>(&from));
}

void Limit::MergeFrom(const Limit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Limit)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      row_count_ = from.row_count_;
    }
    if (cached_has_bits & 0x00000002u) {
      offset_ = from.offset_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Limit::CopyFrom(const Limit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Limit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Limit::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Limit::Swap(Limit* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Limit::InternalSwap(Limit* other) {
  using std::swap;
  swap(row_count_, other->row_count_);
  swap(offset_, other->offset_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string Limit::GetTypeName() const {
  return "Mysqlx.Crud.Limit";
}


// ===================================================================

void LimitExpr::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_LimitExpr_default_instance_._instance.get_mutable()->row_count_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  ::Mysqlx::Crud::_LimitExpr_default_instance_._instance.get_mutable()->offset_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
}
void LimitExpr::clear_row_count() {
  if (row_count_ != NULL) row_count_->Clear();
  clear_has_row_count();
}
void LimitExpr::clear_offset() {
  if (offset_ != NULL) offset_->Clear();
  clear_has_offset();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LimitExpr::kRowCountFieldNumber;
const int LimitExpr::kOffsetFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LimitExpr::LimitExpr()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_LimitExpr.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.LimitExpr)
}
LimitExpr::LimitExpr(const LimitExpr& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_row_count()) {
    row_count_ = new ::Mysqlx::Expr::Expr(*from.row_count_);
  } else {
    row_count_ = NULL;
  }
  if (from.has_offset()) {
    offset_ = new ::Mysqlx::Expr::Expr(*from.offset_);
  } else {
    offset_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.LimitExpr)
}

void LimitExpr::SharedCtor() {
  ::memset(&row_count_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&offset_) -
      reinterpret_cast<char*>(&row_count_)) + sizeof(offset_));
}

LimitExpr::~LimitExpr() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.LimitExpr)
  SharedDtor();
}

void LimitExpr::SharedDtor() {
  if (this != internal_default_instance()) delete row_count_;
  if (this != internal_default_instance()) delete offset_;
}

void LimitExpr::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LimitExpr& LimitExpr::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_LimitExpr.base);
  return *internal_default_instance();
}


void LimitExpr::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.LimitExpr)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(row_count_ != NULL);
      row_count_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(offset_ != NULL);
      offset_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool LimitExpr::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.LimitExpr)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.Expr row_count = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_row_count()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Expr.Expr offset = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_offset()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.LimitExpr)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.LimitExpr)
  return false;
#undef DO_
}

void LimitExpr::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.LimitExpr)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Expr.Expr row_count = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->_internal_row_count(), output);
  }

  // optional .Mysqlx.Expr.Expr offset = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->_internal_offset(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.LimitExpr)
}

size_t LimitExpr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.LimitExpr)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required .Mysqlx.Expr.Expr row_count = 1;
  if (has_row_count()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *row_count_);
  }
  // optional .Mysqlx.Expr.Expr offset = 2;
  if (has_offset()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *offset_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LimitExpr::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LimitExpr*>(&from));
}

void LimitExpr::MergeFrom(const LimitExpr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.LimitExpr)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_row_count()->::Mysqlx::Expr::Expr::MergeFrom(from.row_count());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_offset()->::Mysqlx::Expr::Expr::MergeFrom(from.offset());
    }
  }
}

void LimitExpr::CopyFrom(const LimitExpr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.LimitExpr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LimitExpr::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_row_count()) {
    if (!this->row_count_->IsInitialized()) return false;
  }
  if (has_offset()) {
    if (!this->offset_->IsInitialized()) return false;
  }
  return true;
}

void LimitExpr::Swap(LimitExpr* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LimitExpr::InternalSwap(LimitExpr* other) {
  using std::swap;
  swap(row_count_, other->row_count_);
  swap(offset_, other->offset_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string LimitExpr::GetTypeName() const {
  return "Mysqlx.Crud.LimitExpr";
}


// ===================================================================

void Order::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_Order_default_instance_._instance.get_mutable()->expr_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
}
void Order::clear_expr() {
  if (expr_ != NULL) expr_->Clear();
  clear_has_expr();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Order::kExprFieldNumber;
const int Order::kDirectionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Order::Order()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Order.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Order)
}
Order::Order(const Order& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_expr()) {
    expr_ = new ::Mysqlx::Expr::Expr(*from.expr_);
  } else {
    expr_ = NULL;
  }
  direction_ = from.direction_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Order)
}

void Order::SharedCtor() {
  expr_ = NULL;
  direction_ = 1;
}

Order::~Order() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Order)
  SharedDtor();
}

void Order::SharedDtor() {
  if (this != internal_default_instance()) delete expr_;
}

void Order::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Order& Order::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Order.base);
  return *internal_default_instance();
}


void Order::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Order)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(expr_ != NULL);
      expr_->Clear();
    }
    direction_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Order::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Order)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.Expr expr = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_expr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::Order_Direction_IsValid(value)) {
            set_direction(static_cast< ::Mysqlx::Crud::Order_Direction >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Order)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Order)
  return false;
#undef DO_
}

void Order::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Order)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Expr.Expr expr = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->_internal_expr(), output);
  }

  // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->direction(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Order)
}

size_t Order::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Order)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required .Mysqlx.Expr.Expr expr = 1;
  if (has_expr()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *expr_);
  }
  // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
  if (has_direction()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->direction());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Order::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Order*>(&from));
}

void Order::MergeFrom(const Order& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Order)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_expr()->::Mysqlx::Expr::Expr::MergeFrom(from.expr());
    }
    if (cached_has_bits & 0x00000002u) {
      direction_ = from.direction_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Order::CopyFrom(const Order& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Order)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Order::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_expr()) {
    if (!this->expr_->IsInitialized()) return false;
  }
  return true;
}

void Order::Swap(Order* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Order::InternalSwap(Order* other) {
  using std::swap;
  swap(expr_, other->expr_);
  swap(direction_, other->direction_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string Order::GetTypeName() const {
  return "Mysqlx.Crud.Order";
}


// ===================================================================

void UpdateOperation::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_UpdateOperation_default_instance_._instance.get_mutable()->source_ = const_cast< ::Mysqlx::Expr::ColumnIdentifier*>(
      ::Mysqlx::Expr::ColumnIdentifier::internal_default_instance());
  ::Mysqlx::Crud::_UpdateOperation_default_instance_._instance.get_mutable()->value_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
}
void UpdateOperation::clear_source() {
  if (source_ != NULL) source_->Clear();
  clear_has_source();
}
void UpdateOperation::clear_value() {
  if (value_ != NULL) value_->Clear();
  clear_has_value();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UpdateOperation::kSourceFieldNumber;
const int UpdateOperation::kOperationFieldNumber;
const int UpdateOperation::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UpdateOperation::UpdateOperation()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_UpdateOperation.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.UpdateOperation)
}
UpdateOperation::UpdateOperation(const UpdateOperation& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_source()) {
    source_ = new ::Mysqlx::Expr::ColumnIdentifier(*from.source_);
  } else {
    source_ = NULL;
  }
  if (from.has_value()) {
    value_ = new ::Mysqlx::Expr::Expr(*from.value_);
  } else {
    value_ = NULL;
  }
  operation_ = from.operation_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.UpdateOperation)
}

void UpdateOperation::SharedCtor() {
  ::memset(&source_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&value_) -
      reinterpret_cast<char*>(&source_)) + sizeof(value_));
  operation_ = 1;
}

UpdateOperation::~UpdateOperation() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.UpdateOperation)
  SharedDtor();
}

void UpdateOperation::SharedDtor() {
  if (this != internal_default_instance()) delete source_;
  if (this != internal_default_instance()) delete value_;
}

void UpdateOperation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UpdateOperation& UpdateOperation::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_UpdateOperation.base);
  return *internal_default_instance();
}


void UpdateOperation::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.UpdateOperation)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(source_ != NULL);
      source_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(value_ != NULL);
      value_->Clear();
    }
    operation_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool UpdateOperation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.UpdateOperation)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.ColumnIdentifier source = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::UpdateOperation_UpdateType_IsValid(value)) {
            set_operation(static_cast< ::Mysqlx::Crud::UpdateOperation_UpdateType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Expr.Expr value = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.UpdateOperation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.UpdateOperation)
  return false;
#undef DO_
}

void UpdateOperation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.UpdateOperation)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Expr.ColumnIdentifier source = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->_internal_source(), output);
  }

  // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->operation(), output);
  }

  // optional .Mysqlx.Expr.Expr value = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->_internal_value(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.UpdateOperation)
}

size_t UpdateOperation::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Mysqlx.Crud.UpdateOperation)
  size_t total_size = 0;

  if (has_source()) {
    // required .Mysqlx.Expr.ColumnIdentifier source = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *source_);
  }

  if (has_operation()) {
    // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->operation());
  }

  return total_size;
}
size_t UpdateOperation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.UpdateOperation)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required .Mysqlx.Expr.ColumnIdentifier source = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *source_);

    // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->operation());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional .Mysqlx.Expr.Expr value = 3;
  if (has_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *value_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UpdateOperation::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpdateOperation*>(&from));
}

void UpdateOperation::MergeFrom(const UpdateOperation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.UpdateOperation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_source()->::Mysqlx::Expr::ColumnIdentifier::MergeFrom(from.source());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_value()->::Mysqlx::Expr::Expr::MergeFrom(from.value());
    }
    if (cached_has_bits & 0x00000004u) {
      operation_ = from.operation_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UpdateOperation::CopyFrom(const UpdateOperation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.UpdateOperation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateOperation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;
  if (has_source()) {
    if (!this->source_->IsInitialized()) return false;
  }
  if (has_value()) {
    if (!this->value_->IsInitialized()) return false;
  }
  return true;
}

void UpdateOperation::Swap(UpdateOperation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UpdateOperation::InternalSwap(UpdateOperation* other) {
  using std::swap;
  swap(source_, other->source_);
  swap(value_, other->value_);
  swap(operation_, other->operation_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string UpdateOperation::GetTypeName() const {
  return "Mysqlx.Crud.UpdateOperation";
}


// ===================================================================

void Find::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_Find_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  ::Mysqlx::Crud::_Find_default_instance_._instance.get_mutable()->criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  ::Mysqlx::Crud::_Find_default_instance_._instance.get_mutable()->grouping_criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  ::Mysqlx::Crud::_Find_default_instance_._instance.get_mutable()->limit_ = const_cast< ::Mysqlx::Crud::Limit*>(
      ::Mysqlx::Crud::Limit::internal_default_instance());
  ::Mysqlx::Crud::_Find_default_instance_._instance.get_mutable()->limit_expr_ = const_cast< ::Mysqlx::Crud::LimitExpr*>(
      ::Mysqlx::Crud::LimitExpr::internal_default_instance());
}
void Find::clear_criteria() {
  if (criteria_ != NULL) criteria_->Clear();
  clear_has_criteria();
}
void Find::clear_args() {
  args_.Clear();
}
void Find::clear_grouping() {
  grouping_.Clear();
}
void Find::clear_grouping_criteria() {
  if (grouping_criteria_ != NULL) grouping_criteria_->Clear();
  clear_has_grouping_criteria();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Find::kCollectionFieldNumber;
const int Find::kDataModelFieldNumber;
const int Find::kProjectionFieldNumber;
const int Find::kCriteriaFieldNumber;
const int Find::kArgsFieldNumber;
const int Find::kOrderFieldNumber;
const int Find::kGroupingFieldNumber;
const int Find::kGroupingCriteriaFieldNumber;
const int Find::kLockingFieldNumber;
const int Find::kLockingOptionsFieldNumber;
const int Find::kLimitFieldNumber;
const int Find::kLimitExprFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Find::Find()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Find.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Find)
}
Find::Find(const Find& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      projection_(from.projection_),
      order_(from.order_),
      grouping_(from.grouping_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = NULL;
  }
  if (from.has_criteria()) {
    criteria_ = new ::Mysqlx::Expr::Expr(*from.criteria_);
  } else {
    criteria_ = NULL;
  }
  if (from.has_limit()) {
    limit_ = new ::Mysqlx::Crud::Limit(*from.limit_);
  } else {
    limit_ = NULL;
  }
  if (from.has_grouping_criteria()) {
    grouping_criteria_ = new ::Mysqlx::Expr::Expr(*from.grouping_criteria_);
  } else {
    grouping_criteria_ = NULL;
  }
  if (from.has_limit_expr()) {
    limit_expr_ = new ::Mysqlx::Crud::LimitExpr(*from.limit_expr_);
  } else {
    limit_expr_ = NULL;
  }
  ::memcpy(&locking_options_, &from.locking_options_,
    static_cast<size_t>(reinterpret_cast<char*>(&locking_) -
    reinterpret_cast<char*>(&locking_options_)) + sizeof(locking_));
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Find)
}

void Find::SharedCtor() {
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&limit_expr_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(limit_expr_));
  locking_options_ = 1;
  data_model_ = 1;
  locking_ = 1;
}

Find::~Find() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Find)
  SharedDtor();
}

void Find::SharedDtor() {
  if (this != internal_default_instance()) delete collection_;
  if (this != internal_default_instance()) delete criteria_;
  if (this != internal_default_instance()) delete limit_;
  if (this != internal_default_instance()) delete grouping_criteria_;
  if (this != internal_default_instance()) delete limit_expr_;
}

void Find::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Find& Find::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Find.base);
  return *internal_default_instance();
}


void Find::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Find)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  projection_.Clear();
  order_.Clear();
  grouping_.Clear();
  args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(collection_ != NULL);
      collection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(criteria_ != NULL);
      criteria_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(limit_ != NULL);
      limit_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(grouping_criteria_ != NULL);
      grouping_criteria_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(limit_expr_ != NULL);
      limit_expr_->Clear();
    }
    locking_options_ = 1;
    data_model_ = 1;
    locking_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Find::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Find)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.Projection projection = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_projection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Expr.Expr criteria = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_criteria()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.Limit limit = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_limit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.Order order = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_order()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Expr.Expr grouping = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u /* 66 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_grouping()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u /* 74 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_grouping_criteria()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(90u /* 90 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.Find.RowLock locking = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(96u /* 96 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::Find_RowLock_IsValid(value)) {
            set_locking(static_cast< ::Mysqlx::Crud::Find_RowLock >(value));
          } else {
            unknown_fields_stream.WriteVarint32(96u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.Find.RowLockOptions locking_options = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(104u /* 104 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::Find_RowLockOptions_IsValid(value)) {
            set_locking_options(static_cast< ::Mysqlx::Crud::Find_RowLockOptions >(value));
          } else {
            unknown_fields_stream.WriteVarint32(104u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.LimitExpr limit_expr = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(114u /* 114 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_limit_expr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Find)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Find)
  return false;
#undef DO_
}

void Find::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Find)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->_internal_collection(), output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->data_model(), output);
  }

  // repeated .Mysqlx.Crud.Projection projection = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->projection_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4,
      this->projection(static_cast<int>(i)),
      output);
  }

  // optional .Mysqlx.Expr.Expr criteria = 5;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->_internal_criteria(), output);
  }

  // optional .Mysqlx.Crud.Limit limit = 6;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->_internal_limit(), output);
  }

  // repeated .Mysqlx.Crud.Order order = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->order_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7,
      this->order(static_cast<int>(i)),
      output);
  }

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->grouping_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8,
      this->grouping(static_cast<int>(i)),
      output);
  }

  // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->_internal_grouping_criteria(), output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->args_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11,
      this->args(static_cast<int>(i)),
      output);
  }

  // optional .Mysqlx.Crud.Find.RowLock locking = 12;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      12, this->locking(), output);
  }

  // optional .Mysqlx.Crud.Find.RowLockOptions locking_options = 13;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      13, this->locking_options(), output);
  }

  // optional .Mysqlx.Crud.LimitExpr limit_expr = 14;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      14, this->_internal_limit_expr(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Find)
}

size_t Find::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Find)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required .Mysqlx.Crud.Collection collection = 2;
  if (has_collection()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *collection_);
  }
  // repeated .Mysqlx.Crud.Projection projection = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->projection_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->projection(static_cast<int>(i)));
    }
  }

  // repeated .Mysqlx.Crud.Order order = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->order_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->order(static_cast<int>(i)));
    }
  }

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  {
    unsigned int count = static_cast<unsigned int>(this->grouping_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->grouping(static_cast<int>(i)));
    }
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  {
    unsigned int count = static_cast<unsigned int>(this->args_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->args(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 254u) {
    // optional .Mysqlx.Expr.Expr criteria = 5;
    if (has_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *criteria_);
    }

    // optional .Mysqlx.Crud.Limit limit = 6;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *limit_);
    }

    // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
    if (has_grouping_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *grouping_criteria_);
    }

    // optional .Mysqlx.Crud.LimitExpr limit_expr = 14;
    if (has_limit_expr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *limit_expr_);
    }

    // optional .Mysqlx.Crud.Find.RowLockOptions locking_options = 13;
    if (has_locking_options()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->locking_options());
    }

    // optional .Mysqlx.Crud.DataModel data_model = 3;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

    // optional .Mysqlx.Crud.Find.RowLock locking = 12;
    if (has_locking()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->locking());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Find::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Find*>(&from));
}

void Find::MergeFrom(const Find& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Find)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  projection_.MergeFrom(from.projection_);
  order_.MergeFrom(from.order_);
  grouping_.MergeFrom(from.grouping_);
  args_.MergeFrom(from.args_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.criteria());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_limit()->::Mysqlx::Crud::Limit::MergeFrom(from.limit());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_grouping_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.grouping_criteria());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_limit_expr()->::Mysqlx::Crud::LimitExpr::MergeFrom(from.limit_expr());
    }
    if (cached_has_bits & 0x00000020u) {
      locking_options_ = from.locking_options_;
    }
    if (cached_has_bits & 0x00000040u) {
      data_model_ = from.data_model_;
    }
    if (cached_has_bits & 0x00000080u) {
      locking_ = from.locking_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Find::CopyFrom(const Find& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Find)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Find::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->projection())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->order())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->grouping())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  if (has_collection()) {
    if (!this->collection_->IsInitialized()) return false;
  }
  if (has_criteria()) {
    if (!this->criteria_->IsInitialized()) return false;
  }
  if (has_limit()) {
    if (!this->limit_->IsInitialized()) return false;
  }
  if (has_grouping_criteria()) {
    if (!this->grouping_criteria_->IsInitialized()) return false;
  }
  if (has_limit_expr()) {
    if (!this->limit_expr_->IsInitialized()) return false;
  }
  return true;
}

void Find::Swap(Find* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Find::InternalSwap(Find* other) {
  using std::swap;
  CastToBase(&projection_)->InternalSwap(CastToBase(&other->projection_));
  CastToBase(&order_)->InternalSwap(CastToBase(&other->order_));
  CastToBase(&grouping_)->InternalSwap(CastToBase(&other->grouping_));
  CastToBase(&args_)->InternalSwap(CastToBase(&other->args_));
  swap(collection_, other->collection_);
  swap(criteria_, other->criteria_);
  swap(limit_, other->limit_);
  swap(grouping_criteria_, other->grouping_criteria_);
  swap(limit_expr_, other->limit_expr_);
  swap(locking_options_, other->locking_options_);
  swap(data_model_, other->data_model_);
  swap(locking_, other->locking_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string Find::GetTypeName() const {
  return "Mysqlx.Crud.Find";
}


// ===================================================================

void Insert_TypedRow::InitAsDefaultInstance() {
}
void Insert_TypedRow::clear_field() {
  field_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Insert_TypedRow::kFieldFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Insert_TypedRow::Insert_TypedRow()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Insert_TypedRow.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Insert.TypedRow)
}
Insert_TypedRow::Insert_TypedRow(const Insert_TypedRow& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      field_(from.field_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Insert.TypedRow)
}

void Insert_TypedRow::SharedCtor() {
}

Insert_TypedRow::~Insert_TypedRow() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Insert.TypedRow)
  SharedDtor();
}

void Insert_TypedRow::SharedDtor() {
}

void Insert_TypedRow::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Insert_TypedRow& Insert_TypedRow::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Insert_TypedRow.base);
  return *internal_default_instance();
}


void Insert_TypedRow::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Insert.TypedRow)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  field_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Insert_TypedRow::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Insert.TypedRow)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Mysqlx.Expr.Expr field = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_field()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Insert.TypedRow)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Insert.TypedRow)
  return false;
#undef DO_
}

void Insert_TypedRow::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Insert.TypedRow)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Mysqlx.Expr.Expr field = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->field_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1,
      this->field(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Insert.TypedRow)
}

size_t Insert_TypedRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Insert.TypedRow)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .Mysqlx.Expr.Expr field = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->field_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->field(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Insert_TypedRow::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Insert_TypedRow*>(&from));
}

void Insert_TypedRow::MergeFrom(const Insert_TypedRow& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Insert.TypedRow)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  field_.MergeFrom(from.field_);
}

void Insert_TypedRow::CopyFrom(const Insert_TypedRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Insert.TypedRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Insert_TypedRow::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->field())) return false;
  return true;
}

void Insert_TypedRow::Swap(Insert_TypedRow* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Insert_TypedRow::InternalSwap(Insert_TypedRow* other) {
  using std::swap;
  CastToBase(&field_)->InternalSwap(CastToBase(&other->field_));
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string Insert_TypedRow::GetTypeName() const {
  return "Mysqlx.Crud.Insert.TypedRow";
}


// ===================================================================

void Insert::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_Insert_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
}
void Insert::clear_args() {
  args_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Insert::kCollectionFieldNumber;
const int Insert::kDataModelFieldNumber;
const int Insert::kProjectionFieldNumber;
const int Insert::kRowFieldNumber;
const int Insert::kArgsFieldNumber;
const int Insert::kUpsertFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Insert::Insert()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Insert.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Insert)
}
Insert::Insert(const Insert& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      projection_(from.projection_),
      row_(from.row_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = NULL;
  }
  ::memcpy(&upsert_, &from.upsert_,
    static_cast<size_t>(reinterpret_cast<char*>(&data_model_) -
    reinterpret_cast<char*>(&upsert_)) + sizeof(data_model_));
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Insert)
}

void Insert::SharedCtor() {
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&upsert_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(upsert_));
  data_model_ = 1;
}

Insert::~Insert() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Insert)
  SharedDtor();
}

void Insert::SharedDtor() {
  if (this != internal_default_instance()) delete collection_;
}

void Insert::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Insert& Insert::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Insert.base);
  return *internal_default_instance();
}


void Insert::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Insert)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  projection_.Clear();
  row_.Clear();
  args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(collection_ != NULL);
    collection_->Clear();
  }
  if (cached_has_bits & 6u) {
    upsert_ = false;
    data_model_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Insert::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Insert)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.Column projection = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_projection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_row()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool upsert = 6 [default = false];
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          set_has_upsert();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &upsert_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Insert)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Insert)
  return false;
#undef DO_
}

void Insert::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Insert)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->_internal_collection(), output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->data_model(), output);
  }

  // repeated .Mysqlx.Crud.Column projection = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->projection_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3,
      this->projection(static_cast<int>(i)),
      output);
  }

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->row_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4,
      this->row(static_cast<int>(i)),
      output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->args_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5,
      this->args(static_cast<int>(i)),
      output);
  }

  // optional bool upsert = 6 [default = false];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->upsert(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Insert)
}

size_t Insert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Insert)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *collection_);
  }
  // repeated .Mysqlx.Crud.Column projection = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->projection_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->projection(static_cast<int>(i)));
    }
  }

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->row_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->row(static_cast<int>(i)));
    }
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->args_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->args(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 6u) {
    // optional bool upsert = 6 [default = false];
    if (has_upsert()) {
      total_size += 1 + 1;
    }

    // optional .Mysqlx.Crud.DataModel data_model = 2;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Insert::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Insert*>(&from));
}

void Insert::MergeFrom(const Insert& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Insert)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  projection_.MergeFrom(from.projection_);
  row_.MergeFrom(from.row_);
  args_.MergeFrom(from.args_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (cached_has_bits & 0x00000002u) {
      upsert_ = from.upsert_;
    }
    if (cached_has_bits & 0x00000004u) {
      data_model_ = from.data_model_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Insert::CopyFrom(const Insert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Insert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Insert::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->projection())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->row())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  if (has_collection()) {
    if (!this->collection_->IsInitialized()) return false;
  }
  return true;
}

void Insert::Swap(Insert* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Insert::InternalSwap(Insert* other) {
  using std::swap;
  CastToBase(&projection_)->InternalSwap(CastToBase(&other->projection_));
  CastToBase(&row_)->InternalSwap(CastToBase(&other->row_));
  CastToBase(&args_)->InternalSwap(CastToBase(&other->args_));
  swap(collection_, other->collection_);
  swap(upsert_, other->upsert_);
  swap(data_model_, other->data_model_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string Insert::GetTypeName() const {
  return "Mysqlx.Crud.Insert";
}


// ===================================================================

void Update::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_Update_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  ::Mysqlx::Crud::_Update_default_instance_._instance.get_mutable()->criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  ::Mysqlx::Crud::_Update_default_instance_._instance.get_mutable()->limit_ = const_cast< ::Mysqlx::Crud::Limit*>(
      ::Mysqlx::Crud::Limit::internal_default_instance());
  ::Mysqlx::Crud::_Update_default_instance_._instance.get_mutable()->limit_expr_ = const_cast< ::Mysqlx::Crud::LimitExpr*>(
      ::Mysqlx::Crud::LimitExpr::internal_default_instance());
}
void Update::clear_criteria() {
  if (criteria_ != NULL) criteria_->Clear();
  clear_has_criteria();
}
void Update::clear_args() {
  args_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Update::kCollectionFieldNumber;
const int Update::kDataModelFieldNumber;
const int Update::kCriteriaFieldNumber;
const int Update::kArgsFieldNumber;
const int Update::kOrderFieldNumber;
const int Update::kOperationFieldNumber;
const int Update::kLimitFieldNumber;
const int Update::kLimitExprFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Update::Update()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Update.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Update)
}
Update::Update(const Update& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      order_(from.order_),
      operation_(from.operation_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = NULL;
  }
  if (from.has_criteria()) {
    criteria_ = new ::Mysqlx::Expr::Expr(*from.criteria_);
  } else {
    criteria_ = NULL;
  }
  if (from.has_limit()) {
    limit_ = new ::Mysqlx::Crud::Limit(*from.limit_);
  } else {
    limit_ = NULL;
  }
  if (from.has_limit_expr()) {
    limit_expr_ = new ::Mysqlx::Crud::LimitExpr(*from.limit_expr_);
  } else {
    limit_expr_ = NULL;
  }
  data_model_ = from.data_model_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Update)
}

void Update::SharedCtor() {
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&limit_expr_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(limit_expr_));
  data_model_ = 1;
}

Update::~Update() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Update)
  SharedDtor();
}

void Update::SharedDtor() {
  if (this != internal_default_instance()) delete collection_;
  if (this != internal_default_instance()) delete criteria_;
  if (this != internal_default_instance()) delete limit_;
  if (this != internal_default_instance()) delete limit_expr_;
}

void Update::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Update& Update::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Update.base);
  return *internal_default_instance();
}


void Update::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Update)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  order_.Clear();
  operation_.Clear();
  args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(collection_ != NULL);
      collection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(criteria_ != NULL);
      criteria_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(limit_ != NULL);
      limit_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(limit_expr_ != NULL);
      limit_expr_->Clear();
    }
    data_model_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Update::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Update)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Expr.Expr criteria = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_criteria()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.Limit limit = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_limit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.Order order = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_order()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_operation()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u /* 66 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.LimitExpr limit_expr = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u /* 74 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_limit_expr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Update)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Update)
  return false;
#undef DO_
}

void Update::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Update)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->_internal_collection(), output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->data_model(), output);
  }

  // optional .Mysqlx.Expr.Expr criteria = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->_internal_criteria(), output);
  }

  // optional .Mysqlx.Crud.Limit limit = 5;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->_internal_limit(), output);
  }

  // repeated .Mysqlx.Crud.Order order = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->order_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6,
      this->order(static_cast<int>(i)),
      output);
  }

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->operation_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7,
      this->operation(static_cast<int>(i)),
      output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->args_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8,
      this->args(static_cast<int>(i)),
      output);
  }

  // optional .Mysqlx.Crud.LimitExpr limit_expr = 9;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->_internal_limit_expr(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Update)
}

size_t Update::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Update)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required .Mysqlx.Crud.Collection collection = 2;
  if (has_collection()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *collection_);
  }
  // repeated .Mysqlx.Crud.Order order = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->order_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->order(static_cast<int>(i)));
    }
  }

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->operation_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->operation(static_cast<int>(i)));
    }
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  {
    unsigned int count = static_cast<unsigned int>(this->args_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->args(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 30u) {
    // optional .Mysqlx.Expr.Expr criteria = 4;
    if (has_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *criteria_);
    }

    // optional .Mysqlx.Crud.Limit limit = 5;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *limit_);
    }

    // optional .Mysqlx.Crud.LimitExpr limit_expr = 9;
    if (has_limit_expr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *limit_expr_);
    }

    // optional .Mysqlx.Crud.DataModel data_model = 3;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Update::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Update*>(&from));
}

void Update::MergeFrom(const Update& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Update)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  order_.MergeFrom(from.order_);
  operation_.MergeFrom(from.operation_);
  args_.MergeFrom(from.args_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.criteria());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_limit()->::Mysqlx::Crud::Limit::MergeFrom(from.limit());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_limit_expr()->::Mysqlx::Crud::LimitExpr::MergeFrom(from.limit_expr());
    }
    if (cached_has_bits & 0x00000010u) {
      data_model_ = from.data_model_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Update::CopyFrom(const Update& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Update)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Update::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->order())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->operation())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  if (has_collection()) {
    if (!this->collection_->IsInitialized()) return false;
  }
  if (has_criteria()) {
    if (!this->criteria_->IsInitialized()) return false;
  }
  if (has_limit()) {
    if (!this->limit_->IsInitialized()) return false;
  }
  if (has_limit_expr()) {
    if (!this->limit_expr_->IsInitialized()) return false;
  }
  return true;
}

void Update::Swap(Update* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Update::InternalSwap(Update* other) {
  using std::swap;
  CastToBase(&order_)->InternalSwap(CastToBase(&other->order_));
  CastToBase(&operation_)->InternalSwap(CastToBase(&other->operation_));
  CastToBase(&args_)->InternalSwap(CastToBase(&other->args_));
  swap(collection_, other->collection_);
  swap(criteria_, other->criteria_);
  swap(limit_, other->limit_);
  swap(limit_expr_, other->limit_expr_);
  swap(data_model_, other->data_model_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string Update::GetTypeName() const {
  return "Mysqlx.Crud.Update";
}


// ===================================================================

void Delete::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_Delete_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  ::Mysqlx::Crud::_Delete_default_instance_._instance.get_mutable()->criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  ::Mysqlx::Crud::_Delete_default_instance_._instance.get_mutable()->limit_ = const_cast< ::Mysqlx::Crud::Limit*>(
      ::Mysqlx::Crud::Limit::internal_default_instance());
  ::Mysqlx::Crud::_Delete_default_instance_._instance.get_mutable()->limit_expr_ = const_cast< ::Mysqlx::Crud::LimitExpr*>(
      ::Mysqlx::Crud::LimitExpr::internal_default_instance());
}
void Delete::clear_criteria() {
  if (criteria_ != NULL) criteria_->Clear();
  clear_has_criteria();
}
void Delete::clear_args() {
  args_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Delete::kCollectionFieldNumber;
const int Delete::kDataModelFieldNumber;
const int Delete::kCriteriaFieldNumber;
const int Delete::kArgsFieldNumber;
const int Delete::kOrderFieldNumber;
const int Delete::kLimitFieldNumber;
const int Delete::kLimitExprFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Delete::Delete()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_Delete.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Delete)
}
Delete::Delete(const Delete& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      order_(from.order_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = NULL;
  }
  if (from.has_criteria()) {
    criteria_ = new ::Mysqlx::Expr::Expr(*from.criteria_);
  } else {
    criteria_ = NULL;
  }
  if (from.has_limit()) {
    limit_ = new ::Mysqlx::Crud::Limit(*from.limit_);
  } else {
    limit_ = NULL;
  }
  if (from.has_limit_expr()) {
    limit_expr_ = new ::Mysqlx::Crud::LimitExpr(*from.limit_expr_);
  } else {
    limit_expr_ = NULL;
  }
  data_model_ = from.data_model_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Delete)
}

void Delete::SharedCtor() {
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&limit_expr_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(limit_expr_));
  data_model_ = 1;
}

Delete::~Delete() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Delete)
  SharedDtor();
}

void Delete::SharedDtor() {
  if (this != internal_default_instance()) delete collection_;
  if (this != internal_default_instance()) delete criteria_;
  if (this != internal_default_instance()) delete limit_;
  if (this != internal_default_instance()) delete limit_expr_;
}

void Delete::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Delete& Delete::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_Delete.base);
  return *internal_default_instance();
}


void Delete::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Delete)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  order_.Clear();
  args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(collection_ != NULL);
      collection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(criteria_ != NULL);
      criteria_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(limit_ != NULL);
      limit_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(limit_expr_ != NULL);
      limit_expr_->Clear();
    }
    data_model_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Delete::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Delete)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Expr.Expr criteria = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_criteria()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.Limit limit = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_limit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.Order order = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_order()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.LimitExpr limit_expr = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_limit_expr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Delete)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Delete)
  return false;
#undef DO_
}

void Delete::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Delete)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->_internal_collection(), output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->data_model(), output);
  }

  // optional .Mysqlx.Expr.Expr criteria = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->_internal_criteria(), output);
  }

  // optional .Mysqlx.Crud.Limit limit = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->_internal_limit(), output);
  }

  // repeated .Mysqlx.Crud.Order order = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->order_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5,
      this->order(static_cast<int>(i)),
      output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->args_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6,
      this->args(static_cast<int>(i)),
      output);
  }

  // optional .Mysqlx.Crud.LimitExpr limit_expr = 7;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->_internal_limit_expr(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Delete)
}

size_t Delete::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Delete)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *collection_);
  }
  // repeated .Mysqlx.Crud.Order order = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->order_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->order(static_cast<int>(i)));
    }
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->args_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->args(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 30u) {
    // optional .Mysqlx.Expr.Expr criteria = 3;
    if (has_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *criteria_);
    }

    // optional .Mysqlx.Crud.Limit limit = 4;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *limit_);
    }

    // optional .Mysqlx.Crud.LimitExpr limit_expr = 7;
    if (has_limit_expr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *limit_expr_);
    }

    // optional .Mysqlx.Crud.DataModel data_model = 2;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Delete::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Delete*>(&from));
}

void Delete::MergeFrom(const Delete& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Delete)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  order_.MergeFrom(from.order_);
  args_.MergeFrom(from.args_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.criteria());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_limit()->::Mysqlx::Crud::Limit::MergeFrom(from.limit());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_limit_expr()->::Mysqlx::Crud::LimitExpr::MergeFrom(from.limit_expr());
    }
    if (cached_has_bits & 0x00000010u) {
      data_model_ = from.data_model_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Delete::CopyFrom(const Delete& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Delete)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Delete::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->order())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  if (has_collection()) {
    if (!this->collection_->IsInitialized()) return false;
  }
  if (has_criteria()) {
    if (!this->criteria_->IsInitialized()) return false;
  }
  if (has_limit()) {
    if (!this->limit_->IsInitialized()) return false;
  }
  if (has_limit_expr()) {
    if (!this->limit_expr_->IsInitialized()) return false;
  }
  return true;
}

void Delete::Swap(Delete* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Delete::InternalSwap(Delete* other) {
  using std::swap;
  CastToBase(&order_)->InternalSwap(CastToBase(&other->order_));
  CastToBase(&args_)->InternalSwap(CastToBase(&other->args_));
  swap(collection_, other->collection_);
  swap(criteria_, other->criteria_);
  swap(limit_, other->limit_);
  swap(limit_expr_, other->limit_expr_);
  swap(data_model_, other->data_model_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string Delete::GetTypeName() const {
  return "Mysqlx.Crud.Delete";
}


// ===================================================================

void CreateView::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_CreateView_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  ::Mysqlx::Crud::_CreateView_default_instance_._instance.get_mutable()->stmt_ = const_cast< ::Mysqlx::Crud::Find*>(
      ::Mysqlx::Crud::Find::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CreateView::kCollectionFieldNumber;
const int CreateView::kDefinerFieldNumber;
const int CreateView::kAlgorithmFieldNumber;
const int CreateView::kSecurityFieldNumber;
const int CreateView::kCheckFieldNumber;
const int CreateView::kColumnFieldNumber;
const int CreateView::kStmtFieldNumber;
const int CreateView::kReplaceExistingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CreateView::CreateView()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_CreateView.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.CreateView)
}
CreateView::CreateView(const CreateView& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      column_(from.column_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  definer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_definer()) {
    definer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.definer_);
  }
  if (from.has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = NULL;
  }
  if (from.has_stmt()) {
    stmt_ = new ::Mysqlx::Crud::Find(*from.stmt_);
  } else {
    stmt_ = NULL;
  }
  ::memcpy(&replace_existing_, &from.replace_existing_,
    static_cast<size_t>(reinterpret_cast<char*>(&security_) -
    reinterpret_cast<char*>(&replace_existing_)) + sizeof(security_));
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.CreateView)
}

void CreateView::SharedCtor() {
  definer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&replace_existing_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(replace_existing_));
  check_ = 1;
  algorithm_ = 1;
  security_ = 2;
}

CreateView::~CreateView() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.CreateView)
  SharedDtor();
}

void CreateView::SharedDtor() {
  definer_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete collection_;
  if (this != internal_default_instance()) delete stmt_;
}

void CreateView::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CreateView& CreateView::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_CreateView.base);
  return *internal_default_instance();
}


void CreateView::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.CreateView)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  column_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      definer_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(collection_ != NULL);
      collection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(stmt_ != NULL);
      stmt_->Clear();
    }
  }
  if (cached_has_bits & 120u) {
    replace_existing_ = false;
    check_ = 1;
    algorithm_ = 1;
    security_ = 2;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool CreateView::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.CreateView)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string definer = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_definer()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3 [default = UNDEFINED];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::ViewAlgorithm_IsValid(value)) {
            set_algorithm(static_cast< ::Mysqlx::Crud::ViewAlgorithm >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.ViewSqlSecurity security = 4 [default = DEFINER];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::ViewSqlSecurity_IsValid(value)) {
            set_security(static_cast< ::Mysqlx::Crud::ViewSqlSecurity >(value));
          } else {
            unknown_fields_stream.WriteVarint32(32u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.ViewCheckOption check = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::ViewCheckOption_IsValid(value)) {
            set_check(static_cast< ::Mysqlx::Crud::ViewCheckOption >(value));
          } else {
            unknown_fields_stream.WriteVarint32(40u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string column = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_column()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .Mysqlx.Crud.Find stmt = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_stmt()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool replace_existing = 8 [default = false];
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {
          set_has_replace_existing();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &replace_existing_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.CreateView)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.CreateView)
  return false;
#undef DO_
}

void CreateView::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.CreateView)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->_internal_collection(), output);
  }

  // optional string definer = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->definer(), output);
  }

  // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3 [default = UNDEFINED];
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->algorithm(), output);
  }

  // optional .Mysqlx.Crud.ViewSqlSecurity security = 4 [default = DEFINER];
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->security(), output);
  }

  // optional .Mysqlx.Crud.ViewCheckOption check = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->check(), output);
  }

  // repeated string column = 6;
  for (int i = 0, n = this->column_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->column(i), output);
  }

  // required .Mysqlx.Crud.Find stmt = 7;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->_internal_stmt(), output);
  }

  // optional bool replace_existing = 8 [default = false];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->replace_existing(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.CreateView)
}

size_t CreateView::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Mysqlx.Crud.CreateView)
  size_t total_size = 0;

  if (has_collection()) {
    // required .Mysqlx.Crud.Collection collection = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *collection_);
  }

  if (has_stmt()) {
    // required .Mysqlx.Crud.Find stmt = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *stmt_);
  }

  return total_size;
}
size_t CreateView::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.CreateView)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required .Mysqlx.Crud.Collection collection = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *collection_);

    // required .Mysqlx.Crud.Find stmt = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *stmt_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // repeated string column = 6;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->column_size());
  for (int i = 0, n = this->column_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->column(i));
  }

  // optional string definer = 2;
  if (has_definer()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->definer());
  }

  if (_has_bits_[0 / 32] & 120u) {
    // optional bool replace_existing = 8 [default = false];
    if (has_replace_existing()) {
      total_size += 1 + 1;
    }

    // optional .Mysqlx.Crud.ViewCheckOption check = 5;
    if (has_check()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->check());
    }

    // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3 [default = UNDEFINED];
    if (has_algorithm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->algorithm());
    }

    // optional .Mysqlx.Crud.ViewSqlSecurity security = 4 [default = DEFINER];
    if (has_security()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->security());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CreateView::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateView*>(&from));
}

void CreateView::MergeFrom(const CreateView& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.CreateView)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  column_.MergeFrom(from.column_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 127u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_definer();
      definer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.definer_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_stmt()->::Mysqlx::Crud::Find::MergeFrom(from.stmt());
    }
    if (cached_has_bits & 0x00000008u) {
      replace_existing_ = from.replace_existing_;
    }
    if (cached_has_bits & 0x00000010u) {
      check_ = from.check_;
    }
    if (cached_has_bits & 0x00000020u) {
      algorithm_ = from.algorithm_;
    }
    if (cached_has_bits & 0x00000040u) {
      security_ = from.security_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CreateView::CopyFrom(const CreateView& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.CreateView)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateView::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;
  if (has_collection()) {
    if (!this->collection_->IsInitialized()) return false;
  }
  if (has_stmt()) {
    if (!this->stmt_->IsInitialized()) return false;
  }
  return true;
}

void CreateView::Swap(CreateView* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CreateView::InternalSwap(CreateView* other) {
  using std::swap;
  column_.InternalSwap(CastToBase(&other->column_));
  definer_.Swap(&other->definer_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(collection_, other->collection_);
  swap(stmt_, other->stmt_);
  swap(replace_existing_, other->replace_existing_);
  swap(check_, other->check_);
  swap(algorithm_, other->algorithm_);
  swap(security_, other->security_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string CreateView::GetTypeName() const {
  return "Mysqlx.Crud.CreateView";
}


// ===================================================================

void ModifyView::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_ModifyView_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  ::Mysqlx::Crud::_ModifyView_default_instance_._instance.get_mutable()->stmt_ = const_cast< ::Mysqlx::Crud::Find*>(
      ::Mysqlx::Crud::Find::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ModifyView::kCollectionFieldNumber;
const int ModifyView::kDefinerFieldNumber;
const int ModifyView::kAlgorithmFieldNumber;
const int ModifyView::kSecurityFieldNumber;
const int ModifyView::kCheckFieldNumber;
const int ModifyView::kColumnFieldNumber;
const int ModifyView::kStmtFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ModifyView::ModifyView()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_ModifyView.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.ModifyView)
}
ModifyView::ModifyView(const ModifyView& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      column_(from.column_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  definer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_definer()) {
    definer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.definer_);
  }
  if (from.has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = NULL;
  }
  if (from.has_stmt()) {
    stmt_ = new ::Mysqlx::Crud::Find(*from.stmt_);
  } else {
    stmt_ = NULL;
  }
  ::memcpy(&check_, &from.check_,
    static_cast<size_t>(reinterpret_cast<char*>(&security_) -
    reinterpret_cast<char*>(&check_)) + sizeof(security_));
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.ModifyView)
}

void ModifyView::SharedCtor() {
  definer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&stmt_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(stmt_));
  check_ = 1;
  algorithm_ = 1;
  security_ = 1;
}

ModifyView::~ModifyView() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.ModifyView)
  SharedDtor();
}

void ModifyView::SharedDtor() {
  definer_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete collection_;
  if (this != internal_default_instance()) delete stmt_;
}

void ModifyView::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ModifyView& ModifyView::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_ModifyView.base);
  return *internal_default_instance();
}


void ModifyView::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.ModifyView)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  column_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      definer_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(collection_ != NULL);
      collection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(stmt_ != NULL);
      stmt_->Clear();
    }
    check_ = 1;
    algorithm_ = 1;
    security_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ModifyView::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.ModifyView)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string definer = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_definer()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::ViewAlgorithm_IsValid(value)) {
            set_algorithm(static_cast< ::Mysqlx::Crud::ViewAlgorithm >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.ViewSqlSecurity security = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::ViewSqlSecurity_IsValid(value)) {
            set_security(static_cast< ::Mysqlx::Crud::ViewSqlSecurity >(value));
          } else {
            unknown_fields_stream.WriteVarint32(32u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.ViewCheckOption check = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::ViewCheckOption_IsValid(value)) {
            set_check(static_cast< ::Mysqlx::Crud::ViewCheckOption >(value));
          } else {
            unknown_fields_stream.WriteVarint32(40u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string column = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_column()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.Find stmt = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_stmt()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.ModifyView)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.ModifyView)
  return false;
#undef DO_
}

void ModifyView::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.ModifyView)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->_internal_collection(), output);
  }

  // optional string definer = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->definer(), output);
  }

  // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->algorithm(), output);
  }

  // optional .Mysqlx.Crud.ViewSqlSecurity security = 4;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->security(), output);
  }

  // optional .Mysqlx.Crud.ViewCheckOption check = 5;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->check(), output);
  }

  // repeated string column = 6;
  for (int i = 0, n = this->column_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->column(i), output);
  }

  // optional .Mysqlx.Crud.Find stmt = 7;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->_internal_stmt(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.ModifyView)
}

size_t ModifyView::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.ModifyView)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *collection_);
  }
  // repeated string column = 6;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->column_size());
  for (int i = 0, n = this->column_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->column(i));
  }

  // optional string definer = 2;
  if (has_definer()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->definer());
  }

  if (_has_bits_[0 / 32] & 60u) {
    // optional .Mysqlx.Crud.Find stmt = 7;
    if (has_stmt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *stmt_);
    }

    // optional .Mysqlx.Crud.ViewCheckOption check = 5;
    if (has_check()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->check());
    }

    // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3;
    if (has_algorithm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->algorithm());
    }

    // optional .Mysqlx.Crud.ViewSqlSecurity security = 4;
    if (has_security()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->security());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ModifyView::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ModifyView*>(&from));
}

void ModifyView::MergeFrom(const ModifyView& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.ModifyView)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  column_.MergeFrom(from.column_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_definer();
      definer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.definer_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_stmt()->::Mysqlx::Crud::Find::MergeFrom(from.stmt());
    }
    if (cached_has_bits & 0x00000008u) {
      check_ = from.check_;
    }
    if (cached_has_bits & 0x00000010u) {
      algorithm_ = from.algorithm_;
    }
    if (cached_has_bits & 0x00000020u) {
      security_ = from.security_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ModifyView::CopyFrom(const ModifyView& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.ModifyView)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModifyView::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (has_collection()) {
    if (!this->collection_->IsInitialized()) return false;
  }
  if (has_stmt()) {
    if (!this->stmt_->IsInitialized()) return false;
  }
  return true;
}

void ModifyView::Swap(ModifyView* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ModifyView::InternalSwap(ModifyView* other) {
  using std::swap;
  column_.InternalSwap(CastToBase(&other->column_));
  definer_.Swap(&other->definer_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(collection_, other->collection_);
  swap(stmt_, other->stmt_);
  swap(check_, other->check_);
  swap(algorithm_, other->algorithm_);
  swap(security_, other->security_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string ModifyView::GetTypeName() const {
  return "Mysqlx.Crud.ModifyView";
}


// ===================================================================

void DropView::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_DropView_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DropView::kCollectionFieldNumber;
const int DropView::kIfExistsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DropView::DropView()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_mysqlx_5fcrud_2eproto::scc_info_DropView.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.DropView)
}
DropView::DropView(const DropView& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = NULL;
  }
  if_exists_ = from.if_exists_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.DropView)
}

void DropView::SharedCtor() {
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&if_exists_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(if_exists_));
}

DropView::~DropView() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.DropView)
  SharedDtor();
}

void DropView::SharedDtor() {
  if (this != internal_default_instance()) delete collection_;
}

void DropView::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DropView& DropView::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_mysqlx_5fcrud_2eproto::scc_info_DropView.base);
  return *internal_default_instance();
}


void DropView::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.DropView)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(collection_ != NULL);
    collection_->Clear();
  }
  if_exists_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool DropView::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.DropView)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool if_exists = 2 [default = false];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_if_exists();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &if_exists_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.DropView)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.DropView)
  return false;
#undef DO_
}

void DropView::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.DropView)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->_internal_collection(), output);
  }

  // optional bool if_exists = 2 [default = false];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->if_exists(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.DropView)
}

size_t DropView::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.DropView)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *collection_);
  }
  // optional bool if_exists = 2 [default = false];
  if (has_if_exists()) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DropView::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DropView*>(&from));
}

void DropView::MergeFrom(const DropView& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.DropView)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (cached_has_bits & 0x00000002u) {
      if_exists_ = from.if_exists_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DropView::CopyFrom(const DropView& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.DropView)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DropView::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_collection()) {
    if (!this->collection_->IsInitialized()) return false;
  }
  return true;
}

void DropView::Swap(DropView* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DropView::InternalSwap(DropView* other) {
  using std::swap;
  swap(collection_, other->collection_);
  swap(if_exists_, other->if_exists_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string DropView::GetTypeName() const {
  return "Mysqlx.Crud.DropView";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace Crud
}  // namespace Mysqlx
namespace google {
namespace protobuf {
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Column* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Column >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Column >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Projection* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Projection >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Projection >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Collection* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Collection >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Collection >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Limit* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Limit >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Limit >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::LimitExpr* Arena::CreateMaybeMessage< ::Mysqlx::Crud::LimitExpr >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::LimitExpr >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Order* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Order >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Order >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::UpdateOperation* Arena::CreateMaybeMessage< ::Mysqlx::Crud::UpdateOperation >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::UpdateOperation >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Find* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Find >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Find >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Insert_TypedRow* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Insert_TypedRow >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Insert_TypedRow >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Insert* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Insert >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Insert >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Update* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Update >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Update >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::Delete* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Delete >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Delete >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::CreateView* Arena::CreateMaybeMessage< ::Mysqlx::Crud::CreateView >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::CreateView >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::ModifyView* Arena::CreateMaybeMessage< ::Mysqlx::Crud::ModifyView >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::ModifyView >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::Mysqlx::Crud::DropView* Arena::CreateMaybeMessage< ::Mysqlx::Crud::DropView >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::DropView >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
