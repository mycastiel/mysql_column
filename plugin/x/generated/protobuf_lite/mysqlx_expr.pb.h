// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mysqlx_expr.proto

#ifndef PROTOBUF_INCLUDED_mysqlx_5fexpr_2eproto
#define PROTOBUF_INCLUDED_mysqlx_5fexpr_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "mysqlx_datatypes.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_mysqlx_5fexpr_2eproto 

namespace protobuf_mysqlx_5fexpr_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_mysqlx_5fexpr_2eproto
namespace Mysqlx {
namespace Expr {
class Array;
class ArrayDefaultTypeInternal;
extern ArrayDefaultTypeInternal _Array_default_instance_;
class ColumnIdentifier;
class ColumnIdentifierDefaultTypeInternal;
extern ColumnIdentifierDefaultTypeInternal _ColumnIdentifier_default_instance_;
class DocumentPathItem;
class DocumentPathItemDefaultTypeInternal;
extern DocumentPathItemDefaultTypeInternal _DocumentPathItem_default_instance_;
class Expr;
class ExprDefaultTypeInternal;
extern ExprDefaultTypeInternal _Expr_default_instance_;
class FunctionCall;
class FunctionCallDefaultTypeInternal;
extern FunctionCallDefaultTypeInternal _FunctionCall_default_instance_;
class Identifier;
class IdentifierDefaultTypeInternal;
extern IdentifierDefaultTypeInternal _Identifier_default_instance_;
class Object;
class ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class Object_ObjectField;
class Object_ObjectFieldDefaultTypeInternal;
extern Object_ObjectFieldDefaultTypeInternal _Object_ObjectField_default_instance_;
class Operator;
class OperatorDefaultTypeInternal;
extern OperatorDefaultTypeInternal _Operator_default_instance_;
}  // namespace Expr
}  // namespace Mysqlx
namespace google {
namespace protobuf {
template<> ::Mysqlx::Expr::Array* Arena::CreateMaybeMessage<::Mysqlx::Expr::Array>(Arena*);
template<> ::Mysqlx::Expr::ColumnIdentifier* Arena::CreateMaybeMessage<::Mysqlx::Expr::ColumnIdentifier>(Arena*);
template<> ::Mysqlx::Expr::DocumentPathItem* Arena::CreateMaybeMessage<::Mysqlx::Expr::DocumentPathItem>(Arena*);
template<> ::Mysqlx::Expr::Expr* Arena::CreateMaybeMessage<::Mysqlx::Expr::Expr>(Arena*);
template<> ::Mysqlx::Expr::FunctionCall* Arena::CreateMaybeMessage<::Mysqlx::Expr::FunctionCall>(Arena*);
template<> ::Mysqlx::Expr::Identifier* Arena::CreateMaybeMessage<::Mysqlx::Expr::Identifier>(Arena*);
template<> ::Mysqlx::Expr::Object* Arena::CreateMaybeMessage<::Mysqlx::Expr::Object>(Arena*);
template<> ::Mysqlx::Expr::Object_ObjectField* Arena::CreateMaybeMessage<::Mysqlx::Expr::Object_ObjectField>(Arena*);
template<> ::Mysqlx::Expr::Operator* Arena::CreateMaybeMessage<::Mysqlx::Expr::Operator>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Mysqlx {
namespace Expr {

enum Expr_Type {
  Expr_Type_IDENT = 1,
  Expr_Type_LITERAL = 2,
  Expr_Type_VARIABLE = 3,
  Expr_Type_FUNC_CALL = 4,
  Expr_Type_OPERATOR = 5,
  Expr_Type_PLACEHOLDER = 6,
  Expr_Type_OBJECT = 7,
  Expr_Type_ARRAY = 8
};
bool Expr_Type_IsValid(int value);
const Expr_Type Expr_Type_Type_MIN = Expr_Type_IDENT;
const Expr_Type Expr_Type_Type_MAX = Expr_Type_ARRAY;
const int Expr_Type_Type_ARRAYSIZE = Expr_Type_Type_MAX + 1;

enum DocumentPathItem_Type {
  DocumentPathItem_Type_MEMBER = 1,
  DocumentPathItem_Type_MEMBER_ASTERISK = 2,
  DocumentPathItem_Type_ARRAY_INDEX = 3,
  DocumentPathItem_Type_ARRAY_INDEX_ASTERISK = 4,
  DocumentPathItem_Type_DOUBLE_ASTERISK = 5
};
bool DocumentPathItem_Type_IsValid(int value);
const DocumentPathItem_Type DocumentPathItem_Type_Type_MIN = DocumentPathItem_Type_MEMBER;
const DocumentPathItem_Type DocumentPathItem_Type_Type_MAX = DocumentPathItem_Type_DOUBLE_ASTERISK;
const int DocumentPathItem_Type_Type_ARRAYSIZE = DocumentPathItem_Type_Type_MAX + 1;

// ===================================================================

class Expr : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.Expr) */ {
 public:
  Expr();
  virtual ~Expr();

  Expr(const Expr& from);

  inline Expr& operator=(const Expr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expr(Expr&& from) noexcept
    : Expr() {
    *this = ::std::move(from);
  }

  inline Expr& operator=(Expr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Expr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expr* internal_default_instance() {
    return reinterpret_cast<const Expr*>(
               &_Expr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Expr* other);
  friend void swap(Expr& a, Expr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expr* New() const final {
    return CreateMaybeMessage<Expr>(NULL);
  }

  Expr* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expr>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Expr& from);
  void MergeFrom(const Expr& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Expr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Expr_Type Type;
  static const Type IDENT =
    Expr_Type_IDENT;
  static const Type LITERAL =
    Expr_Type_LITERAL;
  static const Type VARIABLE =
    Expr_Type_VARIABLE;
  static const Type FUNC_CALL =
    Expr_Type_FUNC_CALL;
  static const Type OPERATOR =
    Expr_Type_OPERATOR;
  static const Type PLACEHOLDER =
    Expr_Type_PLACEHOLDER;
  static const Type OBJECT =
    Expr_Type_OBJECT;
  static const Type ARRAY =
    Expr_Type_ARRAY;
  static inline bool Type_IsValid(int value) {
    return Expr_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Expr_Type_Type_MIN;
  static const Type Type_MAX =
    Expr_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Expr_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string variable = 3;
  bool has_variable() const;
  void clear_variable();
  static const int kVariableFieldNumber = 3;
  const ::std::string& variable() const;
  void set_variable(const ::std::string& value);
  #if LANG_CXX11
  void set_variable(::std::string&& value);
  #endif
  void set_variable(const char* value);
  void set_variable(const char* value, size_t size);
  ::std::string* mutable_variable();
  ::std::string* release_variable();
  void set_allocated_variable(::std::string* variable);

  // optional .Mysqlx.Expr.ColumnIdentifier identifier = 2;
  bool has_identifier() const;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 2;
  private:
  const ::Mysqlx::Expr::ColumnIdentifier& _internal_identifier() const;
  public:
  const ::Mysqlx::Expr::ColumnIdentifier& identifier() const;
  ::Mysqlx::Expr::ColumnIdentifier* release_identifier();
  ::Mysqlx::Expr::ColumnIdentifier* mutable_identifier();
  void set_allocated_identifier(::Mysqlx::Expr::ColumnIdentifier* identifier);

  // optional .Mysqlx.Datatypes.Scalar literal = 4;
  bool has_literal() const;
  void clear_literal();
  static const int kLiteralFieldNumber = 4;
  private:
  const ::Mysqlx::Datatypes::Scalar& _internal_literal() const;
  public:
  const ::Mysqlx::Datatypes::Scalar& literal() const;
  ::Mysqlx::Datatypes::Scalar* release_literal();
  ::Mysqlx::Datatypes::Scalar* mutable_literal();
  void set_allocated_literal(::Mysqlx::Datatypes::Scalar* literal);

  // optional .Mysqlx.Expr.FunctionCall function_call = 5;
  bool has_function_call() const;
  void clear_function_call();
  static const int kFunctionCallFieldNumber = 5;
  private:
  const ::Mysqlx::Expr::FunctionCall& _internal_function_call() const;
  public:
  const ::Mysqlx::Expr::FunctionCall& function_call() const;
  ::Mysqlx::Expr::FunctionCall* release_function_call();
  ::Mysqlx::Expr::FunctionCall* mutable_function_call();
  void set_allocated_function_call(::Mysqlx::Expr::FunctionCall* function_call);

  // optional .Mysqlx.Expr.Operator operator = 6;
  bool has_operator_() const;
  void clear_operator_();
  static const int kOperatorFieldNumber = 6;
  private:
  const ::Mysqlx::Expr::Operator& _internal_operator_() const;
  public:
  const ::Mysqlx::Expr::Operator& operator_() const;
  ::Mysqlx::Expr::Operator* release_operator_();
  ::Mysqlx::Expr::Operator* mutable_operator_();
  void set_allocated_operator_(::Mysqlx::Expr::Operator* operator_);

  // optional .Mysqlx.Expr.Object object = 8;
  bool has_object() const;
  void clear_object();
  static const int kObjectFieldNumber = 8;
  private:
  const ::Mysqlx::Expr::Object& _internal_object() const;
  public:
  const ::Mysqlx::Expr::Object& object() const;
  ::Mysqlx::Expr::Object* release_object();
  ::Mysqlx::Expr::Object* mutable_object();
  void set_allocated_object(::Mysqlx::Expr::Object* object);

  // optional .Mysqlx.Expr.Array array = 9;
  bool has_array() const;
  void clear_array();
  static const int kArrayFieldNumber = 9;
  private:
  const ::Mysqlx::Expr::Array& _internal_array() const;
  public:
  const ::Mysqlx::Expr::Array& array() const;
  ::Mysqlx::Expr::Array* release_array();
  ::Mysqlx::Expr::Array* mutable_array();
  void set_allocated_array(::Mysqlx::Expr::Array* array);

  // optional uint32 position = 7;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 7;
  ::google::protobuf::uint32 position() const;
  void set_position(::google::protobuf::uint32 value);

  // required .Mysqlx.Expr.Expr.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Mysqlx::Expr::Expr_Type type() const;
  void set_type(::Mysqlx::Expr::Expr_Type value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Expr)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_identifier();
  void clear_has_identifier();
  void set_has_variable();
  void clear_has_variable();
  void set_has_literal();
  void clear_has_literal();
  void set_has_function_call();
  void clear_has_function_call();
  void set_has_operator_();
  void clear_has_operator_();
  void set_has_position();
  void clear_has_position();
  void set_has_object();
  void clear_has_object();
  void set_has_array();
  void clear_has_array();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr variable_;
  ::Mysqlx::Expr::ColumnIdentifier* identifier_;
  ::Mysqlx::Datatypes::Scalar* literal_;
  ::Mysqlx::Expr::FunctionCall* function_call_;
  ::Mysqlx::Expr::Operator* operator__;
  ::Mysqlx::Expr::Object* object_;
  ::Mysqlx::Expr::Array* array_;
  ::google::protobuf::uint32 position_;
  int type_;
  friend struct ::protobuf_mysqlx_5fexpr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Identifier : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.Identifier) */ {
 public:
  Identifier();
  virtual ~Identifier();

  Identifier(const Identifier& from);

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier(Identifier&& from) noexcept
    : Identifier() {
    *this = ::std::move(from);
  }

  inline Identifier& operator=(Identifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Identifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier* internal_default_instance() {
    return reinterpret_cast<const Identifier*>(
               &_Identifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Identifier* other);
  friend void swap(Identifier& a, Identifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier* New() const final {
    return CreateMaybeMessage<Identifier>(NULL);
  }

  Identifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Identifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string schema_name = 2;
  bool has_schema_name() const;
  void clear_schema_name();
  static const int kSchemaNameFieldNumber = 2;
  const ::std::string& schema_name() const;
  void set_schema_name(const ::std::string& value);
  #if LANG_CXX11
  void set_schema_name(::std::string&& value);
  #endif
  void set_schema_name(const char* value);
  void set_schema_name(const char* value, size_t size);
  ::std::string* mutable_schema_name();
  ::std::string* release_schema_name();
  void set_allocated_schema_name(::std::string* schema_name);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Identifier)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_schema_name();
  void clear_has_schema_name();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr schema_name_;
  friend struct ::protobuf_mysqlx_5fexpr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DocumentPathItem : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.DocumentPathItem) */ {
 public:
  DocumentPathItem();
  virtual ~DocumentPathItem();

  DocumentPathItem(const DocumentPathItem& from);

  inline DocumentPathItem& operator=(const DocumentPathItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DocumentPathItem(DocumentPathItem&& from) noexcept
    : DocumentPathItem() {
    *this = ::std::move(from);
  }

  inline DocumentPathItem& operator=(DocumentPathItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DocumentPathItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DocumentPathItem* internal_default_instance() {
    return reinterpret_cast<const DocumentPathItem*>(
               &_DocumentPathItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(DocumentPathItem* other);
  friend void swap(DocumentPathItem& a, DocumentPathItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DocumentPathItem* New() const final {
    return CreateMaybeMessage<DocumentPathItem>(NULL);
  }

  DocumentPathItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DocumentPathItem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DocumentPathItem& from);
  void MergeFrom(const DocumentPathItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DocumentPathItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DocumentPathItem_Type Type;
  static const Type MEMBER =
    DocumentPathItem_Type_MEMBER;
  static const Type MEMBER_ASTERISK =
    DocumentPathItem_Type_MEMBER_ASTERISK;
  static const Type ARRAY_INDEX =
    DocumentPathItem_Type_ARRAY_INDEX;
  static const Type ARRAY_INDEX_ASTERISK =
    DocumentPathItem_Type_ARRAY_INDEX_ASTERISK;
  static const Type DOUBLE_ASTERISK =
    DocumentPathItem_Type_DOUBLE_ASTERISK;
  static inline bool Type_IsValid(int value) {
    return DocumentPathItem_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DocumentPathItem_Type_Type_MIN;
  static const Type Type_MAX =
    DocumentPathItem_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DocumentPathItem_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional uint32 index = 3;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 3;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // required .Mysqlx.Expr.DocumentPathItem.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Mysqlx::Expr::DocumentPathItem_Type type() const;
  void set_type(::Mysqlx::Expr::DocumentPathItem_Type value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.DocumentPathItem)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_value();
  void clear_has_value();
  void set_has_index();
  void clear_has_index();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::uint32 index_;
  int type_;
  friend struct ::protobuf_mysqlx_5fexpr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ColumnIdentifier : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.ColumnIdentifier) */ {
 public:
  ColumnIdentifier();
  virtual ~ColumnIdentifier();

  ColumnIdentifier(const ColumnIdentifier& from);

  inline ColumnIdentifier& operator=(const ColumnIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ColumnIdentifier(ColumnIdentifier&& from) noexcept
    : ColumnIdentifier() {
    *this = ::std::move(from);
  }

  inline ColumnIdentifier& operator=(ColumnIdentifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ColumnIdentifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColumnIdentifier* internal_default_instance() {
    return reinterpret_cast<const ColumnIdentifier*>(
               &_ColumnIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ColumnIdentifier* other);
  friend void swap(ColumnIdentifier& a, ColumnIdentifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ColumnIdentifier* New() const final {
    return CreateMaybeMessage<ColumnIdentifier>(NULL);
  }

  ColumnIdentifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ColumnIdentifier>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ColumnIdentifier& from);
  void MergeFrom(const ColumnIdentifier& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ColumnIdentifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 1;
  int document_path_size() const;
  void clear_document_path();
  static const int kDocumentPathFieldNumber = 1;
  ::Mysqlx::Expr::DocumentPathItem* mutable_document_path(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >*
      mutable_document_path();
  const ::Mysqlx::Expr::DocumentPathItem& document_path(int index) const;
  ::Mysqlx::Expr::DocumentPathItem* add_document_path();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >&
      document_path() const;

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string table_name = 3;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 3;
  const ::std::string& table_name() const;
  void set_table_name(const ::std::string& value);
  #if LANG_CXX11
  void set_table_name(::std::string&& value);
  #endif
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  ::std::string* mutable_table_name();
  ::std::string* release_table_name();
  void set_allocated_table_name(::std::string* table_name);

  // optional string schema_name = 4;
  bool has_schema_name() const;
  void clear_schema_name();
  static const int kSchemaNameFieldNumber = 4;
  const ::std::string& schema_name() const;
  void set_schema_name(const ::std::string& value);
  #if LANG_CXX11
  void set_schema_name(::std::string&& value);
  #endif
  void set_schema_name(const char* value);
  void set_schema_name(const char* value, size_t size);
  ::std::string* mutable_schema_name();
  ::std::string* release_schema_name();
  void set_allocated_schema_name(::std::string* schema_name);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.ColumnIdentifier)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_table_name();
  void clear_has_table_name();
  void set_has_schema_name();
  void clear_has_schema_name();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem > document_path_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr table_name_;
  ::google::protobuf::internal::ArenaStringPtr schema_name_;
  friend struct ::protobuf_mysqlx_5fexpr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FunctionCall : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.FunctionCall) */ {
 public:
  FunctionCall();
  virtual ~FunctionCall();

  FunctionCall(const FunctionCall& from);

  inline FunctionCall& operator=(const FunctionCall& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FunctionCall(FunctionCall&& from) noexcept
    : FunctionCall() {
    *this = ::std::move(from);
  }

  inline FunctionCall& operator=(FunctionCall&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FunctionCall& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FunctionCall* internal_default_instance() {
    return reinterpret_cast<const FunctionCall*>(
               &_FunctionCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(FunctionCall* other);
  friend void swap(FunctionCall& a, FunctionCall& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FunctionCall* New() const final {
    return CreateMaybeMessage<FunctionCall>(NULL);
  }

  FunctionCall* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FunctionCall>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const FunctionCall& from);
  void MergeFrom(const FunctionCall& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FunctionCall* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Expr.Expr param = 2;
  int param_size() const;
  void clear_param();
  static const int kParamFieldNumber = 2;
  ::Mysqlx::Expr::Expr* mutable_param(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_param();
  const ::Mysqlx::Expr::Expr& param(int index) const;
  ::Mysqlx::Expr::Expr* add_param();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      param() const;

  // required .Mysqlx.Expr.Identifier name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  private:
  const ::Mysqlx::Expr::Identifier& _internal_name() const;
  public:
  const ::Mysqlx::Expr::Identifier& name() const;
  ::Mysqlx::Expr::Identifier* release_name();
  ::Mysqlx::Expr::Identifier* mutable_name();
  void set_allocated_name(::Mysqlx::Expr::Identifier* name);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.FunctionCall)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr > param_;
  ::Mysqlx::Expr::Identifier* name_;
  friend struct ::protobuf_mysqlx_5fexpr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Operator : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.Operator) */ {
 public:
  Operator();
  virtual ~Operator();

  Operator(const Operator& from);

  inline Operator& operator=(const Operator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Operator(Operator&& from) noexcept
    : Operator() {
    *this = ::std::move(from);
  }

  inline Operator& operator=(Operator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Operator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Operator* internal_default_instance() {
    return reinterpret_cast<const Operator*>(
               &_Operator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Operator* other);
  friend void swap(Operator& a, Operator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Operator* New() const final {
    return CreateMaybeMessage<Operator>(NULL);
  }

  Operator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Operator>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Operator& from);
  void MergeFrom(const Operator& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Operator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Expr.Expr param = 2;
  int param_size() const;
  void clear_param();
  static const int kParamFieldNumber = 2;
  ::Mysqlx::Expr::Expr* mutable_param(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_param();
  const ::Mysqlx::Expr::Expr& param(int index) const;
  ::Mysqlx::Expr::Expr* add_param();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      param() const;

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Operator)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr > param_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_mysqlx_5fexpr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Object_ObjectField : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.Object.ObjectField) */ {
 public:
  Object_ObjectField();
  virtual ~Object_ObjectField();

  Object_ObjectField(const Object_ObjectField& from);

  inline Object_ObjectField& operator=(const Object_ObjectField& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Object_ObjectField(Object_ObjectField&& from) noexcept
    : Object_ObjectField() {
    *this = ::std::move(from);
  }

  inline Object_ObjectField& operator=(Object_ObjectField&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Object_ObjectField& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Object_ObjectField* internal_default_instance() {
    return reinterpret_cast<const Object_ObjectField*>(
               &_Object_ObjectField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Object_ObjectField* other);
  friend void swap(Object_ObjectField& a, Object_ObjectField& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Object_ObjectField* New() const final {
    return CreateMaybeMessage<Object_ObjectField>(NULL);
  }

  Object_ObjectField* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Object_ObjectField>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Object_ObjectField& from);
  void MergeFrom(const Object_ObjectField& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Object_ObjectField* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required .Mysqlx.Expr.Expr value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::Mysqlx::Expr::Expr& _internal_value() const;
  public:
  const ::Mysqlx::Expr::Expr& value() const;
  ::Mysqlx::Expr::Expr* release_value();
  ::Mysqlx::Expr::Expr* mutable_value();
  void set_allocated_value(::Mysqlx::Expr::Expr* value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Object.ObjectField)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::Mysqlx::Expr::Expr* value_;
  friend struct ::protobuf_mysqlx_5fexpr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Object : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.Object) */ {
 public:
  Object();
  virtual ~Object();

  Object(const Object& from);

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(Object&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Object& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Object* other);
  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Object* New() const final {
    return CreateMaybeMessage<Object>(NULL);
  }

  Object* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Object* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Object_ObjectField ObjectField;

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Expr.Object.ObjectField fld = 1;
  int fld_size() const;
  void clear_fld();
  static const int kFldFieldNumber = 1;
  ::Mysqlx::Expr::Object_ObjectField* mutable_fld(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField >*
      mutable_fld();
  const ::Mysqlx::Expr::Object_ObjectField& fld(int index) const;
  ::Mysqlx::Expr::Object_ObjectField* add_fld();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField >&
      fld() const;

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Object)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField > fld_;
  friend struct ::protobuf_mysqlx_5fexpr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Array : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.Array) */ {
 public:
  Array();
  virtual ~Array();

  Array(const Array& from);

  inline Array& operator=(const Array& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Array(Array&& from) noexcept
    : Array() {
    *this = ::std::move(from);
  }

  inline Array& operator=(Array&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Array& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Array* internal_default_instance() {
    return reinterpret_cast<const Array*>(
               &_Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Array* other);
  friend void swap(Array& a, Array& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Array* New() const final {
    return CreateMaybeMessage<Array>(NULL);
  }

  Array* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Array>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Array& from);
  void MergeFrom(const Array& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Array* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Expr.Expr value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::Mysqlx::Expr::Expr* mutable_value(int index);
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_value();
  const ::Mysqlx::Expr::Expr& value(int index) const;
  ::Mysqlx::Expr::Expr* add_value();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      value() const;

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Array)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr > value_;
  friend struct ::protobuf_mysqlx_5fexpr_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Expr

// required .Mysqlx.Expr.Expr.Type type = 1;
inline bool Expr::has_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Expr::set_has_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Expr::clear_has_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Expr::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Mysqlx::Expr::Expr_Type Expr::type() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.type)
  return static_cast< ::Mysqlx::Expr::Expr_Type >(type_);
}
inline void Expr::set_type(::Mysqlx::Expr::Expr_Type value) {
  assert(::Mysqlx::Expr::Expr_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Expr.type)
}

// optional .Mysqlx.Expr.ColumnIdentifier identifier = 2;
inline bool Expr::has_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Expr::set_has_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Expr::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Expr::clear_identifier() {
  if (identifier_ != NULL) identifier_->Clear();
  clear_has_identifier();
}
inline const ::Mysqlx::Expr::ColumnIdentifier& Expr::_internal_identifier() const {
  return *identifier_;
}
inline const ::Mysqlx::Expr::ColumnIdentifier& Expr::identifier() const {
  const ::Mysqlx::Expr::ColumnIdentifier* p = identifier_;
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.identifier)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Expr::ColumnIdentifier*>(
      &::Mysqlx::Expr::_ColumnIdentifier_default_instance_);
}
inline ::Mysqlx::Expr::ColumnIdentifier* Expr::release_identifier() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.identifier)
  clear_has_identifier();
  ::Mysqlx::Expr::ColumnIdentifier* temp = identifier_;
  identifier_ = NULL;
  return temp;
}
inline ::Mysqlx::Expr::ColumnIdentifier* Expr::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::ColumnIdentifier>(GetArenaNoVirtual());
    identifier_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.identifier)
  return identifier_;
}
inline void Expr::set_allocated_identifier(::Mysqlx::Expr::ColumnIdentifier* identifier) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete identifier_;
  }
  if (identifier) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      identifier = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, identifier, submessage_arena);
    }
    set_has_identifier();
  } else {
    clear_has_identifier();
  }
  identifier_ = identifier;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.identifier)
}

// optional string variable = 3;
inline bool Expr::has_variable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Expr::set_has_variable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Expr::clear_has_variable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Expr::clear_variable() {
  variable_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_variable();
}
inline const ::std::string& Expr::variable() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.variable)
  return variable_.GetNoArena();
}
inline void Expr::set_variable(const ::std::string& value) {
  set_has_variable();
  variable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Expr.variable)
}
#if LANG_CXX11
inline void Expr::set_variable(::std::string&& value) {
  set_has_variable();
  variable_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.Expr.variable)
}
#endif
inline void Expr::set_variable(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_variable();
  variable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Expr.variable)
}
inline void Expr::set_variable(const char* value, size_t size) {
  set_has_variable();
  variable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Expr.variable)
}
inline ::std::string* Expr::mutable_variable() {
  set_has_variable();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.variable)
  return variable_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Expr::release_variable() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.variable)
  if (!has_variable()) {
    return NULL;
  }
  clear_has_variable();
  return variable_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Expr::set_allocated_variable(::std::string* variable) {
  if (variable != NULL) {
    set_has_variable();
  } else {
    clear_has_variable();
  }
  variable_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), variable);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.variable)
}

// optional .Mysqlx.Datatypes.Scalar literal = 4;
inline bool Expr::has_literal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Expr::set_has_literal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Expr::clear_has_literal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::Mysqlx::Datatypes::Scalar& Expr::_internal_literal() const {
  return *literal_;
}
inline const ::Mysqlx::Datatypes::Scalar& Expr::literal() const {
  const ::Mysqlx::Datatypes::Scalar* p = literal_;
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.literal)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Datatypes::Scalar*>(
      &::Mysqlx::Datatypes::_Scalar_default_instance_);
}
inline ::Mysqlx::Datatypes::Scalar* Expr::release_literal() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.literal)
  clear_has_literal();
  ::Mysqlx::Datatypes::Scalar* temp = literal_;
  literal_ = NULL;
  return temp;
}
inline ::Mysqlx::Datatypes::Scalar* Expr::mutable_literal() {
  set_has_literal();
  if (literal_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Datatypes::Scalar>(GetArenaNoVirtual());
    literal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.literal)
  return literal_;
}
inline void Expr::set_allocated_literal(::Mysqlx::Datatypes::Scalar* literal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(literal_);
  }
  if (literal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      literal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, literal, submessage_arena);
    }
    set_has_literal();
  } else {
    clear_has_literal();
  }
  literal_ = literal;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.literal)
}

// optional .Mysqlx.Expr.FunctionCall function_call = 5;
inline bool Expr::has_function_call() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Expr::set_has_function_call() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Expr::clear_has_function_call() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Expr::clear_function_call() {
  if (function_call_ != NULL) function_call_->Clear();
  clear_has_function_call();
}
inline const ::Mysqlx::Expr::FunctionCall& Expr::_internal_function_call() const {
  return *function_call_;
}
inline const ::Mysqlx::Expr::FunctionCall& Expr::function_call() const {
  const ::Mysqlx::Expr::FunctionCall* p = function_call_;
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.function_call)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Expr::FunctionCall*>(
      &::Mysqlx::Expr::_FunctionCall_default_instance_);
}
inline ::Mysqlx::Expr::FunctionCall* Expr::release_function_call() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.function_call)
  clear_has_function_call();
  ::Mysqlx::Expr::FunctionCall* temp = function_call_;
  function_call_ = NULL;
  return temp;
}
inline ::Mysqlx::Expr::FunctionCall* Expr::mutable_function_call() {
  set_has_function_call();
  if (function_call_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::FunctionCall>(GetArenaNoVirtual());
    function_call_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.function_call)
  return function_call_;
}
inline void Expr::set_allocated_function_call(::Mysqlx::Expr::FunctionCall* function_call) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete function_call_;
  }
  if (function_call) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      function_call = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, function_call, submessage_arena);
    }
    set_has_function_call();
  } else {
    clear_has_function_call();
  }
  function_call_ = function_call;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.function_call)
}

// optional .Mysqlx.Expr.Operator operator = 6;
inline bool Expr::has_operator_() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Expr::set_has_operator_() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Expr::clear_has_operator_() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Expr::clear_operator_() {
  if (operator__ != NULL) operator__->Clear();
  clear_has_operator_();
}
inline const ::Mysqlx::Expr::Operator& Expr::_internal_operator_() const {
  return *operator__;
}
inline const ::Mysqlx::Expr::Operator& Expr::operator_() const {
  const ::Mysqlx::Expr::Operator* p = operator__;
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.operator)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Operator*>(
      &::Mysqlx::Expr::_Operator_default_instance_);
}
inline ::Mysqlx::Expr::Operator* Expr::release_operator_() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.operator)
  clear_has_operator_();
  ::Mysqlx::Expr::Operator* temp = operator__;
  operator__ = NULL;
  return temp;
}
inline ::Mysqlx::Expr::Operator* Expr::mutable_operator_() {
  set_has_operator_();
  if (operator__ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Operator>(GetArenaNoVirtual());
    operator__ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.operator)
  return operator__;
}
inline void Expr::set_allocated_operator_(::Mysqlx::Expr::Operator* operator_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete operator__;
  }
  if (operator_) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      operator_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, operator_, submessage_arena);
    }
    set_has_operator_();
  } else {
    clear_has_operator_();
  }
  operator__ = operator_;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.operator)
}

// optional uint32 position = 7;
inline bool Expr::has_position() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Expr::set_has_position() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Expr::clear_has_position() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Expr::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 Expr::position() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.position)
  return position_;
}
inline void Expr::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Expr.position)
}

// optional .Mysqlx.Expr.Object object = 8;
inline bool Expr::has_object() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Expr::set_has_object() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Expr::clear_has_object() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Expr::clear_object() {
  if (object_ != NULL) object_->Clear();
  clear_has_object();
}
inline const ::Mysqlx::Expr::Object& Expr::_internal_object() const {
  return *object_;
}
inline const ::Mysqlx::Expr::Object& Expr::object() const {
  const ::Mysqlx::Expr::Object* p = object_;
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.object)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Object*>(
      &::Mysqlx::Expr::_Object_default_instance_);
}
inline ::Mysqlx::Expr::Object* Expr::release_object() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.object)
  clear_has_object();
  ::Mysqlx::Expr::Object* temp = object_;
  object_ = NULL;
  return temp;
}
inline ::Mysqlx::Expr::Object* Expr::mutable_object() {
  set_has_object();
  if (object_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Object>(GetArenaNoVirtual());
    object_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.object)
  return object_;
}
inline void Expr::set_allocated_object(::Mysqlx::Expr::Object* object) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete object_;
  }
  if (object) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      object = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    set_has_object();
  } else {
    clear_has_object();
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.object)
}

// optional .Mysqlx.Expr.Array array = 9;
inline bool Expr::has_array() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Expr::set_has_array() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Expr::clear_has_array() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Expr::clear_array() {
  if (array_ != NULL) array_->Clear();
  clear_has_array();
}
inline const ::Mysqlx::Expr::Array& Expr::_internal_array() const {
  return *array_;
}
inline const ::Mysqlx::Expr::Array& Expr::array() const {
  const ::Mysqlx::Expr::Array* p = array_;
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.array)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Array*>(
      &::Mysqlx::Expr::_Array_default_instance_);
}
inline ::Mysqlx::Expr::Array* Expr::release_array() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.array)
  clear_has_array();
  ::Mysqlx::Expr::Array* temp = array_;
  array_ = NULL;
  return temp;
}
inline ::Mysqlx::Expr::Array* Expr::mutable_array() {
  set_has_array();
  if (array_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Array>(GetArenaNoVirtual());
    array_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.array)
  return array_;
}
inline void Expr::set_allocated_array(::Mysqlx::Expr::Array* array) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete array_;
  }
  if (array) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      array = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, array, submessage_arena);
    }
    set_has_array();
  } else {
    clear_has_array();
  }
  array_ = array;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.array)
}

// -------------------------------------------------------------------

// Identifier

// required string name = 1;
inline bool Identifier::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Identifier::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Identifier::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Identifier::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Identifier::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Identifier.name)
  return name_.GetNoArena();
}
inline void Identifier::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Identifier.name)
}
#if LANG_CXX11
inline void Identifier::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.Identifier.name)
}
#endif
inline void Identifier::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Identifier.name)
}
inline void Identifier::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Identifier.name)
}
inline ::std::string* Identifier::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Identifier.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Identifier.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Identifier.name)
}

// optional string schema_name = 2;
inline bool Identifier::has_schema_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Identifier::set_has_schema_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Identifier::clear_has_schema_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Identifier::clear_schema_name() {
  schema_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_schema_name();
}
inline const ::std::string& Identifier::schema_name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Identifier.schema_name)
  return schema_name_.GetNoArena();
}
inline void Identifier::set_schema_name(const ::std::string& value) {
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Identifier.schema_name)
}
#if LANG_CXX11
inline void Identifier::set_schema_name(::std::string&& value) {
  set_has_schema_name();
  schema_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.Identifier.schema_name)
}
#endif
inline void Identifier::set_schema_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Identifier.schema_name)
}
inline void Identifier::set_schema_name(const char* value, size_t size) {
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Identifier.schema_name)
}
inline ::std::string* Identifier::mutable_schema_name() {
  set_has_schema_name();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Identifier.schema_name)
  return schema_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier::release_schema_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Identifier.schema_name)
  if (!has_schema_name()) {
    return NULL;
  }
  clear_has_schema_name();
  return schema_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_schema_name(::std::string* schema_name) {
  if (schema_name != NULL) {
    set_has_schema_name();
  } else {
    clear_has_schema_name();
  }
  schema_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schema_name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Identifier.schema_name)
}

// -------------------------------------------------------------------

// DocumentPathItem

// required .Mysqlx.Expr.DocumentPathItem.Type type = 1;
inline bool DocumentPathItem::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DocumentPathItem::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DocumentPathItem::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DocumentPathItem::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Mysqlx::Expr::DocumentPathItem_Type DocumentPathItem::type() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.DocumentPathItem.type)
  return static_cast< ::Mysqlx::Expr::DocumentPathItem_Type >(type_);
}
inline void DocumentPathItem::set_type(::Mysqlx::Expr::DocumentPathItem_Type value) {
  assert(::Mysqlx::Expr::DocumentPathItem_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.DocumentPathItem.type)
}

// optional string value = 2;
inline bool DocumentPathItem::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentPathItem::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentPathItem::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentPathItem::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& DocumentPathItem::value() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.DocumentPathItem.value)
  return value_.GetNoArena();
}
inline void DocumentPathItem::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.DocumentPathItem.value)
}
#if LANG_CXX11
inline void DocumentPathItem::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.DocumentPathItem.value)
}
#endif
inline void DocumentPathItem::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.DocumentPathItem.value)
}
inline void DocumentPathItem::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.DocumentPathItem.value)
}
inline ::std::string* DocumentPathItem::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.DocumentPathItem.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DocumentPathItem::release_value() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.DocumentPathItem.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DocumentPathItem::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.DocumentPathItem.value)
}

// optional uint32 index = 3;
inline bool DocumentPathItem::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentPathItem::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentPathItem::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentPathItem::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 DocumentPathItem::index() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.DocumentPathItem.index)
  return index_;
}
inline void DocumentPathItem::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.DocumentPathItem.index)
}

// -------------------------------------------------------------------

// ColumnIdentifier

// repeated .Mysqlx.Expr.DocumentPathItem document_path = 1;
inline int ColumnIdentifier::document_path_size() const {
  return document_path_.size();
}
inline void ColumnIdentifier::clear_document_path() {
  document_path_.Clear();
}
inline ::Mysqlx::Expr::DocumentPathItem* ColumnIdentifier::mutable_document_path(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.ColumnIdentifier.document_path)
  return document_path_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >*
ColumnIdentifier::mutable_document_path() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.ColumnIdentifier.document_path)
  return &document_path_;
}
inline const ::Mysqlx::Expr::DocumentPathItem& ColumnIdentifier::document_path(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.ColumnIdentifier.document_path)
  return document_path_.Get(index);
}
inline ::Mysqlx::Expr::DocumentPathItem* ColumnIdentifier::add_document_path() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.ColumnIdentifier.document_path)
  return document_path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >&
ColumnIdentifier::document_path() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.ColumnIdentifier.document_path)
  return document_path_;
}

// optional string name = 2;
inline bool ColumnIdentifier::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnIdentifier::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnIdentifier::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnIdentifier::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ColumnIdentifier::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.ColumnIdentifier.name)
  return name_.GetNoArena();
}
inline void ColumnIdentifier::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.ColumnIdentifier.name)
}
#if LANG_CXX11
inline void ColumnIdentifier::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.ColumnIdentifier.name)
}
#endif
inline void ColumnIdentifier::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.ColumnIdentifier.name)
}
inline void ColumnIdentifier::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.ColumnIdentifier.name)
}
inline ::std::string* ColumnIdentifier::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.ColumnIdentifier.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnIdentifier::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.ColumnIdentifier.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnIdentifier::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.ColumnIdentifier.name)
}

// optional string table_name = 3;
inline bool ColumnIdentifier::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnIdentifier::set_has_table_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnIdentifier::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnIdentifier::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_table_name();
}
inline const ::std::string& ColumnIdentifier::table_name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.ColumnIdentifier.table_name)
  return table_name_.GetNoArena();
}
inline void ColumnIdentifier::set_table_name(const ::std::string& value) {
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.ColumnIdentifier.table_name)
}
#if LANG_CXX11
inline void ColumnIdentifier::set_table_name(::std::string&& value) {
  set_has_table_name();
  table_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.ColumnIdentifier.table_name)
}
#endif
inline void ColumnIdentifier::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.ColumnIdentifier.table_name)
}
inline void ColumnIdentifier::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.ColumnIdentifier.table_name)
}
inline ::std::string* ColumnIdentifier::mutable_table_name() {
  set_has_table_name();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.ColumnIdentifier.table_name)
  return table_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnIdentifier::release_table_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.ColumnIdentifier.table_name)
  if (!has_table_name()) {
    return NULL;
  }
  clear_has_table_name();
  return table_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnIdentifier::set_allocated_table_name(::std::string* table_name) {
  if (table_name != NULL) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
  table_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.ColumnIdentifier.table_name)
}

// optional string schema_name = 4;
inline bool ColumnIdentifier::has_schema_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ColumnIdentifier::set_has_schema_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ColumnIdentifier::clear_has_schema_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ColumnIdentifier::clear_schema_name() {
  schema_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_schema_name();
}
inline const ::std::string& ColumnIdentifier::schema_name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.ColumnIdentifier.schema_name)
  return schema_name_.GetNoArena();
}
inline void ColumnIdentifier::set_schema_name(const ::std::string& value) {
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.ColumnIdentifier.schema_name)
}
#if LANG_CXX11
inline void ColumnIdentifier::set_schema_name(::std::string&& value) {
  set_has_schema_name();
  schema_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.ColumnIdentifier.schema_name)
}
#endif
inline void ColumnIdentifier::set_schema_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.ColumnIdentifier.schema_name)
}
inline void ColumnIdentifier::set_schema_name(const char* value, size_t size) {
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.ColumnIdentifier.schema_name)
}
inline ::std::string* ColumnIdentifier::mutable_schema_name() {
  set_has_schema_name();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.ColumnIdentifier.schema_name)
  return schema_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnIdentifier::release_schema_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.ColumnIdentifier.schema_name)
  if (!has_schema_name()) {
    return NULL;
  }
  clear_has_schema_name();
  return schema_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnIdentifier::set_allocated_schema_name(::std::string* schema_name) {
  if (schema_name != NULL) {
    set_has_schema_name();
  } else {
    clear_has_schema_name();
  }
  schema_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schema_name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.ColumnIdentifier.schema_name)
}

// -------------------------------------------------------------------

// FunctionCall

// required .Mysqlx.Expr.Identifier name = 1;
inline bool FunctionCall::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionCall::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FunctionCall::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FunctionCall::clear_name() {
  if (name_ != NULL) name_->Clear();
  clear_has_name();
}
inline const ::Mysqlx::Expr::Identifier& FunctionCall::_internal_name() const {
  return *name_;
}
inline const ::Mysqlx::Expr::Identifier& FunctionCall::name() const {
  const ::Mysqlx::Expr::Identifier* p = name_;
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.FunctionCall.name)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Identifier*>(
      &::Mysqlx::Expr::_Identifier_default_instance_);
}
inline ::Mysqlx::Expr::Identifier* FunctionCall::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.FunctionCall.name)
  clear_has_name();
  ::Mysqlx::Expr::Identifier* temp = name_;
  name_ = NULL;
  return temp;
}
inline ::Mysqlx::Expr::Identifier* FunctionCall::mutable_name() {
  set_has_name();
  if (name_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Identifier>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.FunctionCall.name)
  return name_;
}
inline void FunctionCall::set_allocated_name(::Mysqlx::Expr::Identifier* name) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete name_;
  }
  if (name) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      name = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    set_has_name();
  } else {
    clear_has_name();
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.FunctionCall.name)
}

// repeated .Mysqlx.Expr.Expr param = 2;
inline int FunctionCall::param_size() const {
  return param_.size();
}
inline void FunctionCall::clear_param() {
  param_.Clear();
}
inline ::Mysqlx::Expr::Expr* FunctionCall::mutable_param(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.FunctionCall.param)
  return param_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
FunctionCall::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.FunctionCall.param)
  return &param_;
}
inline const ::Mysqlx::Expr::Expr& FunctionCall::param(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.FunctionCall.param)
  return param_.Get(index);
}
inline ::Mysqlx::Expr::Expr* FunctionCall::add_param() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.FunctionCall.param)
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
FunctionCall::param() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.FunctionCall.param)
  return param_;
}

// -------------------------------------------------------------------

// Operator

// required string name = 1;
inline bool Operator::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Operator::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Operator::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Operator::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Operator::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Operator.name)
  return name_.GetNoArena();
}
inline void Operator::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Operator.name)
}
#if LANG_CXX11
inline void Operator::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.Operator.name)
}
#endif
inline void Operator::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Operator.name)
}
inline void Operator::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Operator.name)
}
inline ::std::string* Operator::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Operator.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Operator::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Operator.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Operator::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Operator.name)
}

// repeated .Mysqlx.Expr.Expr param = 2;
inline int Operator::param_size() const {
  return param_.size();
}
inline void Operator::clear_param() {
  param_.Clear();
}
inline ::Mysqlx::Expr::Expr* Operator::mutable_param(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Operator.param)
  return param_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
Operator::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.Operator.param)
  return &param_;
}
inline const ::Mysqlx::Expr::Expr& Operator::param(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Operator.param)
  return param_.Get(index);
}
inline ::Mysqlx::Expr::Expr* Operator::add_param() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.Operator.param)
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
Operator::param() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.Operator.param)
  return param_;
}

// -------------------------------------------------------------------

// Object_ObjectField

// required string key = 1;
inline bool Object_ObjectField::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Object_ObjectField::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Object_ObjectField::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Object_ObjectField::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& Object_ObjectField::key() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Object.ObjectField.key)
  return key_.GetNoArena();
}
inline void Object_ObjectField::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Object.ObjectField.key)
}
#if LANG_CXX11
inline void Object_ObjectField::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.Object.ObjectField.key)
}
#endif
inline void Object_ObjectField::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Object.ObjectField.key)
}
inline void Object_ObjectField::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Object.ObjectField.key)
}
inline ::std::string* Object_ObjectField::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Object.ObjectField.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Object_ObjectField::release_key() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Object.ObjectField.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Object_ObjectField::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Object.ObjectField.key)
}

// required .Mysqlx.Expr.Expr value = 2;
inline bool Object_ObjectField::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Object_ObjectField::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Object_ObjectField::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Object_ObjectField::clear_value() {
  if (value_ != NULL) value_->Clear();
  clear_has_value();
}
inline const ::Mysqlx::Expr::Expr& Object_ObjectField::_internal_value() const {
  return *value_;
}
inline const ::Mysqlx::Expr::Expr& Object_ObjectField::value() const {
  const ::Mysqlx::Expr::Expr* p = value_;
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Object.ObjectField.value)
  return p != NULL ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline ::Mysqlx::Expr::Expr* Object_ObjectField::release_value() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Object.ObjectField.value)
  clear_has_value();
  ::Mysqlx::Expr::Expr* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::Mysqlx::Expr::Expr* Object_ObjectField::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Object.ObjectField.value)
  return value_;
}
inline void Object_ObjectField::set_allocated_value(::Mysqlx::Expr::Expr* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    set_has_value();
  } else {
    clear_has_value();
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Object.ObjectField.value)
}

// -------------------------------------------------------------------

// Object

// repeated .Mysqlx.Expr.Object.ObjectField fld = 1;
inline int Object::fld_size() const {
  return fld_.size();
}
inline void Object::clear_fld() {
  fld_.Clear();
}
inline ::Mysqlx::Expr::Object_ObjectField* Object::mutable_fld(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Object.fld)
  return fld_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField >*
Object::mutable_fld() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.Object.fld)
  return &fld_;
}
inline const ::Mysqlx::Expr::Object_ObjectField& Object::fld(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Object.fld)
  return fld_.Get(index);
}
inline ::Mysqlx::Expr::Object_ObjectField* Object::add_fld() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.Object.fld)
  return fld_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField >&
Object::fld() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.Object.fld)
  return fld_;
}

// -------------------------------------------------------------------

// Array

// repeated .Mysqlx.Expr.Expr value = 1;
inline int Array::value_size() const {
  return value_.size();
}
inline void Array::clear_value() {
  value_.Clear();
}
inline ::Mysqlx::Expr::Expr* Array::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Array.value)
  return value_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
Array::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.Array.value)
  return &value_;
}
inline const ::Mysqlx::Expr::Expr& Array::value(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Array.value)
  return value_.Get(index);
}
inline ::Mysqlx::Expr::Expr* Array::add_value() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.Array.value)
  return value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
Array::value() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.Array.value)
  return value_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Expr
}  // namespace Mysqlx

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Mysqlx::Expr::Expr_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::Mysqlx::Expr::DocumentPathItem_Type> : ::std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_mysqlx_5fexpr_2eproto
